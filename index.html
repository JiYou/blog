<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些有意思的事。">
<meta property="og:type" content="website">
<meta property="og:title" content="缘生故如幻">
<meta property="og:url" content="https://jiyou.github.io/blog/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="记录一些有意思的事。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘生故如幻">
<meta name="twitter:description" content="记录一些有意思的事。">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/stl">stl</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/ceph/" style="font-size: 10px;">ceph</a> <a href="/blog/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/stl/" style="font-size: 20px;">stl</a> <a href="/blog/tags/算法/" style="font-size: 15px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JiYou">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">code</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/stl">stl</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-stl/3.模板模板参数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/3.模板模板参数/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/3.模板模板参数/">1.3 模板模板参数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板的模板参数"><a href="#模板的模板参数" class="headerlink" title="模板的模板参数"></a>模板的模板参数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">int</span> i&gt; <span class="keyword">class</span> A &#123;</div><div class="line">   <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A&lt;T, <span class="number">5</span>&gt; &#123;</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> U&gt; <span class="keyword">class</span> B1 &#123; &#125;;</div><div class="line"></div><div class="line">B1&lt;A&gt; c;</div></pre></td></tr></table></figure>
<p>注意，这个代码是无法通过编译的。因为编译器在匹配模板参数的时候，是看全部参数的，不会去考虑<code>A</code>的偏特化版本。</p>
<p>The compiler considers the partial specializations based on a template template argument once you have instantiated a specialization based on the corresponding template template parameter. The following example demonstrates this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 声明一个A的Base模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 声明A的偏特化版本</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="keyword">class</span> A&lt;<span class="keyword">int</span>, U&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   V&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; i;</div><div class="line">   V&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 那么，在生成代码的时候，实际上生成的是</span></div><div class="line"><span class="comment">// class B &#123; A&lt;int, char&gt; i; A &lt;char,char&gt; j; &#125;</span></div><div class="line">B&lt;A&gt; c;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c.i.x).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c.j.x).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果仔细地看一下<code>B</code>这个类，就会发现，<code>T/U</code>好像没有什么用。因为在<code>B</code>的内部声明的里面从来没有用到这两个类型，如果要用这两个类型应该怎么办？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A&lt;T,U&gt; a_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样是会报错的，因为<code>template&lt;class T, class U&gt; class V</code>只会用来修饰类<code>V</code>而不会用来修饰<code>B</code>。所以在编译的时候，会在<code>B</code>里面说，<code>T/U</code>没有定义。</p>
<p>那么，如果想让<code>B</code>类里面有如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T t_;</div><div class="line">    U u_;</div><div class="line">    A&lt;T,U&gt; a_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>应该怎么办？</p>
<p>应该把<code>B</code>类的声明改成如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T t_;</div><div class="line">    U u_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="keyword">class</span> A&lt;<span class="keyword">int</span>, U&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> X, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    V&lt;T, U&gt; v_;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">B&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">float</span>, A&gt; c;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    c.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要特别注意看声明。在声明<code>V</code>的时候，所有的这个<code>V</code>会引用到的变量都是在<code>template&lt;typename T, typename U, typename X, ..&gt; B</code>也就是<code>T, U, X</code>这三个里面取。至于具体取哪个，并不能从<code>template</code>的声明里面看出来。</p>
<p>真正要实例化<code>V</code>类的时候，也就是<code>B</code>的内部声明的时候，才会知道<code>V</code>到底是怎么实例化的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">V&lt;T, U&gt; v_;</div><div class="line">V&lt;U, X&gt; ux_;</div></pre></td></tr></table></figure>
<p>所以可以总结一下，关于模析模板参数。</p>
<ul>
<li>如果模板模板参数想起作用，那么只能在<code>&lt;typename X, typename Y, typename Z, template&lt;class, class&gt; class V&gt;</code>里面取，并且声明模板板参数的时候，不能写明<code>template&lt;class T, class U&gt; class V</code>，而是需要写成<code>template&lt;class, class&gt; class V</code>这种形式，表示参数都从前面的列表里面选择。</li>
<li>如果是写成<code>template&lt;class T, class U&gt; class V</code>这种格式，并且<code>T/U</code>不在外部列表里面。比如<code>template&lt;typename T, typename U, typename X, template&lt;typename T, typename U&gt; class V&gt;</code>这里会因为<code>T/U</code>重复声明，导到编译不过。那么需要改写成<code>template&lt;typename T, typename U, typename X, template&lt;typename A, typename B&gt; class V&gt; class B {};</code>。但是按照这种写法，模板参数<code>A/B</code>就只能在<code>B</code>类定义的时候内部各种实例化，而不能在外部指定。</li>
</ul>
<p>所以，也可以总结成。</p>
<ul>
<li>如果想定义<code>B</code>类的时候，直接也把内部类<code>A</code>的定义决定了。那么，声明的时候，必须采用1.</li>
<li>如果想<code>B</code>类内部自由定义<code>A</code>类的实例化，那么必须采用格式2.</li>
</ul>
<h2 id="模板模板参数的取值范围"><a href="#模板模板参数的取值范围" class="headerlink" title="模板模板参数的取值范围"></a>模板模板参数的取值范围</h2><p>模板模板参数的取值范围可以是：</p>
<ul>
<li>类型声明在前面，比如<code>&lt;typename X, typename Y, typename Z, template&lt;class, class&gt; class V&gt;</code>。这个时候，类<code>V</code>的模板参数可取范围是<code>X, Y, Z</code>。</li>
<li>类型声明在后面，比如<code>&lt;template&lt;class, class&gt; class V, typename X, typename Y, typename Z&gt;</code>也是同样可以取到<code>X/Y/Z</code>的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> H, <span class="keyword">class</span> S&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> H&lt;S&gt; &amp;value)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> V, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(V&lt;T, A&gt; &amp;v)</span> </span>&#123;</div><div class="line">    <span class="comment">// This can be "typename V&lt;T, A&gt;::value_type",</span></div><div class="line">    <span class="comment">// but we are pretending we don't have it</span></div><div class="line"></div><div class="line">    T temp = v.back();</div><div class="line">    v.pop_back();</div><div class="line">    <span class="comment">// Do some work on temp</span></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="缺省值"><a href="#缺省值" class="headerlink" title="缺省值"></a>缺省值</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont = Deque&gt;</div><div class="line"><span class="keyword">class</span> Stack &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//...</span></div><div class="line">Stack&lt;<span class="keyword">int</span>&gt; aStack1; <span class="comment">// use default: Cont is Deque</span></div><div class="line">Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,List&gt; aStack2; <span class="comment">// Cont is List</span></div></pre></td></tr></table></figure>
<p>只是需要注意的是，这里的<code>Deque</code>的声明也需要是<code>template &lt;typename&gt; class Deque { };</code>这样。也就是只有一个模板参数。</p>
<p><strong>注意</strong>这里的<code>Deque</code>不是<code>STL</code>里面<code>Deque</code>。</p>
<h1 id="无用的模板参数"><a href="#无用的模板参数" class="headerlink" title="无用的模板参数"></a>无用的模板参数</h1><p>有时候，如果采用如下声明，会导致相同的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Vec &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> V&gt;</div><div class="line"><span class="keyword">class</span> Wrap &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>在这里，<code>Wrap</code>的声明得到的效果就与</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> V&gt;</div><div class="line"><span class="keyword">class</span> Wrap &#123; &#125;;</div></pre></td></tr></table></figure>
<p>得到同样的效果。因为<code>template&lt;template&lt;typename T&gt; typename V&gt;</code>会导致<code>V</code>没有参数范围可以选择。只能在内部指定类型。</p>
<p>同理，可以扩展到多个参数的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element,</div><div class="line">    <span class="keyword">class</span> Allocator&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3;</div></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3;</div></pre></td></tr></table></figure>
<p>这两个也应该是等价的。在使用的时候，都需要在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3 &#123;</div><div class="line">    Cont&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt; cont_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样的声明方式。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/3.模板模板参数" data-title="1.3 模板模板参数" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/5.模板实例化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/5.模板实例化/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/5.模板实例化/">1.5 模板实例化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实例化的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">指在编译或链接时生成函数模板或类模板的具体实例源代码，即用使用模板时的实参类型替换模板类型参数（还有非类型参数和模板型参数）；</div></pre></td></tr></table></figure>
<p>有点类似于C语言中的宏来生成代码。</p>
<h1 id="实例化的方式"><a href="#实例化的方式" class="headerlink" title="实例化的方式"></a>实例化的方式</h1><ul>
<li>隐式实例化（implicit instantiation）：当使用实例化的模板时自动地在当前代码单元之前插入模板的实例化代码，模板的成员函数一直到引用时才被实例化；</li>
<li>显式实例化（explicit instantiation）：直接声明模板实例化，模板所有成员立即都被实例化；</li>
</ul>
<p>实例化也是一种<code>偏特化</code>，被称为实例化的特例（instantiated (or generated) specialization）。</p>
<h1 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h1><p>由于隐式实例化的存在，也就是编译的报错会推迟，导致出错信息特别长。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> X &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;typenmae T&gt;</div><div class="line"><span class="keyword">class</span> Y &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Z &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    X&lt;Y&gt; x_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以发现这个依赖链条比较长<code>Z-&gt;X-&gt;Y</code>，如果一旦出错，那么这个编译出错信息会特别长。所以针对模板而言，尽量在做测试时将其实例化掉。尽早发现编译错误。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/5.模板实例化" data-title="1.5 模板实例化" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/1.type_traits" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/1.type_traits/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/1.type_traits/">1.1 type_traits</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="If-else的结构"><a href="#If-else的结构" class="headerlink" title="If else的结构"></a>If else的结构</h1><p>有时候想在编译的时候，实现这样的效果，就是根据传入的值来决定需要产生的类型。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(type X, type Y)</span> </span>&#123;</div><div class="line">    <span class="comment">// if a == true 定义类型X</span></div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">bool</span> a = <span class="literal">true</span>/<span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (a) &#123;</div><div class="line">        X var;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Y var;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果想在这里引用var，应该怎么办?</span></div><div class="line">    <span class="comment">// ?? 实际上是不能在这里用的。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一种解决办法是，写一个父类，然后把<code>X/Y</code>声明成<code>Base</code>的子类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> Base &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X : <span class="keyword">public</span> Base &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> Base &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">bool</span> a, type X, type Y)</span> </span>&#123;</div><div class="line">    Base * b = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">if</span> (a) &#123;</div><div class="line">        b = <span class="keyword">new</span> X();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        b = <span class="keyword">new</span> Y();</div><div class="line">    &#125;</div><div class="line">    b.接口调用();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这么写会很烦人：</p>
<ol>
<li>引入了不必要的父类</li>
<li>XY可能已经有自己的父类</li>
<li>X/Y如果还需要与Z在其他地方生成这样的代码关系，那还得生成一个父类</li>
</ol>
<p>这个时候，采用面向对象的方法代码会写得比较丑，那么一种办法是引入模板偏特化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="keyword">bool</span>, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> cond &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> cond&lt;<span class="literal">false</span>, If, Then&gt;&#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> X&#123;&#125;;</div><div class="line"><span class="keyword">class</span> Y&#123;&#125;;</div><div class="line">cond&lt;<span class="literal">true</span>, X, Y&gt;::type 此时为 X</div><div class="line">cond&lt;<span class="literal">false</span>, X, Y&gt;::type 就是Y</div></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> Bool, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> cond &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> cond&lt;<span class="literal">false</span>, If, Then&gt;&#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> If &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"If"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Then &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Then"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// 需要注意的是，true/false这里需要是编译期间就可以决定的常量。</span></div><div class="line">    <span class="comment">// 不能写成bool a = true, 然后cond&lt;a, If, Then&gt;这样。</span></div><div class="line">    cond&lt;<span class="literal">true</span>, If, Then&gt;::type::print();</div><div class="line">    cond&lt;<span class="literal">false</span>, If, Then&gt;::type::print();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里相当于在进行类型运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">constexpr</span> <span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">return</span> type=X;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> type=Y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就需要引出后面要介绍的模板元编程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/1.type_traits" data-title="1.1 type_traits" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/6.模板的编译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/6.模板的编译/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/6.模板的编译/">1.5 模板的编译</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>模板的编译一般采用包含编译，(其他比较偏门的会介绍<code>export</code>啥的)，<code>export</code>已经被废止了，所以不再去研究。</p>
<p>正确的做法是:</p>
<ul>
<li>模板的实现都放到<code>.h</code>也就是头文件里面</li>
<li>使用的时候直接包含头文件</li>
</ul>
<p>在链接阶段，如果是因为模板生成的代码，比如类定义或者函数义有多份，那么会自动去重。</p>
<h1 id="嵌套类型依赖"><a href="#嵌套类型依赖" class="headerlink" title="嵌套类型依赖"></a>嵌套类型依赖</h1><p>假设想使用<code>T</code>类里面的<code>iterator</code>，如果代码写做如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> T&amp; container)</span></span></div><div class="line">&#123;</div><div class="line">    T::const_iterator * x;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于编译器并不清楚<code>const_iterator</code>是一个类型，还是静态变量，大多数情况下会认为是一个<code>静态变量</code>。但是，这里实际上是一个类型，所以这里会编译报错。</p>
<p>那么正确的写法应该是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> T&amp; container)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typename</span> T::const_iterator *x;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，在嵌套类型依赖的时候，需要明确的指出<code>typename</code>这个类型。</p>
<h1 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h1><p>只有2个地方是不需要在嵌套依赖的时候来指明<code>typename</code>的，那么就是声明继承的时候。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class Derived: public Base&lt;T&gt;::Nested // 1. 这里不需要</div><div class="line">&#123;</div><div class="line">　public:</div><div class="line">　　explicit Derived(int x)</div><div class="line">　　: Base&lt;T&gt;::Nested(x) //  2. 这里也不需要</div><div class="line">　　&#123;</div><div class="line">　　　typename Base&lt;T&gt;::Nested temp; //nested dependent type, need typename</div><div class="line">　　&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如，这里<code>Nested</code>就是<code>Base&lt;T&gt;</code>里面的一个类型。实际上，这里也很明显，那就是继承肯定是继承于类型，而不是一个静态变量。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/6.模板的编译" data-title="1.5 模板的编译" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/4.模板特化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/4.模板特化/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/4.模板特化/">1.3 模板偏特化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h1><p>前面介绍过，模板的偏特化可以有两种形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; &#123;</div><div class="line">    <span class="keyword">float</span> v_[<span class="number">4</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">bool</span>, N&gt;&#123;</div><div class="line">    <span class="keyword">char</span> v_[(N+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>)];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>把所有的参数具体化，比如<code>T = float, N = 4</code></li>
<li>把部分参数具体化，比如<code>T = bool</code></li>
</ul>
<p>需要注意的是，已经被具体化的参数就不要再出现在<code>template&lt;&gt;</code>这里面了。如果所有的参数都被具体化的，那么<code>template&lt;&gt;</code>这里面就什么都没有了。</p>
<p>比较复杂的是两种情况，也就是模板特化与<code>模板模板参数</code>混在一起的时候。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T t_;</div><div class="line">    U u_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="keyword">class</span> A&lt;<span class="keyword">int</span>, U&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// V这里的参数只能从T/U/X里面选择。</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> X, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    V&lt;T, U&gt; v_;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">B&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">float</span>, A&gt; c;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    c.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着再分析另外一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> i&gt; <span class="keyword">class</span> Arg; <span class="comment">// 用于模板型模板参数</span></div><div class="line"><span class="comment">// 通例</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">int</span> i, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">int</span>&gt; <span class="keyword">class</span> CP&gt;</div><div class="line"><span class="keyword">class</span> Example &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 完全特例化</span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">class</span> Example&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="number">2</span>, Arg&gt;;</div><div class="line"></div><div class="line"><span class="comment">// 第一个参数有const修饰</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">int</span> i, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">int</span>&gt; <span class="keyword">class</span> CP&gt;</div><div class="line"><span class="keyword">class</span> Example&lt;<span class="keyword">const</span> T1, T2, i, CP&gt; &#123; &#125;;</div></pre></td></tr></table></figure>
<p>需要注意的是后面的那个<code>class CP</code>在选择类型的时候，只能从<code>T1/T2/i</code>里面选择了。</p>
<h1 id="类型组合的特化"><a href="#类型组合的特化" class="headerlink" title="类型组合的特化"></a>类型组合的特化</h1><p>再看一个有趣的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一二个参数为Arg的实例且满足一定关系，第四个参数为Arg</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> i&gt;</div><div class="line"><span class="keyword">class</span> Example&lt;Arg&lt;T, i&gt;, Arg&lt;T, i+<span class="number">10</span>&gt;, i, Arg&gt; &#123; &#125;;</div></pre></td></tr></table></figure>
<p>也就是说，在特化的时候，可以写成这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;参数范围A&gt;</div><div class="line"><span class="keyword">class</span> Example&lt;由A范围组合出按照顺序满足条件的这个具体类型即可&gt; &#123; &#125;;</div></pre></td></tr></table></figure>
<p>那么在类里面使用<code>Arg</code>的时候，可以选择的参数范围就是已知的类型。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> i&gt; <span class="keyword">class</span> Arg&#123; &#125;; <span class="comment">// 用于模板型模板参数</span></div><div class="line"><span class="comment">// 通例</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">int</span> i, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">int</span>&gt; <span class="keyword">class</span> CP&gt;</div><div class="line"><span class="keyword">class</span> Example &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> i&gt;</div><div class="line"><span class="keyword">class</span> Example&lt;<span class="keyword">const</span> T, Arg&lt;T,i+<span class="number">10</span>&gt;, i, Arg&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Arg&lt;T, i&gt; s_;</div><div class="line">    Arg&lt;<span class="keyword">const</span> T, i&gt; a_;</div><div class="line">    Arg&lt;Arg&lt;T,i&gt;,i&gt; b_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以，可以看出<code>Arg</code>这个模板类可以使用<code>T,i, const T, Arg&lt;T,i+10&gt;, i,</code>都可以。</p>
<p>关于模板特化</p>
<ul>
<li>Base模板需要提前声明</li>
<li>如果模板A是模板B的子集，优先匹配A。</li>
<li>如果两个模板有交集，且不成子集关系，编译报错。</li>
</ul>
<h1 id="模板偏特化元编程"><a href="#模板偏特化元编程" class="headerlink" title="模板偏特化元编程"></a>模板偏特化元编程</h1><p>可以利用偏特化来实现<code>if/else</code>对类型的操作。比如判断两个类型是否相等。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line"><span class="keyword">struct</span> is_same &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_same&lt;T,T&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 自定义类型，只是用来测试is_same模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Example &#123; &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</div><div class="line">    <span class="keyword">typedef</span> uint uint2;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_same&lt;<span class="keyword">unsigned</span>, uint2&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_same&lt;Example&lt;<span class="keyword">unsigned</span>, <span class="number">2</span>&gt;, Example&lt;uint2, <span class="number">2</span>&gt;&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_same&lt;Example&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;, Example&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt;&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line">template&lt;int N&gt;</div><div class="line">struct order &#123;</div><div class="line">    static constexpr int64_t value = N * order&lt;N-1&gt;::value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 由于只有一个参数需要偏特化，所以</div><div class="line">// 这里用template&lt;&gt;</div><div class="line">template&lt;&gt;</div><div class="line">struct order&lt;0&gt; &#123;</div><div class="line">    static constexpr int64_t value = 1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line">    std::cout &lt;&lt; order&lt;10&gt;::value &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/4.模板特化" data-title="1.3 模板偏特化" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/2.模板简介" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/2.模板简介/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/2.模板简介/">1.2 模板元编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板示例"><a href="#模板示例" class="headerlink" title="模板示例"></a>模板示例</h1><p>这里自己实现一个判断两个对象是否相等的模板函数。同时也定义一个模板类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equ</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !(a &lt; b) &amp;&amp; !(b &lt; a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> number &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    number(<span class="keyword">const</span> T &amp;v): v_(v) &#123; &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number &amp;n) <span class="keyword">const</span> ;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T v_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">bool</span> number&lt;T&gt;::<span class="keyword">operator</span> &lt;(<span class="keyword">const</span> number &amp;n) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> v_ &lt; n.v_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    number&lt;<span class="keyword">int</span>&gt; a(<span class="number">1</span>), b(<span class="number">1</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; equ(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; equ&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>, <span class="number">2.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模板的参数"><a href="#模板的参数" class="headerlink" title="模板的参数"></a>模板的参数</h1><ul>
<li>类型参数（type template parameter），用 typename 或 class 标记；(最好是用<code>typename</code>)</li>
<li>非类型参数（non-type template parameter）可以是：整数及枚举类型、对象或函数的指针、对象或函数的引用、对象的成员指针，非类型参数是模板实例的常量；</li>
<li>模板型参数（template template parameter），如<code>template&lt;typename T, template&lt;typename&gt; class A&gt; someclass {};</code>；</li>
<li>模板参数可以有默认值（函数模板参数默认是从 C++11 开始支持）；</li>
<li>函数模板的和函数参数类型有关的模板参数可以自动推导，<strong>类模板参数不存在推导机制</strong>；</li>
<li>C++11 引入变长模板参数。</li>
</ul>
<p>总结一下：</p>
<ul>
<li>参数必须是字面量。无论常数，类型，自定义类型，模板类型都是编译时的常量。运行时的变量是不能用的。</li>
<li>类和函数模板参数都可以有默认值</li>
<li>函数可以自动推导，类模板不可以。</li>
</ul>
<p><strong>运行时变量不可以</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; &#123;</div><div class="line">    <span class="keyword">float</span> v_[<span class="number">4</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">bool</span>, N&gt;&#123;</div><div class="line">    <span class="keyword">char</span> v_[(N+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>)];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;        <span class="comment">// 这里是一个变量</span></div><div class="line">    Vec&lt;<span class="keyword">bool</span>, N&gt; bits; <span class="comment">// Compile ERROR! 利用变量来模板化类</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么函数是否可以呢？</p>
<h1 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h1><p>特化的时候，可以：</p>
<ul>
<li>将<code>Base</code>模板里面的类具体化。</li>
<li>只具体化某个模板参数，其他的保留。</li>
</ul>
<h2 id="所有的参数具体化"><a href="#所有的参数具体化" class="headerlink" title="所有的参数具体化"></a>所有的参数具体化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; &#123;</div><div class="line">    <span class="keyword">float</span> v_[<span class="number">4</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如在<code>base</code>类里面声明了两个参数，这两个参数都可以具体化。<code>T = float, N = 4</code>。</p>
<h2 id="具体化某部分参数"><a href="#具体化某部分参数" class="headerlink" title="具体化某部分参数"></a>具体化某部分参数</h2><p><code>base</code>类的参数是<code>typename T, int N</code>，那么可不可以只具体化<code>typename T = bool</code>呢？答案是可以的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">bool</span>, N&gt; &#123;</div><div class="line">    <span class="keyword">char</span> v_[(N+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>)];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>术语:</p>
<ul>
<li><p>最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（<code>full specialization</code>），</p>
</li>
<li><p>另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（<code>partial specialization</code>）</p>
</li>
</ul>
<p>用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/2.模板简介" data-title="1.2 模板元编程" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/222" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/222/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/222/">LeetCode.22 反转二叉树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Invert a binary tree.</div><div class="line"></div><div class="line">Example:</div><div class="line"></div><div class="line">Input:</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div><div class="line">Output:</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="简洁写法"><a href="#简洁写法" class="headerlink" title="简洁写法"></a>简洁写法</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">invertTree_recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</div><div class="line">        TreeNode* node = invertTree_recursive(root-&gt;left);</div><div class="line">        root-&gt;left = invertTree_recursive(root-&gt;right);</div><div class="line">        root-&gt;right = node;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="带栈"><a href="#带栈" class="headerlink" title="带栈"></a>带栈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 带栈的写法</div><div class="line">TreeNode* invertTree(TreeNode* root) &#123;</div><div class="line">    if (!root) return nullptr;</div><div class="line">    stack&lt;TreeNode*&gt; s;</div><div class="line">    s.push(root);</div><div class="line">    while (!s.empty()) &#123;</div><div class="line">        auto p = s.top(); s.pop();</div><div class="line">        std::swap(p-&gt;left, p-&gt;right);</div><div class="line">        if (p-&gt;left) s.push(p-&gt;left);</div><div class="line">        if (p-&gt;right) s.push(p-&gt;right);</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/222" data-title="LeetCode.22 反转二叉树" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/22" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/22/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/22/">LeetCode.22 合法括号对的总排列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定括号的对数。要求写出程序。把所有可能的，符合运算括号排列的都输出出来。</p>
<h1 id="总的结果数目"><a href="#总的结果数目" class="headerlink" title="总的结果数目"></a>总的结果数目</h1><p>比如当给定括号 的对数为n的时候。总的字符数是n*2。那么总的结果可能是:</p>
<p>相当于有<code>2*n</code>个箱子。每个箱子可以选择’(‘或者’)’。那么总的数目有<code>2^(n&lt;&lt;1)</code>个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> total_size = (<span class="number">1</span>&lt;&lt;(n&lt;&lt;<span class="number">1</span>)) + <span class="number">1</span>;</div><div class="line"><span class="keyword">char</span> **ret = (<span class="keyword">char</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * total_size);</div><div class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * total_size);</div></pre></td></tr></table></figure>
<h1 id="第pos个字符应该放什么"><a href="#第pos个字符应该放什么" class="headerlink" title="第pos个字符应该放什么?"></a>第pos个字符应该放什么?</h1><p>由于所有的结果都已经放到了<code>ret</code>中。并且有一个<code>ret_tail</code>记录ret中接下来的空箱子的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i = <span class="number">0</span> : ret &#123;</div><div class="line">    字符串 = ret[i]</div><div class="line">    根据  字符串 里面的(/)符号数</div><div class="line">        决定在后面追加的内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环体可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line">ret[<span class="number">0</span>] = <span class="string">"("</span>;</div><div class="line"><span class="keyword">for</span> (pos = <span class="number">1</span>; pos &lt; (n&lt;&lt;<span class="number">1</span>); pos++) &#123;</div><div class="line">    <span class="comment">// 当前字符串的数目</span></div><div class="line">    cnt = ret_tail;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</div><div class="line">        <span class="built_in">string</span> = ret[i];</div><div class="line">        如果不生成新的字符串，直接在ret[i]上追加字符</div><div class="line">        如果需要生成新的字符串，ret_tail申请空间，复制ret[i],然后追加字符到ret[ret_tail];</div><div class="line">            ret_tail++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加速判断"><a href="#加速判断" class="headerlink" title="加速判断"></a>加速判断</h2><p>为了加速判断，每个字符串申请的空间是:</p>
<ol>
<li>先与4 bytes对齐</li>
<li>再多申请4个int的空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">|........string......|...|used|left|</div></pre></td></tr></table></figure>
<p>也就是前面都是正常的C字符串。只不过在这个字符串后面，多申请了一段空间用来存放<code>used/left</code>。</p>
<ul>
<li>used表示<code>(</code>用了多少？</li>
<li>left表示<code>)</code>抵消的<code>(</code>还留下多少？比如<code>(()</code>这里的<code>used=2, left = 1</code>。</li>
</ul>
<p>把这两个<code>int</code>与字符串一起放的原因是容易申请内存。也跟随字符串一起，容易定位与操作。<br>所以这里生成了两个宏，专门用来取<code>used/left</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_COUNT(p, l) ((int*)(p + l - sizeof(int)))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> USED_COUNT(p, l) ((int*)(p + l - 2*sizeof(int)))</span></div></pre></td></tr></table></figure>
<p>有了<code>used/left</code>之后。生成新的字符串的时候，<code>used/left</code>的值，就直接在原有的字符串上累加就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_char</span><span class="params">(<span class="keyword">char</span> **ret, <span class="keyword">const</span> <span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">size_t</span> str_len, <span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">    assert(!ret[i][pos]);</div><div class="line">    ret[i][pos] = c;</div><div class="line">    <span class="keyword">int</span> *left = LEFT_COUNT(ret[i], str_len);</div><div class="line">    <span class="keyword">int</span> *used = USED_COUNT(ret[i], str_len);</div><div class="line">    <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</div><div class="line">        *left += <span class="number">1</span>;</div><div class="line">        *used += <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;        </div><div class="line">        *left -= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Return an array of size *returnSize.</div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line">#define ROUND_UP(x) ((((x) + 3) &gt;&gt; 2) &lt;&lt; 2)</div><div class="line">#define LEFT_COUNT(p, l) ((int*)(p + l - sizeof(int)))</div><div class="line">#define USED_COUNT(p, l) ((int*)(p + l - 2*sizeof(int)))</div><div class="line"></div><div class="line">void set_char(char **ret, const size_t i, const size_t pos, const size_t str_len, char c) &#123;</div><div class="line">    assert(!ret[i][pos]);</div><div class="line">    ret[i][pos] = c;</div><div class="line">    int *left = LEFT_COUNT(ret[i], str_len);</div><div class="line">    int *used = USED_COUNT(ret[i], str_len);</div><div class="line">    if (c == '(') &#123;</div><div class="line">        *left += 1;</div><div class="line">        *used += 1;</div><div class="line">    &#125; else &#123;        </div><div class="line">        *left -= 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dup_string(char **ret, const size_t from, const size_t to, const size_t str_len, int* returnSize) &#123;</div><div class="line">    assert(!ret[to]);</div><div class="line">    ret[to] = (char*) malloc(sizeof(char) * str_len);</div><div class="line">    memcpy(ret[to], ret[from], sizeof(char) * str_len);</div><div class="line">    *returnSize += 1; // ERROR: *returnSize + 1 -&gt; *returnSize += 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">char** generateParenthesis(int n, int* returnSize) &#123;</div><div class="line">    if (0 == n) &#123;</div><div class="line">        *returnSize = 0;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t total_size = (1&lt;&lt;(n&lt;&lt;1)) + 1;</div><div class="line">    char **ret = (char**) malloc(sizeof(char*) * total_size);</div><div class="line">    memset(ret, 0, sizeof(char*) * total_size);</div><div class="line">    </div><div class="line">    size_t str_len = ROUND_UP(n&lt;&lt;1) + (sizeof(int)&lt;&lt;2);</div><div class="line">    ret[0] = (char*) malloc(sizeof(char) * str_len);</div><div class="line">    *returnSize = 1; // ERROR: 这里也需要初始化为1</div><div class="line">    memset(ret[0], 0, sizeof(char) * str_len);</div><div class="line"></div><div class="line">    /*需要填充的字符串的位置，其中第一个位置能只填(*/</div><div class="line">    set_char(ret, 0, 0, str_len, '(');</div><div class="line"></div><div class="line">    /*指向需要填充的尾巴, ret_tail中还没有字符串生成*/</div><div class="line">    size_t ret_tail = 1;</div><div class="line"></div><div class="line">    /*其他位置*/</div><div class="line">    for (size_t pos = 1; pos &lt; (n&lt;&lt;1); pos++) &#123;</div><div class="line">        /*遍历里面的每个字符串*/</div><div class="line">        const size_t cnt = ret_tail;</div><div class="line">        for (size_t i = 0; i &lt; cnt; i++) &#123;</div><div class="line">            assert(ret[i]);</div><div class="line">            //assert(ret_tail &lt;= (1&lt;&lt;n));</div><div class="line"></div><div class="line">            char *p = ret[i];</div><div class="line">            int *left = LEFT_COUNT(p, str_len);</div><div class="line">            int *used = USED_COUNT(p, str_len);</div><div class="line"></div><div class="line">            /*如果(已经用光, 且left为0*/</div><div class="line">            if (*used == n &amp;&amp; 0 == *left) continue;</div><div class="line">            </div><div class="line">            /*如果(用光，但是left还有，只能补)*/</div><div class="line">            if (*used == n &amp;&amp; *left &gt; 0) &#123;</div><div class="line">                set_char(ret, i, pos, str_len, ')');</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            assert(*used &lt; n);</div><div class="line">            /*还有(没有用光，那么有两种情况:注意先复制!!可以省掉处理旧字符的情况*/</div><div class="line">            if (*left &gt; 0) &#123;</div><div class="line">                // b. 放(</div><div class="line">                dup_string(ret, i, ret_tail, str_len, returnSize);</div><div class="line">                set_char(ret, ret_tail, pos, str_len, '(');</div><div class="line">                ret_tail++;</div><div class="line"></div><div class="line">                // a. 放)</div><div class="line">                set_char(ret, i, pos, str_len, ')');</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /*left == 0, 只能放(*/</div><div class="line">            assert(*left == 0);</div><div class="line">            set_char(ret, i, pos, str_len, '(');</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/22" data-title="LeetCode.22 合法括号对的总排列" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/17" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/17/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/17/">LeetCode.17 九键字母组合</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目含义"><a href="#题目含义" class="headerlink" title="题目含义"></a>题目含义</h1><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p>对于这样的一个按键。如果按下一串数字，会出现什么样的字母组合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: &quot;23&quot;</div><div class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div></pre></td></tr></table></figure>
<p>输出的时候，不需要考虑顺序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>总的思想还是比较简单的。首先根据每个数字上面的字母数，得到结果总数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> len_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="number">4</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="number">4</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">    <span class="comment">/*计算总的结果数*/</span></div><div class="line">    *returnSize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = digits;</div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        (*returnSize) *= len_rec[*p] &gt; <span class="number">0</span> ? len_rec[*p] : <span class="number">1</span>;</div><div class="line">        p++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>得到总的结果数之后，可以一次性地把所有需要动态申请的内存都申请完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*申请结果空间*/</span></div><div class="line"><span class="keyword">size_t</span> retSize = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * (*returnSize + <span class="number">1</span>);</div><div class="line"><span class="keyword">char</span> **ret = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(retSize);</div><div class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, retSize);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">    <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>);</div><div class="line">    ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">    <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始处理，比如给定的数字串是”999”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 第一个数字为<span class="number">9</span></div><div class="line">   生成相应的字符串</div><div class="line">   ar1 = </div><div class="line">   [</div><div class="line">    <span class="string">"w"</span>,</div><div class="line">    <span class="string">"x"</span>,</div><div class="line">    <span class="string">"y"</span>,</div><div class="line">    <span class="string">"z"</span>,</div><div class="line">   ]</div><div class="line"></div><div class="line"><span class="number">2.</span> 第二个数字为<span class="number">9</span></div><div class="line">   ar2 = []</div><div class="line">   <span class="keyword">for</span> c in <span class="string">"wxyz"</span>:</div><div class="line">       新数组 = ar1 + c;</div><div class="line">       ar2 = [ar2; 新数组]</div><div class="line">   如果把循环展开，就是</div><div class="line">   c = <span class="string">"w"</span></div><div class="line">   新数组 = [<span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>]</div><div class="line">   ar2 = [<span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>]</div><div class="line">   </div><div class="line">   第二次循环</div><div class="line">   c = <span class="string">"x"</span></div><div class="line">   新数组 = [<span class="string">"wx"</span>, <span class="string">"xx"</span>, <span class="string">"yx"</span>, <span class="string">"zx"</span>]</div><div class="line">   ar2 = [</div><div class="line">   <span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>,</div><div class="line">   <span class="string">"wx"</span>, <span class="string">"xx"</span>, <span class="string">"yx"</span>, <span class="string">"zx"</span>,</div><div class="line">   ]</div><div class="line">   ...</div><div class="line">   </div><div class="line">   假设ar1长度为N。</div><div class="line">   那么后面每次循环的时候，只需要把</div><div class="line">   这N个字符串拷贝到新的位置。</div><div class="line">        a. 第一次添加的是<span class="number">0</span>~N<span class="number">-1</span></div><div class="line">        b. 第二次处理的字符串是N~<span class="number">2</span>N<span class="number">-1</span></div><div class="line">        c. 第三次处理的是<span class="number">2</span>N~<span class="number">3</span>N<span class="number">-1</span></div><div class="line"><span class="number">3.</span> 递归处理第三个数字</div></pre></td></tr></table></figure>
<p>这段代码的关键就是在:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</div><div class="line"><span class="comment">// pos指向当前需要处理的是哪个数字</span></div><div class="line"><span class="comment">// 同时也是结果字符串需要填充的字符</span></div><div class="line"><span class="comment">// 串的位置。</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 这段代码利用9-&gt;"wxyz"中的"w"来生成</div><div class="line"> * ar1，并且得到长度len(ar1);</div><div class="line"> */</div><div class="line"><span class="keyword">size_t</span> pos = str - a;</div><div class="line"><span class="keyword">while</span> (ret[i][<span class="number">0</span>]) &#123;  <span class="comment">// ERROR: ret[i] -&gt; ret[i][0]</span></div><div class="line">    ret[i][pos] = *dic;</div><div class="line">    assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; retLen);</div><div class="line">    assert(<span class="number">0</span> &lt;= pos &amp;&amp; pos &lt; dstrLen);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * curlen就是指len(ar1);</div><div class="line"> */</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> curlen = i;</div><div class="line"><span class="comment">// *p指向9-&gt;wxyz中的第二个字母x</span></div><div class="line"><span class="keyword">char</span> *p = dic + <span class="number">1</span>;</div><div class="line"><span class="comment">// 从第二个字母开始依次处理每个字母</span></div><div class="line"><span class="keyword">while</span> (*p) &#123;</div><div class="line">    <span class="keyword">size_t</span> npos = (p-dic)*curlen;</div><div class="line">    <span class="comment">// 在处理的时候，把</span></div><div class="line">    <span class="comment">// [0, len(ar1))拷贝到</span></div><div class="line">    <span class="comment">// [i*len(ar1), (i+1)*len(ar1) )</span></div><div class="line">    <span class="comment">// 然后再修改pos位置的字母</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; curlen; i++) &#123;</div><div class="line">        <span class="comment">// 注意处理的字符串</span></div><div class="line">        <span class="built_in">strcpy</span>(ret[npos + i], ret[i]);</div><div class="line">        assert(<span class="number">0</span> &lt;= (npos+i) &amp;&amp; (npos+i) &lt; retLen);</div><div class="line">        assert(<span class="number">0</span> &lt;= pos &amp;&amp; pos &lt; dstrLen);</div><div class="line">        ret[npos+i][pos] = *p;</div><div class="line">    &#125;</div><div class="line">    p++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里并没有使用任何第三方库。直接使用一下递归就可以了。</p>
<h1 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*单字符串快速查找*/</span></div><div class="line"><span class="keyword">char</span>* str_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="string">"abc"</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="string">"def"</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="string">"ghi"</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="string">"jkl"</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="string">"mno"</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="string">"pqrs"</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="string">"tuv"</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="string">"wxyz"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> len_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="number">4</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="number">4</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 这里递归进行处理</div><div class="line"> * str指向当前要处理的字符指针</div><div class="line"> * ret已经申请好所有的空间。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">append_char</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">char</span> *str, <span class="keyword">char</span> **ret)</span> </span>&#123;</div><div class="line">    <span class="comment">/*已经结束*/</span></div><div class="line">    <span class="keyword">if</span> (!str || !(*str)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*当前字符映射过去的字符串*/</span></div><div class="line">    <span class="keyword">char</span> *dic = str_rec[*str];</div><div class="line">    <span class="keyword">if</span> (!dic || !(*dic)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/*处理dic里面的第一个字符*/</span></div><div class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> pos = str - a;</div><div class="line">    <span class="keyword">while</span> (ret[i][<span class="number">0</span>]) &#123;  <span class="comment">// ERROR: ret[i] -&gt; ret[i][0]</span></div><div class="line">        ret[i][pos] = *dic;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*当前ret的长度*/</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> curlen = i;</div><div class="line">    <span class="keyword">char</span> *p = dic + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        <span class="keyword">size_t</span> npos = (p-dic)*curlen;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; curlen; i++) &#123;</div><div class="line">            <span class="built_in">strcpy</span>(ret[npos + i], ret[i]);</div><div class="line">            ret[npos+i][pos] = *p;</div><div class="line">        &#125;</div><div class="line">        p++;</div><div class="line">    &#125;</div><div class="line">    append_char(a, str + <span class="number">1</span>, ret);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Return an array of size *returnSize.</div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">char</span>** <span class="title">letterCombinations</span><span class="params">(<span class="keyword">char</span>* digits, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</div><div class="line">    <span class="comment">/*如果为空串*/</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == digits || *digits == <span class="number">0</span>) &#123;</div><div class="line">        *returnSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*计算总的结果数*/</span></div><div class="line">    *returnSize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = digits;</div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        (*returnSize) *= len_rec[*p] &gt; <span class="number">0</span> ? len_rec[*p] : <span class="number">1</span>;</div><div class="line">        p++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* d_len表示当前数字串的长度，</span></div><div class="line">     * 结果字符串的长度是d_len + 1</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> d_len = p - digits;</div><div class="line"></div><div class="line">    <span class="comment">/*申请结果空间*/</span></div><div class="line">    <span class="keyword">size_t</span> retSize = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * (*returnSize + <span class="number">1</span>);</div><div class="line">    <span class="keyword">char</span> **ret = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(retSize);</div><div class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, retSize);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">        <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>); <span class="comment">// 这里要多申请一个char</span></div><div class="line">        ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">        <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);    <span class="comment">// ERROR: 这里一定要把n长度的字符串清0，而不只是d_len</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*处理第一个字符*/</span></div><div class="line">    <span class="keyword">char</span> *str = str_rec[*digits];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;  str[i]; i++) &#123;</div><div class="line">        ret[i][<span class="number">0</span>] = str[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    append_char(digits, digits + <span class="number">1</span>, ret);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在提交的时候，总是遇到</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">sysmalloc: Assertion `(old_top == (((mbinptr) (((char *) &amp;((av)-&gt;bins[((1) - 1) * 2])) - __builtin_offsetof (struct malloc_chunk, fd)))) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= (unsigned long)((((__builtin_offsetof (struct malloc_chunk, fd_nextsize))+((2 *(sizeof(size_t))) - 1)) &amp; ~((2 *(sizeof(size_t))) - 1))) &amp;&amp; ((old_top)-&gt;size &amp; 0x1) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0)' failed.</div></pre></td></tr></table></figure>
<p>说的是内存访问越界。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 这里在申请内存的时候，要多一个char</span></div><div class="line"><span class="comment">// 并且要把申请的内存空间请0.</span></div><div class="line"><span class="comment">// memset(ret[i], 0, d_len);会导致上面那个错. </span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">    <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>); <span class="comment">// ERROR: 这里要多申请一个char!!!</span></div><div class="line">    ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">    <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);    <span class="comment">// ERROR: 这里一定要把n长度的字符串清0，而不只是d_len</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/17" data-title="LeetCode.17 九键字母组合" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/10/" class="article-date">
  	<time datetime="2018-05-02T02:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/10/">LeetCode.10 正则表达式匹配</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，以及一个正则表达式。<br>判断给定的正则表达式是否可以表示字符串。</p>
<p>这里并没有让所有的正则表达式的符号都参与进来。<br>只是让’*’, ‘.’这两个符号加进来了。且字符串中只有<code>a~z</code>小写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">* 吃掉前面的字符，或者无视自己，或者把前面的字符重复x次。</div><div class="line">. 可以匹配任意字符</div></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">a*有好几种解释</div><div class="line"><span class="number">1.</span> 空串后面的*把a吃掉</div><div class="line"><span class="number">2.</span> a, *自身没有起任何作用</div><div class="line"><span class="number">3.</span> aa重复<span class="number">1</span>次</div><div class="line"><span class="number">4.</span> aaa重复<span class="number">2</span>次</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.* 万能字符串，可以表示任何字符在重复的时候，也可以写成....这样。</div><div class="line">** 后面的*可以选择吃掉前面的字符。前面的字符*可能的一种选项就是忽略自己。</div><div class="line">   1. 空串</div><div class="line">   2. *</div><div class="line">   3. **</div><div class="line">   4. ***</div></pre></td></tr></table></figure>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>这个题的做法是典型的深度优先搜索。不过在处理的时候，可以考虑预处理一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> x*x*如果出现在正则表达式里面。实际上是可以简化成x*的。</div><div class="line"><span class="number">2.</span> x*x*x*可以优化成x*</div></pre></td></tr></table></figure>
<p>预处理的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len_p = <span class="built_in">strlen</span>(p);</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = len_p - <span class="number">1</span>; i &gt; <span class="number">1</span>; --i) &#123;</div><div class="line">        <span class="comment">// 匹配x*x*这种情况, i指向后面的那个x</span></div><div class="line">        <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; p[i + <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; p[i] == p[i - <span class="number">2</span>]) &#123;</div><div class="line">            memmove(p + i, p + i + <span class="number">2</span>, len_p - i - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 经过上面的处理，x*x*x*可以被缩减为x*</span></div><div class="line">    <span class="comment">// 这里开始进行match匹配</span></div><div class="line">    <span class="keyword">return</span> match_sub(s, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进行匹配的时候，首先可以考虑没有<code>&#39;*&#39;</code>号的情况。比如。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">abc 与 a.c</div><div class="line">abc 与 bdc</div><div class="line"><span class="string">""</span>  与 pg</div><div class="line"><span class="literal">NULL</span> 与 abc</div></pre></td></tr></table></figure>
<p>这种都特别容易判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> same(a,b) ((a)==(b) || (<span class="meta-string">'.'</span>) == (b))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match_sub</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;*p &amp;&amp; *(p + <span class="number">1</span>) != <span class="string">'*'</span>; ++s, ++p)</div><div class="line">        <span class="keyword">if</span> (!s|| !*s || !same(*s, *p))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 此时*p == 0或p[1] == '*'</span></div><div class="line">    <span class="keyword">if</span> (!*p) <span class="keyword">return</span> <span class="literal">NULL</span> == s || *s == <span class="number">0</span>;</div><div class="line">    <span class="comment">// 此时p[1] 必然为'*'</span></div><div class="line">    </div><div class="line">    <span class="comment">// 如果当前字符相等，此时p[1] == '*'</span></div><div class="line">    <span class="comment">// 那么可以选择</span></div><div class="line">    <span class="comment">// 1. 重复 match_sub(s+1, p)</span></div><div class="line">    <span class="comment">// 2. 利用*吃掉当前字符 match_sub(s, p+2);</span></div><div class="line">    <span class="comment">// 3. a*b, *号可以选择无视自己.那么就是match_sub(s+1, p+2);</span></div><div class="line">    <span class="keyword">if</span> (*s &amp;&amp; same(*s, *p))</div><div class="line">        <span class="keyword">return</span>  match_sub(s + <span class="number">1</span>, p) || match_sub(s, p + <span class="number">2</span>) || match_sub(s+<span class="number">1</span>, p+<span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> match_sub(s, p + <span class="number">2</span>);</div><div class="line">    <span class="comment">// 除此之外的其他情况，比如*s == 0 || !same</span></div><div class="line">    <span class="comment">// 那么只能利用*号吃掉当前字符</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/10" data-title="LeetCode.10 正则表达式匹配" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>