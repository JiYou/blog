<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些有意思的事。">
<meta property="og:type" content="website">
<meta property="og:title" content="缘生故如幻">
<meta property="og:url" content="https://jiyou.github.io/blog/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="记录一些有意思的事。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘生故如幻">
<meta name="twitter:description" content="记录一些有意思的事。">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/stl">stl</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/ceph/" style="font-size: 16.67px;">ceph</a> <a href="/blog/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/stl/" style="font-size: 20px;">stl</a> <a href="/blog/tags/算法/" style="font-size: 13.33px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JiYou">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">code</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/stl">stl</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-ceph/6.store_test.cc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/08/01/ceph/6.store_test.cc/" class="article-date">
  	<time datetime="2018-08-01T05:28:32.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/08/01/ceph/6.store_test.cc/">1.5 store_test.cc代码阅读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight"><table><tr><td class="code"><pre><div class="line">// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-</div><div class="line">// vim: ts=8 sw=2 smarttab</div><div class="line">/*</div><div class="line"> * Ceph - scalable distributed file system</div><div class="line"> *</div><div class="line"> * Copyright (C) 2004-2006 Sage Weil &lt;sage@newdream.net&gt;</div><div class="line"> *</div><div class="line"> * This is free software; you can redistribute it and/or</div><div class="line"> * modify it under the terms of the GNU Lesser General Public</div><div class="line"> * License version 2.1, as published by the Free Software</div><div class="line"> * Foundation.  See file COPYING.</div><div class="line"> *</div><div class="line"> */</div><div class="line">using namespace std::placeholders;</div><div class="line"></div><div class="line">typedef boost::mt11213b gen_type;</div><div class="line"></div><div class="line">const uint64_t DEF_STORE_TEST_BLOCKDEV_SIZE = 10240000000;</div><div class="line">#define dout_context g_ceph_context</div><div class="line"></div><div class="line">#define GTEST_HAS_PARAM_TEST 1</div><div class="line">#if GTEST_HAS_PARAM_TEST</div><div class="line"></div><div class="line">// 检测两个bufferlist是否相等</div><div class="line">// 注意不是两个string是否相等</div><div class="line">// 类似于</div><div class="line">// ["a", "a", "a", "b"]</div><div class="line">// ["aa", "ab"]</div><div class="line">// 这两个bufferlist应该是相等的。</div><div class="line">static bool bl_eq(bufferlist&amp; expected, bufferlist&amp; actual)</div><div class="line">&#123;</div><div class="line">    if (expected.contents_equal(actual))</div><div class="line">        return true;</div><div class="line"></div><div class="line">    unsigned first = 0;</div><div class="line">    if(expected.length() != actual.length()) &#123;</div><div class="line">        cout &lt;&lt; "--- buffer lengths mismatch " &lt;&lt; std::hex</div><div class="line">             &lt;&lt; "expected 0x" &lt;&lt; expected.length() &lt;&lt; " != actual 0x"</div><div class="line">             &lt;&lt; actual.length() &lt;&lt; std::dec &lt;&lt; std::endl;</div><div class="line">        derr &lt;&lt; "--- buffer lengths mismatch " &lt;&lt; std::hex</div><div class="line">             &lt;&lt; "expected 0x" &lt;&lt; expected.length() &lt;&lt; " != actual 0x"</div><div class="line">             &lt;&lt; actual.length() &lt;&lt; std::dec &lt;&lt; dendl;</div><div class="line">    &#125;</div><div class="line">    auto len = std::min(expected.length(), actual.length());</div><div class="line">    while ( first&lt;len &amp;&amp; expected[first] == actual[first])</div><div class="line">        ++first;</div><div class="line">    unsigned last = len;</div><div class="line">    while (last &gt; 0 &amp;&amp; expected[last-1] == actual[last-1])</div><div class="line">        --last;</div><div class="line">    if(len &gt; 0) &#123;</div><div class="line">        cout &lt;&lt; "--- buffer mismatch between offset 0x" &lt;&lt; std::hex &lt;&lt; first</div><div class="line">             &lt;&lt; " and 0x" &lt;&lt; last &lt;&lt; ", total 0x" &lt;&lt; len &lt;&lt; std::dec</div><div class="line">             &lt;&lt; std::endl;</div><div class="line">        derr &lt;&lt; "--- buffer mismatch between offset 0x" &lt;&lt; std::hex &lt;&lt; first</div><div class="line">             &lt;&lt; " and 0x" &lt;&lt; last &lt;&lt; ", total 0x" &lt;&lt; len &lt;&lt; std::dec</div><div class="line">             &lt;&lt; dendl;</div><div class="line">        cout &lt;&lt; "--- expected:\n";</div><div class="line">        expected.hexdump(cout);</div><div class="line">        cout &lt;&lt; "--- actual:\n";</div><div class="line">        actual.hexdump(cout);</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">int queue_transaction(</div><div class="line">    T &amp;store,</div><div class="line">    ObjectStore::CollectionHandle ch,</div><div class="line">    ObjectStore::Transaction &amp;&amp;t)</div><div class="line">&#123;</div><div class="line">    if (rand() % 2) &#123;</div><div class="line">        // 这里生成一个空事务，然后把t包含进去</div><div class="line">        // 本质上是在测[]空事务，append实体事务的情况。</div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        t2.append(t);</div><div class="line">        return store-&gt;queue_transaction(ch, std::move(t2));</div><div class="line">    &#125; else &#123;</div><div class="line">        return store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">bool sorted(const vector&lt;ghobject_t&gt; &amp;in)</div><div class="line">&#123;</div><div class="line">    ghobject_t start;</div><div class="line">    for (vector&lt;ghobject_t&gt;::const_iterator i = in.begin();</div><div class="line">         i != in.end();</div><div class="line">         ++i) &#123;</div><div class="line">        if (start &gt; *i) &#123;</div><div class="line">            cout &lt;&lt; start &lt;&lt; " should follow " &lt;&lt; *i &lt;&lt; std::endl;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        start = *i;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这里设置统一测试参数const char *</div><div class="line">// 主要是为了测试各种bluestore, filestore, memstore, kvstore底层存储</div><div class="line"></div><div class="line">class StoreTest : public StoreTestFixture, public ::testing::WithParamInterface&lt;const char*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    // 获得参数，初始化</div><div class="line">    // 这里使用gtest::GetParam()</div><div class="line">    // 这是因为StoreTestFixture的构造函数的参数就是</div><div class="line">    // char *type</div><div class="line">    // 注意看一下文章：</div><div class="line">    // https://blog.csdn.net/breaksoftware/article/details/51059583</div><div class="line">    StoreTest() : StoreTestFixture(GetParam()) &#123;&#125;</div><div class="line">    // 压缩测试</div><div class="line">    void doCompressionTest();</div><div class="line">    // 合成的，人造的测试</div><div class="line">    void doSyntheticTest(</div><div class="line">        int num_ops,</div><div class="line">        uint64_t max_obj, uint64_t max_wr, uint64_t align);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StoreTestDeferredSetup : public StoreTest</div><div class="line">&#123;</div><div class="line">    void SetUp() override</div><div class="line">    &#123;</div><div class="line">        //do nothing</div><div class="line">    &#125;</div><div class="line"></div><div class="line">protected:</div><div class="line">    void DeferredSetup()</div><div class="line">    &#123;</div><div class="line">        StoreTest::SetUp();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StoreTestSpecificAUSize : public StoreTestDeferredSetup</div><div class="line">&#123;</div><div class="line"></div><div class="line">public:</div><div class="line">    // 这里定义在不同配置下需要运行的函数</div><div class="line">    typedef</div><div class="line">    std::function&lt;void(</div><div class="line">        uint64_t num_ops,</div><div class="line">        uint64_t max_obj,</div><div class="line">        uint64_t max_wr,</div><div class="line">        uint64_t align)&gt; MatrixTest;</div><div class="line"></div><div class="line">    void StartDeferred(size_t min_alloc_size)</div><div class="line">    &#123;</div><div class="line">        SetVal(g_conf, "bluestore_min_alloc_size", stringify(min_alloc_size).c_str());</div><div class="line">        DeferredSetup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    // bluestore matrix testing</div><div class="line">    uint64_t max_write = 40 * 1024;</div><div class="line">    uint64_t max_size = 400 * 1024;</div><div class="line">    uint64_t alignment = 0;</div><div class="line">    uint64_t num_ops = 10000;</div><div class="line"></div><div class="line">protected:</div><div class="line">    string matrix_get(const char *k)</div><div class="line">    &#123;</div><div class="line">        if (string(k) == "max_write") &#123;</div><div class="line">            return stringify(max_write);</div><div class="line">        &#125; else if (string(k) == "max_size") &#123;</div><div class="line">            return stringify(max_size);</div><div class="line">        &#125; else if (string(k) == "alignment") &#123;</div><div class="line">            return stringify(alignment);</div><div class="line">        &#125; else if (string(k) == "num_ops") &#123;</div><div class="line">            return stringify(num_ops);</div><div class="line">        &#125; else &#123;</div><div class="line">            char *buf;</div><div class="line">            g_conf-&gt;get_val(k, &amp;buf, -1);</div><div class="line">            string v = buf;</div><div class="line">            free(buf);</div><div class="line">            return v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void matrix_set(const char *k, const char *v)</div><div class="line">    &#123;</div><div class="line">        if (string(k) == "max_write") &#123;</div><div class="line">            max_write = atoll(v);</div><div class="line">        &#125; else if (string(k) == "max_size") &#123;</div><div class="line">            max_size = atoll(v);</div><div class="line">        &#125; else if (string(k) == "alignment") &#123;</div><div class="line">            alignment = atoll(v);</div><div class="line">        &#125; else if (string(k) == "num_ops") &#123;</div><div class="line">            num_ops = atoll(v);</div><div class="line">        &#125; else &#123;</div><div class="line">            SetVal(g_conf, k, v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 整个函数结构来看就是一个DFS</div><div class="line">    // 会尝试matrix里面的所有的配置，然后</div><div class="line">    // 运行fn函数。</div><div class="line"></div><div class="line">    // matrix是一个二维矩阵，里面的每个元素都是一个字符串</div><div class="line">    // 这里相当于是只处理第i行</div><div class="line">    void do_matrix_choose(const char *matrix[][10],</div><div class="line">                          int i, int pos, int num,</div><div class="line">                          MatrixTest fn)</div><div class="line">    &#123;</div><div class="line">        // 如果这一行非空</div><div class="line">        if (matrix[i][0]) &#123;</div><div class="line">            // count是拿到第i行有多少字符串</div><div class="line">            int count;</div><div class="line">            for (count = 0; matrix[i][count+1]; ++count) ;</div><div class="line">            // 依次处理第i行里面的每个字符串</div><div class="line">            // 这里跳掉了第i行的第1个元素</div><div class="line">            // 然后开始设置第1~count个元素</div><div class="line">            for (int j = 1; matrix[i][j]; ++j) &#123;</div><div class="line">                // matrix[i][0]表示的是key值</div><div class="line">                matrix_set(matrix[i][0], matrix[i][j]);</div><div class="line">                do_matrix_choose(matrix,</div><div class="line">                                 i + 1,</div><div class="line">                                 pos * count + j - 1,</div><div class="line">                                 num * count,</div><div class="line">                                 fn);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            cout &lt;&lt; "---------------------- " &lt;&lt; (pos + 1) &lt;&lt; " / " &lt;&lt; num</div><div class="line">                 &lt;&lt; " ----------------------" &lt;&lt; std::endl;</div><div class="line">            for (unsigned k=0; matrix[k][0]; ++k) &#123;</div><div class="line">                cout &lt;&lt; "  " &lt;&lt; matrix[k][0] &lt;&lt; " = " &lt;&lt; matrix_get(matrix[k][0])</div><div class="line">                     &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">            fn(num_ops, max_size, max_write, alignment);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void do_matrix(const char *matrix[][10],</div><div class="line">                   MatrixTest fn)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        if (strcmp(matrix[0][0], "bluestore_min_alloc_size") == 0) &#123;</div><div class="line">            int count;</div><div class="line">            for (count = 0; matrix[0][count+1]; ++count) ;</div><div class="line">            for (size_t j = 1; matrix[0][j]; ++j) &#123;</div><div class="line">                if (j &gt; 1) &#123;</div><div class="line">                    // teardown主要是负责测试垃圾回收</div><div class="line">                    TearDown();</div><div class="line">                &#125;</div><div class="line">                StartDeferred(strtoll(matrix[0][j], NULL, 10));</div><div class="line">                do_matrix_choose(matrix, 1, j - 1, count, fn);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            StartDeferred(0);</div><div class="line">            do_matrix_choose(matrix, 0, 0, 1, fn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 第一个参数是类名，第二个参数是函数名</div><div class="line">TEST_P(StoreTest, collect_metadata)</div><div class="line">&#123;</div><div class="line">    // 这里可以直接访问类的内部成员</div><div class="line">    // store成员就是StoreTest里面的store成员。</div><div class="line">    map&lt;string,string&gt; pm;</div><div class="line">    store-&gt;collect_metadata(&amp;pm);</div><div class="line">    if (GetParam() == string("filestore")) &#123;</div><div class="line">        ASSERT_NE(pm.count("filestore_backend"), 0u);</div><div class="line">        ASSERT_NE(pm.count("filestore_f_type"), 0u);</div><div class="line">        ASSERT_NE(pm.count("backend_filestore_partition_path"), 0u);</div><div class="line">        ASSERT_NE(pm.count("backend_filestore_dev_node"), 0u);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Trivial)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, TrivialRemount)</div><div class="line">&#123;</div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleRemount)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    // 各种内部object的深入介绍</div><div class="line">    // http://bean-li.github.io/ceph-object-in-bottom/</div><div class="line">    // sobject表示清加了snaphot支持的object</div><div class="line">    // hobject表示支持hashed object，就是说这个object可以和具体的PG对应起来</div><div class="line">    // ghobject表示的是支持EC的object</div><div class="line">    // 这里生成两个对象</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line"></div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line"></div><div class="line">    // 这里是去要一个新的collection.</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + write" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid2, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, IORemount)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + objects" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // overwrites</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; "overwrites" &lt;&lt; std::endl;</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.remove(cid, hoid);</div><div class="line">        &#125;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, UnprintableCharsName)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    string name = "funnychars_";</div><div class="line">    for (unsigned i = 0; i &lt; 256; ++i) &#123;</div><div class="line">        name.push_back(i);</div><div class="line">    &#125;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t(name, CEPH_NOSNAP)));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + object" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; "removing" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, FiemapEmpty)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t("fiemap_object", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        t.truncate(cid, oid, 100000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, 0, 100000, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        e[0] = 100000;</div><div class="line">        EXPECT_TRUE(m == e || m.empty());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, FiemapHoles)</div><div class="line">&#123;</div><div class="line">    const uint64_t MAX_EXTENTS = 4000;</div><div class="line">    const uint64_t SKIP_STEP = 65536;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t("fiemap_object", CEPH_NOSNAP)));</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("foo");</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        for (uint64_t i = 0; i &lt; MAX_EXTENTS; i++)</div><div class="line">            t.write(cid, oid, SKIP_STEP * i, 3, bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //fiemap test from 0 to SKIP_STEP * (MAX_EXTENTS - 1) + 3</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, 0, SKIP_STEP * (MAX_EXTENTS - 1) + 3, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        ASSERT_TRUE(!m.empty());</div><div class="line">        ASSERT_GE(m[0], 3u);</div><div class="line">        auto last = m.crbegin();</div><div class="line">        if (m.size() == 1) &#123;</div><div class="line">            ASSERT_EQ(0u, last-&gt;first);</div><div class="line">        &#125; else if (m.size() == MAX_EXTENTS) &#123;</div><div class="line">            for (uint64_t i = 0; i &lt; MAX_EXTENTS; i++) &#123;</div><div class="line">                ASSERT_TRUE(m.count(SKIP_STEP * i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ASSERT_GT(last-&gt;first + last-&gt;second, SKIP_STEP * (MAX_EXTENTS - 1));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fiemap test from SKIP_STEP to SKIP_STEP * (MAX_EXTENTS - 2) + 3</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, SKIP_STEP, SKIP_STEP * (MAX_EXTENTS - 2) + 3, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        ASSERT_TRUE(!m.empty());</div><div class="line">        // kstore always returns [0, object_size] regardless of offset and length</div><div class="line">        // FIXME: if fiemap logic in kstore is refined</div><div class="line">        if (string(GetParam()) != "kstore") &#123;</div><div class="line">            ASSERT_GE(m[SKIP_STEP], 3u);</div><div class="line">            auto last = m.crbegin();</div><div class="line">            if (m.size() == 1) &#123;</div><div class="line">                ASSERT_EQ(SKIP_STEP, last-&gt;first);</div><div class="line">            &#125; else if (m.size() == MAX_EXTENTS - 2) &#123;</div><div class="line">                for (uint64_t i = 1; i &lt; MAX_EXTENTS - 1; i++) &#123;</div><div class="line">                    ASSERT_TRUE(m.count(SKIP_STEP*i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_GT(last-&gt;first + last-&gt;second, SKIP_STEP * (MAX_EXTENTS - 1));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleMetaColTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "add collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimplePGColTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(1,2), shard_id_t::NO_SHARD));</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        t.create_collection(cid, 4);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 4);</div><div class="line">        cerr &lt;&lt; "add collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleColPreHashTest)</div><div class="line">&#123;</div><div class="line">    // Firstly we will need to revert the value making sure</div><div class="line">    // collection hint actually works</div><div class="line">    int merge_threshold = g_ceph_context-&gt;_conf-&gt;filestore_merge_threshold;</div><div class="line">    std::ostringstream oss;</div><div class="line">    if (merge_threshold &gt; 0) &#123;</div><div class="line">        oss &lt;&lt; "-" &lt;&lt; merge_threshold;</div><div class="line">        SetVal(g_conf, "filestore_merge_threshold", oss.str().c_str());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint32_t pg_num = 128;</div><div class="line"></div><div class="line">    boost::uniform_int&lt;&gt; pg_id_range(0, pg_num);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    int pg_id = pg_id_range(rng);</div><div class="line"></div><div class="line">    int objs_per_folder = abs(merge_threshold) * 16 * g_ceph_context-&gt;_conf-&gt;filestore_split_multiple;</div><div class="line">    boost::uniform_int&lt;&gt; folders_range(5, 256);</div><div class="line">    uint64_t expected_num_objs = (uint64_t)objs_per_folder * (uint64_t)folders_range(rng);</div><div class="line"></div><div class="line">    coll_t cid(spg_t(pg_t(pg_id, 15), shard_id_t::NO_SHARD));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        // Create a collection along with a hint</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 5);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        bufferlist hint;</div><div class="line">        encode(pg_num, hint);</div><div class="line">        encode(expected_num_objs, hint);</div><div class="line">        t.collection_hint(cid, ObjectStore::Transaction::COLL_HINT_EXPECTED_NUM_OBJECTS, hint);</div><div class="line">        cerr &lt;&lt; "collection hint" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // Remove the collection</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallBlockWrites)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    bufferlist b;</div><div class="line">    bufferptr bp(0x1000);</div><div class="line">    memset(bp.c_str(), 'b', 0x1000);</div><div class="line">    b.append(bp);</div><div class="line">    bufferlist c;</div><div class="line">    bufferptr cp(0x1000);</div><div class="line">    memset(cp.c_str(), 'c', 0x1000);</div><div class="line">    c.append(cp);</div><div class="line">    bufferptr zp(0x1000);</div><div class="line">    zp.zero();</div><div class="line">    bufferlist z;</div><div class="line">    z.append(zp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        exp.append(a);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x1000, 0x1000, b);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x2000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x3000, 0x1000, c);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(z);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x2000, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 0x1000, c);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(c);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BufferCacheReadTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        t.write(cid, hoid, 10, 5, bl);</div><div class="line">        cerr &lt;&lt; "TwinWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 15, newdata);</div><div class="line">        ASSERT_EQ(r, 15);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(bl);</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //overwrite over the same extents</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append("edcba");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        t.write(cid, hoid, 10, 5, bl);</div><div class="line">        cerr &lt;&lt; "TwinWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 15, newdata);</div><div class="line">        ASSERT_EQ(r, 15);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(bl);</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //additional write to an unused region of some blob</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl2, newdata;</div><div class="line">        bl2.append("1234567890");</div><div class="line"></div><div class="line">        t.write(cid, hoid, 20, bl2.length(), bl2);</div><div class="line">        cerr &lt;&lt; "Append" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 30, newdata);</div><div class="line">        ASSERT_EQ(r, 30);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append("edcba");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append("edcba");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl2);</div><div class="line"></div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //additional write to an unused region of some blob and partial owerite over existing extents</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2, bl3, newdata;</div><div class="line">        bl.append("DCB");</div><div class="line">        bl2.append("1234567890");</div><div class="line">        bl3.append("BA");</div><div class="line"></div><div class="line">        t.write(cid, hoid, 30, bl2.length(), bl2);</div><div class="line">        t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 13, bl3.length(), bl3);</div><div class="line">        cerr &lt;&lt; "TripleWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 40, newdata);</div><div class="line">        ASSERT_EQ(r, 40);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append("eDCBa");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append("edcBA");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl2);</div><div class="line">            expected.append(bl2);</div><div class="line"></div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StoreTest::doCompressionTest()</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    std::string data;</div><div class="line">    data.resize(0x10000 * 4);</div><div class="line">    for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">        data[i] = i / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData (4xAU) Write" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, data.size() , newdata);</div><div class="line"></div><div class="line">        ASSERT_EQ(r, (int)data.size());</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 711 , newdata);</div><div class="line">        ASSERT_EQ(r, 711);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0,711));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0xf00f, data.size(), newdata);</div><div class="line">        ASSERT_EQ(r, int(data.size() - 0xf00f) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0xf00f));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.stored, (unsigned)data.size());</div><div class="line">            ASSERT_LE(statfs.compressed, (unsigned)data.size());</div><div class="line">            ASSERT_EQ(statfs.compressed_original, (unsigned)data.size());</div><div class="line">            ASSERT_LE(statfs.compressed_allocated, (unsigned)data.size());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    std::string data2;</div><div class="line">    data2.resize(0x10000 * 4 - 0x9000);</div><div class="line">    for(size_t i = 0; i &lt; data2.size(); i++)</div><div class="line">        data2[i] = (i+1) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x8000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData partial overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x10000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x10000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x8000));</div><div class="line">            expected.append(data2.substr(0, 0x8000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x9000, 711 , newdata);</div><div class="line">        ASSERT_EQ(r, 711);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x1000,711));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x0, 0x40000, newdata);</div><div class="line">        ASSERT_EQ(r, int(0x40000) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x8000));</div><div class="line">            expected.append(data2.substr(0, 0x37000));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    data2.resize(0x3f000);</div><div class="line">    for(size_t i = 0; i &lt; data2.size(); i++)</div><div class="line">        data2[i] = (i+2) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData partial overwrite, two extents overlapped, single one to be removed" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x3e000 - 1, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x3e000 - 1);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0, 0x3e000 - 1));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x3e000-1, 0x2001, newdata);</div><div class="line">        ASSERT_EQ(r, 0x2001);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x3e000-1, 0x1001));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x0, 0x40000, newdata);</div><div class="line">        ASSERT_EQ(r, int(0x40000) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0, 0x3f000));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    data.resize(0x1001);</div><div class="line">    for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">        data[i] = (i+3) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0x3f000-1, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Small chunk partial overwrite, two extents overlapped, single one to be removed" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x3e000, 0x2000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x2000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x3e000, 0x1000 - 1));</div><div class="line">            expected.append(data.substr(0, 0x1001));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Cleaning object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    auto settingsBookmark = BookmarkSettings();</div><div class="line">    SetVal(g_conf, "bluestore_compression_min_blob_size", "262144");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    &#123;</div><div class="line">        data.resize(0x10000*6);</div><div class="line"></div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i / 256;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData large blob" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, CompressionTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_algorithm", "snappy");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    doCompressionTest();</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_algorithm", "zlib");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "aggressive");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    doCompressionTest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleObjectTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append("abcde");</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, in);</div><div class="line">        ASSERT_EQ(5, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, exp;</div><div class="line">        bl.append("abcde");</div><div class="line">        exp = bl;</div><div class="line">        exp.append(bl);</div><div class="line">        t.write(cid, hoid, 5, 5, bl);</div><div class="line">        cerr &lt;&lt; "Append" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, exp;</div><div class="line">        bl.append("abcdeabcde");</div><div class="line">        exp = bl;</div><div class="line">        t.write(cid, hoid, 0, 10, bl);</div><div class="line">        cerr &lt;&lt; "Full overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 3, 5, bl);</div><div class="line">        cerr &lt;&lt; "Partial overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        exp.append("abcabcdede");</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append("fghij");</div><div class="line">            t.truncate(cid, hoid, 0);</div><div class="line">            t.write(cid, hoid, 5, 5, bl);</div><div class="line">            cerr &lt;&lt; "Truncate + hole" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append("abcde");</div><div class="line">            t.write(cid, hoid, 0, 5, bl);</div><div class="line">            cerr &lt;&lt; "Reverse fill-in" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        exp.append("abcdefghij");</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234");</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "larger overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, bl.length(), in);</div><div class="line">        ASSERT_EQ((int)bl.length(), r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(bl, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234");</div><div class="line"></div><div class="line">        //test: offset=len=0 mean read all data</div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0, in);</div><div class="line">        ASSERT_EQ((int)bl.length(), r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(bl, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //verifying unaligned csums</div><div class="line">        std::string s1("1"), s2(0x1000, '2'), s3("00");</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append(s1);</div><div class="line">            bl.append(s2);</div><div class="line">            t.truncate(cid, hoid, 0);</div><div class="line">            t.write(cid, hoid, 0x1000-1, bl.length(), bl);</div><div class="line">            cerr &lt;&lt; "Write unaligned csum, stage 1" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist in, exp1, exp2, exp3;</div><div class="line">        exp1.append(s1);</div><div class="line">        exp2.append(s2);</div><div class="line">        exp3.append(s3);</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000-1, 1, in);</div><div class="line">        ASSERT_EQ(1, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp1, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000, 0x1000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp2, in));</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append(s3);</div><div class="line">            t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">            cerr &lt;&lt; "Write unaligned csum, stage 2" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 1, 2, in);</div><div class="line">        ASSERT_EQ(2, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp3, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000-1, 1, in);</div><div class="line">        ASSERT_EQ(1, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp1, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000, 0x1000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp2, in));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTestSpecificAUSize, BluestoreStatFSTest)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(65536);</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    // just a big number to disble gc</div><div class="line">    SetVal(g_conf, "bluestore_gc_enable_total_threshold", "100000");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line">    int r;</div><div class="line"></div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2 = hoid;</div><div class="line">    hoid2.hobj.snap = 1;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ(g_conf-&gt;bluestore_block_size, statfs.total);</div><div class="line">        ASSERT_TRUE(statfs.available &gt; 0u &amp;&amp; statfs.available &lt; g_conf-&gt;bluestore_block_size);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        cerr &lt;&lt; "Append 5 bytes" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(5, statfs.stored);</div><div class="line">        ASSERT_EQ(0x10000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0, statfs.compressed);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x30000, 'a');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 0x10000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Append 0x30000 compressible bytes" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30005, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1, 3);</div><div class="line">        t.zero(cid, hoid, 0x20000, 9);</div><div class="line">        cerr &lt;&lt; "Punch hole at 1~3, 0x20000~9" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30005 - 3 - 9, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000 - 9, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x1000, 'b');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x10001, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite first and second(compressible) extents" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30001 - 9 + 0x1000, statfs.stored);</div><div class="line">        ASSERT_EQ(0x40000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000 - 9 - 0x1000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x10000, 'c');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 0x10000, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x20000, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x30000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite compressed extent with 3 uncompressible ones" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30000 + 0x1001, statfs.stored);</div><div class="line">        ASSERT_EQ(0x40000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 0, 0x40000);</div><div class="line">        cerr &lt;&lt; "Zero object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0u, statfs.allocated);</div><div class="line">        ASSERT_EQ(0u, statfs.stored);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x10000, 'c');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s.substr(0, 0x10000-2));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Yet another compressible write" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x40000 - 2, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0x10000, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        cerr &lt;&lt; "Clone compressed objecte" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs2;</div><div class="line">        r = store-&gt;statfs(&amp;statfs2);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_GT(statfs2.stored, statfs.stored);</div><div class="line">        ASSERT_EQ(statfs2.allocated, statfs.allocated);</div><div class="line">        ASSERT_GT(statfs2.compressed, statfs.compressed);</div><div class="line">        ASSERT_GT(statfs2.compressed_original, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs2.compressed_allocated, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BluestoreFragmentedBlobTest)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(g_conf-&gt;bluestore_block_size, statfs.total);</div><div class="line">        ASSERT_EQ(0u, statfs.allocated);</div><div class="line">        ASSERT_EQ(0u, statfs.stored);</div><div class="line">        ASSERT_TRUE(statfs.available &gt; 0u &amp;&amp; statfs.available &lt; g_conf-&gt;bluestore_block_size);</div><div class="line">    &#125;</div><div class="line">    std::string data;</div><div class="line">    data.resize(0x10000 * 3);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i / 256 + 1;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        t.zero(cid, hoid, 0x10000, 0x10000);</div><div class="line">        cerr &lt;&lt; "Append 3*0x10000 bytes and punch a hole 0x10000~10000" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x20000, statfs.stored);</div><div class="line">        ASSERT_EQ(0x20000, statfs.allocated);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, data.size(), newdata);</div><div class="line">        ASSERT_EQ(r, (int)data.size());</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x10000));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(data.substr(0x20000, 0x10000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 1, data.size()-2, newdata);</div><div class="line">        ASSERT_EQ(r, (int)data.size()-2);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(1, 0x10000-1));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(data.substr(0x20000, 0x10000 - 1));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string data2(3, 'b');</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x20000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write 3 bytes after the hole" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x20000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x20000, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x20000-1, 21, newdata);</div><div class="line">        ASSERT_EQ(r, (int)21);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(string(0x1, 0));</div><div class="line">            expected.append(string(data2));</div><div class="line">            expected.append(data.substr(0x20003, 21-4));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string data2(3, 'a');</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x10000+1, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write 3 bytes to the hole" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x20003, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x10000-1, 0x10000+22, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x10000+22);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0x10000-1, 1));</div><div class="line">            expected.append(string(0x1, 0));</div><div class="line">            expected.append(data2);</div><div class="line">            expected.append(string(0x10000-4, 0));</div><div class="line">            expected.append(string(0x3, 'b'));</div><div class="line">            expected.append(data.substr(0x20004, 21-3));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(string(0x30000, 'c'));</div><div class="line">        t.write(cid, hoid, 0, 0x30000, bl);</div><div class="line">        t.zero(cid, hoid, 0, 0x10000);</div><div class="line">        t.zero(cid, hoid, 0x20000, 0x10000);</div><div class="line">        cerr &lt;&lt; "Rewrite an object and create two holes at the beginning and the end" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x10000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x10000, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x30000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x30000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(string(0x10000, 'c'));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManySmallWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(4096);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;100; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*4096, 4096, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i=0; i&lt;100; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % 1024)*4096, 4096, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MultiSmallWriteSameBlock)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("short");</div><div class="line">    C_SaferCond c, d;</div><div class="line">    // touch same block in both same transaction, tls, and pipelined txns</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t, u;</div><div class="line">        t.write(cid, a, 0, 5, bl, 0);</div><div class="line">        t.write(cid, a, 5, 5, bl, 0);</div><div class="line">        t.write(cid, a, 4094, 5, bl, 0);</div><div class="line">        t.write(cid, a, 9000, 5, bl, 0);</div><div class="line">        u.write(cid, a, 10, 5, bl, 0);</div><div class="line">        u.write(cid, a, 7000, 5, bl, 0);</div><div class="line">        t.register_on_commit(&amp;c);</div><div class="line">        vector&lt;ObjectStore::Transaction&gt; v = &#123;t, u&#125;;</div><div class="line">        store-&gt;queue_transactions(ch, v);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t, u;</div><div class="line">        t.write(cid, a, 40, 5, bl, 0);</div><div class="line">        t.write(cid, a, 45, 5, bl, 0);</div><div class="line">        t.write(cid, a, 4094, 5, bl, 0);</div><div class="line">        t.write(cid, a, 6000, 5, bl, 0);</div><div class="line">        u.write(cid, a, 610, 5, bl, 0);</div><div class="line">        u.write(cid, a, 11000, 5, bl, 0);</div><div class="line">        t.register_on_commit(&amp;d);</div><div class="line">        vector&lt;ObjectStore::Transaction&gt; v = &#123;t, u&#125;;</div><div class="line">        store-&gt;queue_transactions(ch, v);</div><div class="line">    &#125;</div><div class="line">    c.wait();</div><div class="line">    d.wait();</div><div class="line">    &#123;</div><div class="line">        bufferlist bl2;</div><div class="line">        r = store-&gt;read(ch, a, 0, 16000, bl2);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallSkipFront)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, a);</div><div class="line">        t.truncate(cid, a, 3000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bufferptr bp(4096);</div><div class="line">        memset(bp.c_str(), 1, 4096);</div><div class="line">        bl.append(bp);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 4096, 4096, bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        ASSERT_EQ(8192, store-&gt;read(ch, a, 0, 8192, bl));</div><div class="line">        for (unsigned i=0; i&lt;4096; ++i)</div><div class="line">            ASSERT_EQ(0, bl[i]);</div><div class="line">        for (unsigned i=4096; i&lt;8192; ++i)</div><div class="line">            ASSERT_EQ(1, bl[i]);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AppendDeferredVsTailCache)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("fooo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    unsigned min_alloc = g_conf-&gt;bluestore_min_alloc_size;</div><div class="line">    unsigned size = min_alloc / 3;</div><div class="line">    bufferptr bpa(size);</div><div class="line">    memset(bpa.c_str(), 1, bpa.length());</div><div class="line">    bufferlist bla;</div><div class="line">    bla.append(bpa);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bla.length(), bla, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // force cached tail to clear ...</div><div class="line">    &#123;</div><div class="line">        ch.reset();</div><div class="line">        int r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bufferptr bpb(size);</div><div class="line">    memset(bpb.c_str(), 2, bpb.length());</div><div class="line">    bufferlist blb;</div><div class="line">    blb.append(bpb);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bla.length(), blb.length(), blb, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferptr bpc(size);</div><div class="line">    memset(bpc.c_str(), 3, bpc.length());</div><div class="line">    bufferlist blc;</div><div class="line">    blc.append(bpc);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bla.length() + blb.length(), blc.length(), blc, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist final;</div><div class="line">    final.append(bla);</div><div class="line">    final.append(blb);</div><div class="line">    final.append(blc);</div><div class="line">    bufferlist actual;</div><div class="line">    &#123;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, a, 0, final.length(), actual));</div><div class="line">        ASSERT_TRUE(bl_eq(final, actual));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AppendZeroTrailingSharedBlock)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("fooo", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b = a;</div><div class="line">    b.hobj.snap = 1;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    unsigned min_alloc = g_conf-&gt;bluestore_min_alloc_size;</div><div class="line">    unsigned size = min_alloc / 3;</div><div class="line">    bufferptr bpa(size);</div><div class="line">    memset(bpa.c_str(), 1, bpa.length());</div><div class="line">    bufferlist bla;</div><div class="line">    bla.append(bpa);</div><div class="line">    // make sure there is some trailing gunk in the last block</div><div class="line">    &#123;</div><div class="line">        bufferlist bt;</div><div class="line">        bt.append(bla);</div><div class="line">        bt.append("BADBADBADBAD");</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bt.length(), bt, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, a, size);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // clone</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, a, b);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // append with implicit zeroing</div><div class="line">    bufferptr bpb(size);</div><div class="line">    memset(bpb.c_str(), 2, bpb.length());</div><div class="line">    bufferlist blb;</div><div class="line">    blb.append(bpb);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, min_alloc * 3, blb.length(), blb, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist final;</div><div class="line">    final.append(bla);</div><div class="line">    bufferlist zeros;</div><div class="line">    zeros.append_zero(min_alloc * 3 - size);</div><div class="line">    final.append(zeros);</div><div class="line">    final.append(blb);</div><div class="line">    bufferlist actual;</div><div class="line">    &#123;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, a, 0, final.length(), actual));</div><div class="line">        final.hexdump(cout);</div><div class="line">        actual.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(final, actual));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallSequentialUnaligned)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    int len = 1000;</div><div class="line">    bufferptr bp(len);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*len, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManyBigWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(4 * 1048576);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*4*1048586, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // aligned</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % 256)*4*1048576, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // unaligned</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % (256*4096))*1024, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // do some zeros</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, b, (rand() % (256*4096))*1024, 16*1048576);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BigWriteBigZero)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(1048576);</div><div class="line">    memset(bp.c_str(), 'b', bp.length());</div><div class="line">    bl.append(bp);</div><div class="line">    bufferlist s;</div><div class="line">    bufferptr sp(4096);</div><div class="line">    memset(sp.c_str(), 's', sp.length());</div><div class="line">    s.append(sp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, a, bl.length() / 4, bl.length() / 2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bl.length() / 2, s.length(), s);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MiscFragmentTests)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(524288);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 1048576, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist inbl;</div><div class="line">        int r = store-&gt;read(ch, a, 524288 + 131072, 1024, inbl);</div><div class="line">        ASSERT_EQ(r, 1024);</div><div class="line">        ASSERT_EQ(inbl.length(), 1024u);</div><div class="line">        ASSERT_TRUE(inbl.is_zero());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 1048576 - 4096, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroVsObjectSize)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    struct stat stat;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist a;</div><div class="line">    a.append("stuff");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 5, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(5, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1, 2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(5, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 3, 200);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(203, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 100000, 200);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(100200, stat.st_size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroLengthWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist empty;</div><div class="line">        t.write(cid, hoid, 1048576, 0, empty);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    struct stat stat;</div><div class="line">    r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ASSERT_EQ(0, stat.st_size);</div><div class="line"></div><div class="line">    bufferlist newdata;</div><div class="line">    r = store-&gt;read(ch, hoid, 0, 1048576, newdata);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroLengthZero)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1048576, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    struct stat stat;</div><div class="line">    r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ASSERT_EQ(0, stat.st_size);</div><div class="line"></div><div class="line">    bufferlist newdata;</div><div class="line">    r = store-&gt;read(ch, hoid, 0, 1048576, newdata);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleAttrTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("attr object 1", CEPH_NOSNAP)));</div><div class="line">    bufferlist val, val2;</div><div class="line">    val.append("value");</div><div class="line">    val.append("value2");</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool empty;</div><div class="line">        int r = store-&gt;collection_empty(ch, &amp;empty);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ASSERT_TRUE(empty);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        r = store-&gt;getattr(ch, hoid, "nofoo", bp);</div><div class="line">        ASSERT_EQ(-ENOENT, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.setattr(cid, hoid, "foo", val);</div><div class="line">        t.setattr(cid, hoid, "bar", val2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool empty;</div><div class="line">        int r = store-&gt;collection_empty(ch, &amp;empty);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ASSERT_TRUE(!empty);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        r = store-&gt;getattr(ch, hoid, "nofoo", bp);</div><div class="line">        ASSERT_EQ(-ENODATA, r);</div><div class="line"></div><div class="line">        r = store-&gt;getattr(ch, hoid, "foo", bp);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(bp);</div><div class="line">        ASSERT_TRUE(bl_eq(val, bl));</div><div class="line"></div><div class="line">        map&lt;string,bufferptr&gt; bm;</div><div class="line">        r = store-&gt;getattrs(ch, hoid, bm);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleListTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 1), shard_id_t(1)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)),</div><div class="line">                            ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">            hoid.hobj.pool = 1;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        set&lt;ghobject_t&gt; saw;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (!next.is_max()) &#123;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(),</div><div class="line">                                           50,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_TRUE(sorted(objects));</div><div class="line">            cout &lt;&lt; " got " &lt;&lt; objects.size() &lt;&lt; " next " &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin(); p != objects.end();</div><div class="line">                 ++p) &#123;</div><div class="line">                if (saw.count(*p)) &#123;</div><div class="line">                    cout &lt;&lt; "got DUP " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                &#125; else &#123;</div><div class="line">                    //cout &lt;&lt; "got new " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">                saw.insert(*p);</div><div class="line">            &#125;</div><div class="line">            objects.clear();</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(saw.size(), all.size());</div><div class="line">        ASSERT_EQ(saw, all);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ListEndTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 1), shard_id_t(1)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)),</div><div class="line">                            ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">            hoid.hobj.pool = 1;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t end(hobject_t(sobject_t("object_100", CEPH_NOSNAP)),</div><div class="line">                       ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        end.hobj.pool = 1;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next;</div><div class="line">        int r = store-&gt;collection_list(ch, ghobject_t(), end, 500,</div><div class="line">                                       &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (auto &amp;p : objects) &#123;</div><div class="line">            ASSERT_NE(p, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Sort)</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        hobject_t a(sobject_t("a", CEPH_NOSNAP));</div><div class="line">        hobject_t b = a;</div><div class="line">        ASSERT_EQ(a, b);</div><div class="line">        b.oid.name = "b";</div><div class="line">        ASSERT_NE(a, b);</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.pool = 1;</div><div class="line">        b.pool = 2;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.pool = 3;</div><div class="line">        ASSERT_TRUE(a &gt; b);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t a(hobject_t(sobject_t("a", CEPH_NOSNAP)));</div><div class="line">        ghobject_t b(hobject_t(sobject_t("b", CEPH_NOSNAP)));</div><div class="line">        a.hobj.pool = 1;</div><div class="line">        b.hobj.pool = 1;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.hobj.pool = -3;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.hobj.pool = 1;</div><div class="line">        b.hobj.pool = -3;</div><div class="line">        ASSERT_TRUE(a &gt; b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MultipoolListTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    int poolid = 4373;</div><div class="line">    coll_t cid = coll_t(spg_t(pg_t(0, poolid), shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all, saw;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)));</div><div class="line">            if (rand() &amp; 1)</div><div class="line">                hoid.hobj.pool = -2 - poolid;</div><div class="line">            else</div><div class="line">                hoid.hobj.pool = poolid;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (!next.is_max()) &#123;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 50,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            cout &lt;&lt; " got " &lt;&lt; objects.size() &lt;&lt; " next " &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin(); p != objects.end();</div><div class="line">                 ++p) &#123;</div><div class="line">                saw.insert(*p);</div><div class="line">            &#125;</div><div class="line">            objects.clear();</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(saw, all);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleCloneTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small, large, xlarge, newdata, attr;</div><div class="line">    small.append("small");</div><div class="line">    large.append("large");</div><div class="line">    xlarge.append("xlarge");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        t.setattr(cid, hoid, "attr2", large);</div><div class="line">        t.setattr(cid, hoid, "attr3", xlarge);</div><div class="line">        t.write(cid, hoid, 0, small.length(), small);</div><div class="line">        t.write(cid, hoid, 10, small.length(), small);</div><div class="line">        cerr &lt;&lt; "Creating object and set attr " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP),</div><div class="line">                               "key", 123, -1, ""));</div><div class="line">    ghobject_t hoid3(hobject_t(sobject_t("Object 3", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        t.setattr(cid, hoid2, "attr2", small);</div><div class="line">        t.rmattr(cid, hoid2, "attr1");</div><div class="line">        t.write(cid, hoid, 10, large.length(), large);</div><div class="line">        t.setattr(cid, hoid, "attr1", large);</div><div class="line">        t.setattr(cid, hoid, "attr2", small);</div><div class="line">        cerr &lt;&lt; "Clone object and rm attr" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(large, newdata));</div><div class="line"></div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line"></div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid2, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line"></div><div class="line">        r = store-&gt;getattr(ch, hoid2, "attr2", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(small, attr));</div><div class="line"></div><div class="line">        attr.clear();</div><div class="line">        r = store-&gt;getattr(ch, hoid2, "attr3", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(xlarge, attr));</div><div class="line"></div><div class="line">        attr.clear();</div><div class="line">        r = store-&gt;getattr(ch, hoid, "attr1", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(large, attr));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16384);</div><div class="line">        memset(p.c_str(), 1, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 2, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, pl.length(), a.length(), al);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16384);</div><div class="line">        memset(p.c_str(), 111, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr z(4096);</div><div class="line">        z.zero();</div><div class="line">        final.append(z);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 112, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, pl.length() + z.length(), a.length(), al);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16000);</div><div class="line">        memset(p.c_str(), 5, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr z(1000);</div><div class="line">        z.zero();</div><div class="line">        final.append(z);</div><div class="line">        bufferptr a(8000);</div><div class="line">        memset(a.c_str(), 6, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, 17000, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(1048576);</div><div class="line">        memset(p.c_str(), 3, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(65536);</div><div class="line">        memset(a.c_str(), 4, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, a.length(), a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, al.length());</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, al.length()*2, pl.length() - al.length()*2);</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(65536);</div><div class="line">        memset(p.c_str(), 7, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 8, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, 32768, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, 32768);</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, final.length(), pl.length() - final.length());</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(65536);</div><div class="line">        memset(p.c_str(), 9, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 10, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, 33768, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, 33768);</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, final.length(), pl.length() - final.length());</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //Unfortunately we need a workaround for filestore since EXPECT_DEATH</div><div class="line">    // macro has potential issues when using /in multithread environments.</div><div class="line">    //It works well for all stores but filestore for now.</div><div class="line">    //A fix setting gtest_death_test_style = "threadsafe" doesn't help as well -</div><div class="line">    //  test app clone asserts on store folder presence.</div><div class="line">    //</div><div class="line">    if (string(GetParam()) != "filestore") &#123;</div><div class="line">        //verify if non-empty collection is properly handled after store reload</div><div class="line">        ch.reset();</div><div class="line">        r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Invalid rm coll" &lt;&lt; std::endl;</div><div class="line">        PrCtl unset_dumpable;</div><div class="line">        EXPECT_DEATH(queue_transaction(store, ch, std::move(t)), "");</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid3); //new record in db</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //See comment above for "filestore" check explanation.</div><div class="line">    if (string(GetParam()) != "filestore") &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        //verify if non-empty collection is properly handled when there are some pending removes and live records in db</div><div class="line">        cerr &lt;&lt; "Invalid rm coll again" &lt;&lt; std::endl;</div><div class="line">        ch.reset();</div><div class="line">        r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        PrCtl unset_dumpable;</div><div class="line">        EXPECT_DEATH(queue_transaction(store, ch, std::move(t)), "");</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove(cid, hoid3);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OmapSimple)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("omap_obj", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    map&lt;string,bufferlist&gt; km;</div><div class="line">    km["foo"] = small;</div><div class="line">    km["bar"].append("asdfjkasdkjdfsjkafskjsfdj");</div><div class="line">    bufferlist header;</div><div class="line">    header.append("this is a header");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_setkeys(cid, hoid, km);</div><div class="line">        t.omap_setheader(cid, hoid, header);</div><div class="line">        cerr &lt;&lt; "Creating object and set omap " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // get header, keys</div><div class="line">    &#123;</div><div class="line">        bufferlist h;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        store-&gt;omap_get(ch, hoid, &amp;h, &amp;r);</div><div class="line">        ASSERT_TRUE(bl_eq(header, h));</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    // test iterator with seek_to_first</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        ObjectMap::ObjectMapIterator iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;seek_to_first(); iter-&gt;valid(); iter-&gt;next(false)) &#123;</div><div class="line">            r[iter-&gt;key()] = iter-&gt;value();</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    // test iterator with initial lower_bound</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        ObjectMap::ObjectMapIterator iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;lower_bound(string()); iter-&gt;valid(); iter-&gt;next(false)) &#123;</div><div class="line">            r[iter-&gt;key()] = iter-&gt;value();</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OmapCloneTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    map&lt;string,bufferlist&gt; km;</div><div class="line">    km["foo"] = small;</div><div class="line">    km["bar"].append("asdfjkasdkjdfsjkafskjsfdj");</div><div class="line">    bufferlist header;</div><div class="line">    header.append("this is a header");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_setkeys(cid, hoid, km);</div><div class="line">        t.omap_setheader(cid, hoid, header);</div><div class="line">        cerr &lt;&lt; "Creating object and set omap " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP),</div><div class="line">                               "key", 123, -1, ""));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        cerr &lt;&lt; "Clone object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        bufferlist h;</div><div class="line">        store-&gt;omap_get(ch, hoid2, &amp;h, &amp;r);</div><div class="line">        ASSERT_TRUE(bl_eq(header, h));</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleCloneRangeTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    hoid.hobj.pool = -1;</div><div class="line">    bufferlist small, newdata;</div><div class="line">    small.append("small");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 10, 5, small);</div><div class="line">        cerr &lt;&lt; "Creating object and write bl " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    hoid2.hobj.pool = -1;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone_range(cid, hoid, hoid2, 10, 5, 10);</div><div class="line">        cerr &lt;&lt; "Clone range object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;read(ch, hoid2, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, hoid, 1024*1024);</div><div class="line">        t.clone_range(cid, hoid, hoid2, 0, 1024*1024, 0);</div><div class="line">        cerr &lt;&lt; "Clone range object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct stat stat, stat2;</div><div class="line">        r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">        r = store-&gt;stat(ch, hoid2, &amp;stat2);</div><div class="line">        ASSERT_EQ(stat.st_size, stat2.st_size);</div><div class="line">        ASSERT_EQ(1024*1024, stat2.st_size);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleObjectLongnameTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaObjectaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ghobject_t generate_long_name(unsigned i)</div><div class="line">&#123;</div><div class="line">    stringstream name;</div><div class="line">    name &lt;&lt; "object id " &lt;&lt; i &lt;&lt; " ";</div><div class="line">    for (unsigned j = 0; j &lt; 500; ++j) name &lt;&lt; 'a';</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t(name.str(), CEPH_NOSNAP)));</div><div class="line">    hoid.hobj.set_hash(i % 2);</div><div class="line">    return hoid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, LongnameSplitTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    for (unsigned i = 0; i &lt; 320; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t hoid = generate_long_name(i);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t test_obj = generate_long_name(319);</div><div class="line">    ghobject_t test_obj_2 = test_obj;</div><div class="line">    test_obj_2.generation = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        // should cause a split</div><div class="line">        t.collection_move_rename(</div><div class="line">            cid, test_obj,</div><div class="line">            cid, test_obj_2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (unsigned i = 0; i &lt; 319; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t hoid = generate_long_name(i);</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Removing object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, test_obj_2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManyObjectTest)</div><div class="line">&#123;</div><div class="line">    int NUM_OBJS = 2000;</div><div class="line">    int r = 0;</div><div class="line">    coll_t cid;</div><div class="line">    string base = "";</div><div class="line">    for (int i = 0; i &lt; 100; ++i) base.append("aaaaa");</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        if (!(i % 5)) &#123;</div><div class="line">            cerr &lt;&lt; "Object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(string(buf) + base, CEPH_NOSNAP)));</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        created.insert(hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        struct stat buf;</div><div class="line">        ASSERT_TRUE(!store-&gt;stat(ch, *i, &amp;buf));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set&lt;ghobject_t&gt; listed, listed2;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(), INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    cerr &lt;&lt; "objects.size() is " &lt;&lt; objects.size() &lt;&lt; std::endl;</div><div class="line">    for (vector&lt;ghobject_t&gt; ::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        listed.insert(*i);</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line"></div><div class="line">    ghobject_t start, next;</div><div class="line">    objects.clear();</div><div class="line">    r = store-&gt;collection_list(</div><div class="line">            ch,</div><div class="line">            ghobject_t::get_max(),</div><div class="line">            ghobject_t::get_max(),</div><div class="line">            50,</div><div class="line">            &amp;objects,</div><div class="line">            &amp;next</div><div class="line">        );</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_TRUE(objects.empty());</div><div class="line"></div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t start2, next2;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, start, ghobject_t::get_max(),</div><div class="line">                                   50,</div><div class="line">                                   &amp;objects,</div><div class="line">                                   &amp;next);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        listed.insert(objects.begin(), objects.end());</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line"></div><div class="line">        start = next;</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    if (listed2.size()) &#123;</div><div class="line">        ASSERT_EQ(listed.size(), listed2.size());</div><div class="line">    &#125;</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "cleaning up" &lt;&lt; std::endl;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class ObjectGenerator</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual ghobject_t create_object(gen_type *gen) = 0;</div><div class="line">    virtual ~ObjectGenerator() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class MixedGenerator : public ObjectGenerator</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    unsigned seq;</div><div class="line">    int64_t poolid;</div><div class="line">    explicit MixedGenerator(int64_t p) : seq(0), poolid(p) &#123;&#125;</div><div class="line">    ghobject_t create_object(gen_type *gen) override</div><div class="line">    &#123;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "OBJ_%u", seq);</div><div class="line">        string name(buf);</div><div class="line">        if (seq % 2) &#123;</div><div class="line">            for (unsigned i = 0; i &lt; 300; ++i) &#123;</div><div class="line">                name.push_back('a');</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++seq;</div><div class="line">        return ghobject_t(</div><div class="line">                   hobject_t(</div><div class="line">                       name, string(), rand() &amp; 2 ? CEPH_NOSNAP : rand(),</div><div class="line">                       (((seq / 1024) % 2) * 0xF00 ) +</div><div class="line">                       (seq &amp; 0xFF),</div><div class="line">                       poolid, ""));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SyntheticWorkloadState</div><div class="line">&#123;</div><div class="line">    struct Object &#123;</div><div class="line">        bufferlist data;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    static const unsigned max_in_flight = 16;</div><div class="line">    static const unsigned max_objects = 3000;</div><div class="line">    static const unsigned max_attr_size = 5;</div><div class="line">    static const unsigned max_attr_name_len = 100;</div><div class="line">    static const unsigned max_attr_value_len = 1024 * 64;</div><div class="line">    coll_t cid;</div><div class="line">    unsigned write_alignment;</div><div class="line">    unsigned max_object_len, max_write_len;</div><div class="line">    unsigned in_flight;</div><div class="line">    map&lt;ghobject_t, Object&gt; contents;</div><div class="line">    set&lt;ghobject_t&gt; available_objects;</div><div class="line">    set&lt;ghobject_t&gt; in_flight_objects;</div><div class="line">    ObjectGenerator *object_gen;</div><div class="line">    gen_type *rng;</div><div class="line">    ObjectStore *store;</div><div class="line">    ObjectStore::CollectionHandle ch;</div><div class="line"></div><div class="line">    Mutex lock;</div><div class="line">    Cond cond;</div><div class="line"></div><div class="line">    struct EnterExit &#123;</div><div class="line">        const char *msg;</div><div class="line">        explicit EnterExit(const char *m) : msg(m)</div><div class="line">        &#123;</div><div class="line">            //cout &lt;&lt; pthread_self() &lt;&lt; " enter " &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ~EnterExit()</div><div class="line">        &#123;</div><div class="line">            //cout &lt;&lt; pthread_self() &lt;&lt; " exit " &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnReadable : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t hoid;</div><div class="line">        C_SyntheticOnReadable(SyntheticWorkloadState *state, ghobject_t hoid)</div><div class="line">            : state(state), hoid(hoid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("onreadable finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(hoid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(hoid);</div><div class="line">            if (state-&gt;contents.count(hoid))</div><div class="line">                state-&gt;available_objects.insert(hoid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            state-&gt;cond.Signal();</div><div class="line"></div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(state-&gt;ch, hoid, 0, state-&gt;contents[hoid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[hoid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnStash : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t oid, noid;</div><div class="line"></div><div class="line">        C_SyntheticOnStash(SyntheticWorkloadState *state,</div><div class="line">                           ghobject_t oid, ghobject_t noid)</div><div class="line">            : state(state), oid(oid), noid(noid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("stash finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(oid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(oid);</div><div class="line">            if (state-&gt;contents.count(noid))</div><div class="line">                state-&gt;available_objects.insert(noid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(</div><div class="line">                    state-&gt;ch, noid, 0,</div><div class="line">                    state-&gt;contents[noid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[noid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnClone : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t oid, noid;</div><div class="line"></div><div class="line">        C_SyntheticOnClone(SyntheticWorkloadState *state,</div><div class="line">                           ghobject_t oid, ghobject_t noid)</div><div class="line">            : state(state), oid(oid), noid(noid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("clone finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(oid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(oid);</div><div class="line">            if (state-&gt;contents.count(oid))</div><div class="line">                state-&gt;available_objects.insert(oid);</div><div class="line">            if (state-&gt;contents.count(noid))</div><div class="line">                state-&gt;available_objects.insert(noid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(state-&gt;ch, noid, 0, state-&gt;contents[noid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[noid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    static void filled_byte_array(bufferlist&amp; bl, size_t size)</div><div class="line">    &#123;</div><div class="line">        static const char alphanum[] = "0123456789"</div><div class="line">                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</div><div class="line">                                       "abcdefghijklmnopqrstuvwxyz";</div><div class="line">        if (!size) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        bufferptr bp(size);</div><div class="line">        for (unsigned int i = 0; i &lt; size - 1; i++) &#123;</div><div class="line">            // severely limit entropy so we can compress...</div><div class="line">            bp[i] = alphanum[rand() % 10]; //(sizeof(alphanum) - 1)];</div><div class="line">        &#125;</div><div class="line">        bp[size - 1] = '\0';</div><div class="line"></div><div class="line">        bl.append(bp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SyntheticWorkloadState(ObjectStore *store,</div><div class="line">                           ObjectGenerator *gen,</div><div class="line">                           gen_type *rng,</div><div class="line">                           coll_t cid,</div><div class="line">                           unsigned max_size,</div><div class="line">                           unsigned max_write,</div><div class="line">                           unsigned alignment)</div><div class="line">        : cid(cid), write_alignment(alignment), max_object_len(max_size),</div><div class="line">          max_write_len(max_write), in_flight(0), object_gen(gen),</div><div class="line">          rng(rng), store(store),</div><div class="line">          lock("State lock") &#123;&#125;</div><div class="line"></div><div class="line">    int init()</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ch = store-&gt;create_new_collection(cid);</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        return queue_transaction(store, ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">    void shutdown()</div><div class="line">    &#123;</div><div class="line">        while (1) &#123;</div><div class="line">            vector&lt;ghobject_t&gt; objects;</div><div class="line">            int r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                           10, &amp;objects, 0);</div><div class="line">            assert(r &gt;= 0);</div><div class="line">            if (objects.empty())</div><div class="line">                break;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin();</div><div class="line">                 p != objects.end(); ++p) &#123;</div><div class="line">                t.remove(cid, *p);</div><div class="line">            &#125;</div><div class="line">            queue_transaction(store, ch, std::move(t));</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        queue_transaction(store, ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">    void statfs(store_statfs_t&amp; stat)</div><div class="line">    &#123;</div><div class="line">        store-&gt;statfs(&amp;stat);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t get_uniform_random_object()</div><div class="line">    &#123;</div><div class="line">        while (in_flight &gt;= max_in_flight || available_objects.empty())</div><div class="line">            cond.Wait(lock);</div><div class="line">        boost::uniform_int&lt;&gt; choose(0, available_objects.size() - 1);</div><div class="line">        int index = choose(*rng);</div><div class="line">        set&lt;ghobject_t&gt;::iterator i = available_objects.begin();</div><div class="line">        for ( ; index &gt; 0; --index, ++i) ;</div><div class="line">        ghobject_t ret = *i;</div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void wait_for_ready()</div><div class="line">    &#123;</div><div class="line">        while (in_flight &gt;= max_in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void wait_for_done()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool can_create()</div><div class="line">    &#123;</div><div class="line">        return (available_objects.size() + in_flight_objects.size()) &lt; max_objects;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool can_unlink()</div><div class="line">    &#123;</div><div class="line">        return (available_objects.size() + in_flight_objects.size()) &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    unsigned get_random_alloc_hints()</div><div class="line">    &#123;</div><div class="line">        unsigned f = 0;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_WRITE;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_READ;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_READ;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            // append_only, immutable</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 4);</div><div class="line">            f |= u(*rng) &lt;&lt; 4;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SHORTLIVED;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_LONGLIVED;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return f;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int touch()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("touch");</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line">        ghobject_t new_obj = object_gen-&gt;create_object(rng);</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, new_obj);</div><div class="line">        boost::uniform_int&lt;&gt; u(17, 22);</div><div class="line">        boost::uniform_int&lt;&gt; v(12, 17);</div><div class="line">        t.set_alloc_hint(cid, new_obj,</div><div class="line">                         1ull &lt;&lt; u(*rng),</div><div class="line">                         1ull &lt;&lt; v(*rng),</div><div class="line">                         get_random_alloc_hints());</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        if (!contents.count(new_obj))</div><div class="line">            contents[new_obj] = Object();</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int stash()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("stash");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = old_obj;</div><div class="line">        new_obj.generation++;</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.collection_move_rename(cid, old_obj, cid, new_obj);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        contents[new_obj].attrs = contents[old_obj].attrs;</div><div class="line">        contents[new_obj].data = contents[old_obj].data;</div><div class="line">        contents.erase(old_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnStash(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int clone()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("clone");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = object_gen-&gt;create_object(rng);</div><div class="line">        // make the hash match</div><div class="line">        new_obj.hobj.set_hash(old_obj.hobj.get_hash());</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, old_obj, new_obj);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        contents[new_obj].attrs = contents[old_obj].attrs;</div><div class="line">        contents[new_obj].data = contents[old_obj].data;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnClone(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int clone_range()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("clone_range");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        bufferlist &amp;srcdata = contents[old_obj].data;</div><div class="line">        if (srcdata.length() == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t srcoff = u1(*rng);</div><div class="line">        // make src and dst offsets match, since that's what the osd does</div><div class="line">        uint64_t dstoff = srcoff; //u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            srcoff = round_up_to(srcoff, write_alignment);</div><div class="line">            dstoff = round_up_to(dstoff, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (srcoff &gt; srcdata.length() - 1) &#123;</div><div class="line">            srcoff = srcdata.length() - 1;</div><div class="line">        &#125;</div><div class="line">        if (srcoff + len &gt; srcdata.length()) &#123;</div><div class="line">            len = srcdata.length() - srcoff;</div><div class="line">        &#125;</div><div class="line">        if (0)</div><div class="line">            cout &lt;&lt; __func__ &lt;&lt; " from " &lt;&lt; srcoff &lt;&lt; "~" &lt;&lt; len</div><div class="line">                 &lt;&lt; " (size " &lt;&lt; srcdata.length() &lt;&lt; ") to "</div><div class="line">                 &lt;&lt; dstoff &lt;&lt; "~" &lt;&lt; len &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone_range(cid, old_obj, new_obj, srcoff, len, dstoff);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        bufferlist bl;</div><div class="line">        if (srcoff &lt; srcdata.length()) &#123;</div><div class="line">            if (srcoff + len &gt; srcdata.length()) &#123;</div><div class="line">                bl.substr_of(srcdata, srcoff, srcdata.length() - srcoff);</div><div class="line">            &#125; else &#123;</div><div class="line">                bl.substr_of(srcdata, srcoff, len);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist&amp; dstdata = contents[new_obj].data;</div><div class="line">        if (dstdata.length() &lt;= dstoff) &#123;</div><div class="line">            if (bl.length() &gt; 0) &#123;</div><div class="line">                dstdata.append_zero(dstoff - dstdata.length());</div><div class="line">                dstdata.append(bl);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist value;</div><div class="line">            assert(dstdata.length() &gt; dstoff);</div><div class="line">            dstdata.copy(0, dstoff, value);</div><div class="line">            value.append(bl);</div><div class="line">            if (value.length() &lt; dstdata.length())</div><div class="line">                dstdata.copy(value.length(),</div><div class="line">                             dstdata.length() - value.length(), value);</div><div class="line">            value.swap(dstdata);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnClone(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    int write()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("write");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        bufferlist bl;</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            offset = round_up_to(offset, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        filled_byte_array(bl, len);</div><div class="line"></div><div class="line">        bufferlist&amp; data = contents[new_obj].data;</div><div class="line">        if (data.length() &lt;= offset) &#123;</div><div class="line">            if (len &gt; 0) &#123;</div><div class="line">                data.append_zero(offset-data.length());</div><div class="line">                data.append(bl);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist value;</div><div class="line">            assert(data.length() &gt; offset);</div><div class="line">            data.copy(0, offset, value);</div><div class="line">            value.append(bl);</div><div class="line">            if (value.length() &lt; data.length())</div><div class="line">                data.copy(value.length(),</div><div class="line">                          data.length()-value.length(), value);</div><div class="line">            value.swap(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.write(cid, new_obj, offset, len, bl);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int truncate()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("truncate");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; choose(0, max_object_len);</div><div class="line">        size_t len = choose(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.truncate(cid, obj, len);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        bufferlist&amp; data = contents[obj].data;</div><div class="line">        if (data.length() &lt;= len) &#123;</div><div class="line">            data.append_zero(len - data.length());</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist bl;</div><div class="line">            data.copy(0, len, bl);</div><div class="line">            bl.swap(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int zero()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("zero");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            offset = round_up_to(offset, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (len &gt; 0) &#123;</div><div class="line">            auto&amp; data = contents[new_obj].data;</div><div class="line">            if (data.length() &lt; offset + len) &#123;</div><div class="line">                data.append_zero(offset+len-data.length());</div><div class="line">            &#125;</div><div class="line">            bufferlist n;</div><div class="line">            n.substr_of(data, 0, offset);</div><div class="line">            n.append_zero(len);</div><div class="line">            if (data.length() &gt; offset + len)</div><div class="line">                data.copy(offset + len, data.length() - offset - len, n);</div><div class="line">            data.swap(n);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.zero(cid, new_obj, offset, len);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void read()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("read");</div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len/2);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_object_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (offset &gt; len)</div><div class="line">            swap(offset, len);</div><div class="line"></div><div class="line">        ghobject_t obj;</div><div class="line">        bufferlist expected;</div><div class="line">        int r;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("read locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            obj = get_uniform_random_object();</div><div class="line">            expected = contents[obj].data;</div><div class="line">        &#125;</div><div class="line">        bufferlist bl, result;</div><div class="line">        if (0) cout &lt;&lt; " obj " &lt;&lt; obj</div><div class="line">                        &lt;&lt; " size " &lt;&lt; expected.length()</div><div class="line">                        &lt;&lt; " offset " &lt;&lt; offset</div><div class="line">                        &lt;&lt; " len " &lt;&lt; len &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;read(ch, obj, offset, len, result);</div><div class="line">        if (offset &gt;= expected.length()) &#123;</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            size_t max_len = expected.length() - offset;</div><div class="line">            if (len &gt; max_len)</div><div class="line">                len = max_len;</div><div class="line">            assert(len == result.length());</div><div class="line">            ASSERT_EQ(len, result.length());</div><div class="line">            expected.copy(offset, len, bl);</div><div class="line">            ASSERT_EQ(r, (int)len);</div><div class="line">            ASSERT_TRUE(bl_eq(bl, result));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int setattrs()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("setattrs");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u0(1, max_attr_size);</div><div class="line">        boost::uniform_int&lt;&gt; u1(4, max_attr_name_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(4, max_attr_value_len);</div><div class="line">        boost::uniform_int&lt;&gt; u3(0, 100);</div><div class="line">        uint64_t size = u0(*rng);</div><div class="line">        uint64_t name_len;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator it = contents[obj].attrs.begin();</div><div class="line">             it != contents[obj].attrs.end(); ++it)</div><div class="line">            keys.insert(it-&gt;first);</div><div class="line"></div><div class="line">        while (size--) &#123;</div><div class="line">            bufferlist name, value;</div><div class="line">            uint64_t get_exist = u3(*rng);</div><div class="line">            uint64_t value_len = u2(*rng);</div><div class="line">            filled_byte_array(value, value_len);</div><div class="line">            if (get_exist &lt; 50 &amp;&amp; keys.size()) &#123;</div><div class="line">                set&lt;string&gt;::iterator k = keys.begin();</div><div class="line">                attrs[*k] = value;</div><div class="line">                contents[obj].attrs[*k] = value;</div><div class="line">                keys.erase(k);</div><div class="line">            &#125; else &#123;</div><div class="line">                name_len = u1(*rng);</div><div class="line">                filled_byte_array(name, name_len);</div><div class="line">                attrs[name.c_str()] = value;</div><div class="line">                contents[obj].attrs[name.c_str()] = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        t.setattrs(cid, obj, attrs);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void getattrs()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("getattrs");</div><div class="line">        ghobject_t obj;</div><div class="line">        map&lt;string, bufferlist&gt; expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("getattrs locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            int retry = 10;</div><div class="line">            do &#123;</div><div class="line">                obj = get_uniform_random_object();</div><div class="line">                if (!--retry)</div><div class="line">                    return ;</div><div class="line">            &#125; while (contents[obj].attrs.empty());</div><div class="line">            expected = contents[obj].attrs;</div><div class="line">        &#125;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">        int r = store-&gt;getattrs(ch, obj, attrs);</div><div class="line">        ASSERT_TRUE(r == 0);</div><div class="line">        ASSERT_TRUE(attrs.size() == expected.size());</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator it = expected.begin();</div><div class="line">             it != expected.end(); ++it) &#123;</div><div class="line">            ASSERT_TRUE(bl_eq(attrs[it-&gt;first], it-&gt;second));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void getattr()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("getattr");</div><div class="line">        ghobject_t obj;</div><div class="line">        int r;</div><div class="line">        int retry;</div><div class="line">        map&lt;string, bufferlist&gt; expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("getattr locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            retry = 10;</div><div class="line">            do &#123;</div><div class="line">                obj = get_uniform_random_object();</div><div class="line">                if (!--retry)</div><div class="line">                    return ;</div><div class="line">            &#125; while (contents[obj].attrs.empty());</div><div class="line">            expected = contents[obj].attrs;</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; u(0, expected.size()-1);</div><div class="line">        retry = u(*rng);</div><div class="line">        map&lt;string, bufferlist&gt;::iterator it = expected.begin();</div><div class="line">        while (retry) &#123;</div><div class="line">            retry--;</div><div class="line">            ++it;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist bl;</div><div class="line">        r = store-&gt;getattr(ch, obj, it-&gt;first, bl);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(it-&gt;second, bl));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int rmattr()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("rmattr");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj;</div><div class="line">        int retry = 10;</div><div class="line">        do &#123;</div><div class="line">            obj = get_uniform_random_object();</div><div class="line">            if (!--retry)</div><div class="line">                return 0;</div><div class="line">        &#125; while (contents[obj].attrs.empty());</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u(0, contents[obj].attrs.size()-1);</div><div class="line">        retry = u(*rng);</div><div class="line">        map&lt;string, bufferlist&gt;::iterator it = contents[obj].attrs.begin();</div><div class="line">        while (retry) &#123;</div><div class="line">            retry--;</div><div class="line">            ++it;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.rmattr(cid, obj, it-&gt;first);</div><div class="line"></div><div class="line">        contents[obj].attrs.erase(it-&gt;first);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void fsck(bool deep)</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("fsck");</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">        ch.reset();</div><div class="line">        store-&gt;umount();</div><div class="line">        int r = store-&gt;fsck(deep);</div><div class="line">        assert(r == 0 || r == -EOPNOTSUPP);</div><div class="line">        store-&gt;mount();</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void scan()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("scan");</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        set&lt;ghobject_t&gt; objects_set, objects_set2;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (1) &#123;</div><div class="line">            //cerr &lt;&lt; "scanning..." &lt;&lt; std::endl;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 100,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_TRUE(sorted(objects));</div><div class="line">            objects_set.insert(objects.begin(), objects.end());</div><div class="line">            objects.clear();</div><div class="line">            if (next.is_max()) break;</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        if (objects_set.size() != available_objects.size()) &#123;</div><div class="line">            for (set&lt;ghobject_t&gt;::iterator p = objects_set.begin();</div><div class="line">                 p != objects_set.end();</div><div class="line">                 ++p)</div><div class="line">                if (available_objects.count(*p) == 0) &#123;</div><div class="line">                    cerr &lt;&lt; "+ " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                    ceph_abort();</div><div class="line">                &#125;</div><div class="line">            for (set&lt;ghobject_t&gt;::iterator p = available_objects.begin();</div><div class="line">                 p != available_objects.end();</div><div class="line">                 ++p)</div><div class="line">                if (objects_set.count(*p) == 0)</div><div class="line">                    cerr &lt;&lt; "- " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">            //cerr &lt;&lt; " objects_set: " &lt;&lt; objects_set &lt;&lt; std::endl;</div><div class="line">            //cerr &lt;&lt; " available_set: " &lt;&lt; available_objects &lt;&lt; std::endl;</div><div class="line">            assert(0 == "badness");</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ASSERT_EQ(objects_set.size(), available_objects.size());</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator i = objects_set.begin();</div><div class="line">             i != objects_set.end();</div><div class="line">             ++i) &#123;</div><div class="line">            ASSERT_GT(available_objects.count(*i), (unsigned)0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                       INT_MAX, &amp;objects, 0);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        objects_set2.insert(objects.begin(), objects.end());</div><div class="line">        ASSERT_EQ(objects_set2.size(), available_objects.size());</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator i = objects_set2.begin();</div><div class="line">             i != objects_set2.end();</div><div class="line">             ++i) &#123;</div><div class="line">            ASSERT_GT(available_objects.count(*i), (unsigned)0);</div><div class="line">            if (available_objects.count(*i) == 0) &#123;</div><div class="line">                cerr &lt;&lt; "+ " &lt;&lt; *i &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void stat()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("stat");</div><div class="line">        ghobject_t hoid;</div><div class="line">        uint64_t expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("stat lock1");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            hoid = get_uniform_random_object();</div><div class="line">            in_flight_objects.insert(hoid);</div><div class="line">            available_objects.erase(hoid);</div><div class="line">            ++in_flight;</div><div class="line">            expected = contents[hoid].data.length();</div><div class="line">        &#125;</div><div class="line">        struct stat buf;</div><div class="line">        int r = store-&gt;stat(ch, hoid, &amp;buf);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        assert((uint64_t)buf.st_size == expected);</div><div class="line">        ASSERT_TRUE((uint64_t)buf.st_size == expected);</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("stat lock2");</div><div class="line">            --in_flight;</div><div class="line">            cond.Signal();</div><div class="line">            in_flight_objects.erase(hoid);</div><div class="line">            available_objects.insert(hoid);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int unlink()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("unlink");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        ghobject_t to_remove = get_uniform_random_object();</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, to_remove);</div><div class="line">        ++in_flight;</div><div class="line">        available_objects.erase(to_remove);</div><div class="line">        in_flight_objects.insert(to_remove);</div><div class="line">        contents.erase(to_remove);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, to_remove));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void print_internal_state()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        cerr &lt;&lt; "available_objects: " &lt;&lt; available_objects.size()</div><div class="line">             &lt;&lt; " in_flight_objects: " &lt;&lt; in_flight_objects.size()</div><div class="line">             &lt;&lt; " total objects: " &lt;&lt; in_flight_objects.size() + available_objects.size()</div><div class="line">             &lt;&lt; " in_flight " &lt;&lt; in_flight &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">void StoreTest::doSyntheticTest(</div><div class="line">    int num_ops,</div><div class="line">    uint64_t max_obj, uint64_t max_wr, uint64_t align)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(555);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(), &amp;gen, &amp;rng, cid,</div><div class="line">                                    max_obj, max_wr, align);</div><div class="line">    test_obj.init();</div><div class="line">    for (int i = 0; i &lt; num_ops/10; ++i) &#123;</div><div class="line">        if (!(i % 500)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; num_ops; ++i) &#123;</div><div class="line">        if (!(i % 1000)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; true_false(0, 999);</div><div class="line">        int val = true_false(rng);</div><div class="line">        if (val &gt; 998) &#123;</div><div class="line">            test_obj.fsck(true);</div><div class="line">        &#125; else if (val &gt; 997) &#123;</div><div class="line">            test_obj.fsck(false);</div><div class="line">        &#125; else if (val &gt; 970) &#123;</div><div class="line">            test_obj.scan();</div><div class="line">        &#125; else if (val &gt; 950) &#123;</div><div class="line">            test_obj.stat();</div><div class="line">        &#125; else if (val &gt; 850) &#123;</div><div class="line">            test_obj.zero();</div><div class="line">        &#125; else if (val &gt; 800) &#123;</div><div class="line">            test_obj.unlink();</div><div class="line">        &#125; else if (val &gt; 550) &#123;</div><div class="line">            test_obj.write();</div><div class="line">        &#125; else if (val &gt; 500) &#123;</div><div class="line">            test_obj.clone();</div><div class="line">        &#125; else if (val &gt; 450) &#123;</div><div class="line">            test_obj.clone_range();</div><div class="line">        &#125; else if (val &gt; 300) &#123;</div><div class="line">            test_obj.stash();</div><div class="line">        &#125; else if (val &gt; 100) &#123;</div><div class="line">            test_obj.read();</div><div class="line">        &#125; else &#123;</div><div class="line">            test_obj.truncate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Synthetic)</div><div class="line">&#123;</div><div class="line">    doSyntheticTest(10000, 400*1024, 40*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixSharding)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", 0 &#125;, // must be the first!</div><div class="line">        &#123; "num_ops", "50000", 0 &#125;,</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "262144", 0 &#125;,</div><div class="line">        &#123; "alignment", "4096", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_min_size", "60", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_max_size", "300", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_target_size", "150", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, ZipperPatternSharded)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(4096);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    int len = 4096;</div><div class="line">    bufferptr bp(len);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*2*len, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*2*len + 1, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCsumAlgorithm)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "65536", 0 &#125;, // must be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "16", 0 &#125;,</div><div class="line">        &#123;</div><div class="line">            "bluestore_csum_type", "crc32c", "crc32c_16", "crc32c_8", "xxhash32",</div><div class="line">            "xxhash64", "none", 0</div><div class="line">        &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCsumVsCompression)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "16384", 0 &#125;, //to be the first!</div><div class="line">        &#123; "max_write", "131072", 0 &#125;,</div><div class="line">        &#123; "max_size", "262144", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", 0&#125;,</div><div class="line">        &#123; "bluestore_compression_algorithm", "snappy", "zlib", 0 &#125;,</div><div class="line">        &#123; "bluestore_csum_type", "crc32c", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCompression)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "1048576", 0 &#125;,</div><div class="line">        &#123; "max_size", "4194304", 0 &#125;,</div><div class="line">        &#123; "alignment", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "aggressive", "passive", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "true", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCompressionAlgorithm)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "1048576", 0 &#125;,</div><div class="line">        &#123; "max_size", "4194304", 0 &#125;,</div><div class="line">        &#123; "alignment", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_algorithm", "zlib", "snappy", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixNoCsum)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "262144", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_csum_type", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "true", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixPreferDeferred)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "262144", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_prefer_deferred_size", "32768", "0", 0&#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AttrSynthetic)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(447);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,447),shard_id_t::NO_SHARD));</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(), &amp;gen, &amp;rng, cid, 40*1024, 4*1024, 0);</div><div class="line">    test_obj.init();</div><div class="line">    for (int i = 0; i &lt; 500; ++i) &#123;</div><div class="line">        if (!(i % 10)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">        if (!(i % 100)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; true_false(0, 99);</div><div class="line">        int val = true_false(rng);</div><div class="line">        if (val &gt; 97) &#123;</div><div class="line">            test_obj.scan();</div><div class="line">        &#125; else if (val &gt; 93) &#123;</div><div class="line">            test_obj.stat();</div><div class="line">        &#125; else if (val &gt; 75) &#123;</div><div class="line">            test_obj.rmattr();</div><div class="line">        &#125; else if (val &gt; 47) &#123;</div><div class="line">            test_obj.setattrs();</div><div class="line">        &#125; else if (val &gt; 45) &#123;</div><div class="line">            test_obj.clone();</div><div class="line">        &#125; else if (val &gt; 37) &#123;</div><div class="line">            test_obj.stash();</div><div class="line">        &#125; else if (val &gt; 30) &#123;</div><div class="line">            test_obj.getattrs();</div><div class="line">        &#125; else &#123;</div><div class="line">            test_obj.getattr();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, HashCollisionTest)</div><div class="line">&#123;</div><div class="line">    int64_t poolid = 11;</div><div class="line">    coll_t cid(spg_t(pg_t(0,poolid),shard_id_t::NO_SHARD));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    string base = "";</div><div class="line">    for (int i = 0; i &lt; 100; ++i) base.append("aaaaa");</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    for (int n = 0; n &lt; 10; ++n) &#123;</div><div class="line">        char nbuf[100];</div><div class="line">        sprintf(nbuf, "n%d", n);</div><div class="line">        for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">            char buf[100];</div><div class="line">            sprintf(buf, "%d", i);</div><div class="line">            if (!(i % 100)) &#123;</div><div class="line">                cerr &lt;&lt; "Object n" &lt;&lt; n &lt;&lt; " "&lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            ghobject_t hoid(hobject_t(string(buf) + base, string(), CEPH_NOSNAP, 0, poolid, string(nbuf)));</div><div class="line">            &#123;</div><div class="line">                ObjectStore::Transaction t;</div><div class="line">                t.touch(cid, hoid);</div><div class="line">                r = queue_transaction(store, ch, std::move(t));</div><div class="line">                ASSERT_EQ(r, 0);</div><div class="line">            &#125;</div><div class="line">            created.insert(hoid);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(), INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    set&lt;ghobject_t&gt; listed(objects.begin(), objects.end());</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; " and created.size() is " &lt;&lt; created.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t current, next;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 60,</div><div class="line">                                   &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">             i != objects.end();</div><div class="line">             ++i) &#123;</div><div class="line">            if (listed.count(*i))</div><div class="line">                cerr &lt;&lt; *i &lt;&lt; " repeated" &lt;&lt; std::endl;</div><div class="line">            listed.insert(*i);</div><div class="line">        &#125;</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ScrubTest)</div><div class="line">&#123;</div><div class="line">    int64_t poolid = 111;</div><div class="line">    coll_t cid(spg_t(pg_t(0, poolid),shard_id_t(1)));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    string base = "aaaaa";</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">        char buf[100];</div><div class="line">        sprintf(buf, "%d", i);</div><div class="line">        if (!(i % 5)) &#123;</div><div class="line">            cerr &lt;&lt; "Object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ghobject_t hoid(hobject_t(string(buf) + base, string(), CEPH_NOSNAP, i,</div><div class="line">                                  poolid, ""),</div><div class="line">                        ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        created.insert(hoid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add same hobject_t but different generation</div><div class="line">    &#123;</div><div class="line">        ghobject_t hoid1(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""),</div><div class="line">                         ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        ghobject_t hoid2(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""), (gen_t)1, shard_id_t(1));</div><div class="line">        ghobject_t hoid3(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""), (gen_t)2, shard_id_t(1));</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid1);</div><div class="line">        t.touch(cid, hoid2);</div><div class="line">        t.touch(cid, hoid3);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        created.insert(hoid1);</div><div class="line">        created.insert(hoid2);</div><div class="line">        created.insert(hoid3);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    set&lt;ghobject_t&gt; listed(objects.begin(), objects.end());</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; " and created.size() is " &lt;&lt; created.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t current, next;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 60,</div><div class="line">                                   &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">             i != objects.end(); ++i) &#123;</div><div class="line">            if (listed.count(*i))</div><div class="line">                cerr &lt;&lt; *i &lt;&lt; " repeated" &lt;&lt; std::endl;</div><div class="line">            listed.insert(*i);</div><div class="line">        &#125;</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line">        current = next.get_boundary();</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTest, OMapTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_clear(cid, hoid);</div><div class="line">        map&lt;string, bufferlist&gt; start_set;</div><div class="line">        t.omap_setkeys(cid, hoid, start_set);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator j = attrs.begin();</div><div class="line">             j != attrs.end();</div><div class="line">             ++j) &#123;</div><div class="line">            bool correct = cur_attrs.count(j-&gt;first) &amp;&amp; string(cur_attrs[j-&gt;first].c_str()) == string(j-&gt;second.c_str());</div><div class="line">            if (!correct) &#123;</div><div class="line">                std::cout &lt;&lt; j-&gt;first &lt;&lt; " is present in cur_attrs " &lt;&lt; cur_attrs.count(j-&gt;first) &lt;&lt; " times " &lt;&lt; std::endl;</div><div class="line">                if (cur_attrs.count(j-&gt;first) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; j-&gt;second.c_str() &lt;&lt; " : " &lt;&lt; cur_attrs[j-&gt;first].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(attrs.size(), cur_attrs.size());</div><div class="line"></div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        bl.clear();</div><div class="line">        bufferptr bp(buf, strlen(buf) + 1);</div><div class="line">        bl.append(bp);</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        attrs.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int i = 0;</div><div class="line">    while (attrs.size()) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "removal: On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator j = attrs.begin();</div><div class="line">             j != attrs.end();</div><div class="line">             ++j) &#123;</div><div class="line">            bool correct = cur_attrs.count(j-&gt;first) &amp;&amp; string(cur_attrs[j-&gt;first].c_str()) == string(j-&gt;second.c_str());</div><div class="line">            if (!correct) &#123;</div><div class="line">                std::cout &lt;&lt; j-&gt;first &lt;&lt; " is present in cur_attrs " &lt;&lt; cur_attrs.count(j-&gt;first) &lt;&lt; " times " &lt;&lt; std::endl;</div><div class="line">                if (cur_attrs.count(j-&gt;first) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; j-&gt;second.c_str() &lt;&lt; " : " &lt;&lt; cur_attrs[j-&gt;first].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        string to_remove = attrs.begin()-&gt;first;</div><div class="line">        set&lt;string&gt; keys_to_remove;</div><div class="line">        keys_to_remove.insert(to_remove);</div><div class="line">        t.omap_rmkeys(cid, hoid, keys_to_remove);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        attrs.erase(to_remove);</div><div class="line"></div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        bufferlist bl1;</div><div class="line">        bl1.append("omap_header");</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.omap_setheader(cid, hoid, bl1);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">        bufferlist bl2;</div><div class="line">        bl2.append("value");</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key", bl2));</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist bl3;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl3, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(cur_attrs.size(), size_t(1));</div><div class="line">        ASSERT_TRUE(bl_eq(bl1, bl3));</div><div class="line"></div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        r = store-&gt;omap_get_keys(ch, hoid, &amp;keys);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(keys.size(), size_t(1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // test omap_clear, omap_rmkey_range</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            map&lt;string,bufferlist&gt; to_set;</div><div class="line">            for (int n=0; n&lt;10; ++n) &#123;</div><div class="line">                to_set[stringify(n)].append("foo");</div><div class="line">            &#125;</div><div class="line">            bufferlist h;</div><div class="line">            h.append("header");</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.remove(cid, hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            t.omap_setheader(cid, hoid, h);</div><div class="line">            t.omap_setkeys(cid, hoid, to_set);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.omap_rmkeyrange(cid, hoid, "3", "7");</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            bufferlist hdr;</div><div class="line">            map&lt;string,bufferlist&gt; m;</div><div class="line">            store-&gt;omap_get(ch, hoid, &amp;hdr, &amp;m);</div><div class="line">            ASSERT_EQ(6u, hdr.length());</div><div class="line">            ASSERT_TRUE(m.count("2"));</div><div class="line">            ASSERT_TRUE(!m.count("3"));</div><div class="line">            ASSERT_TRUE(!m.count("6"));</div><div class="line">            ASSERT_TRUE(m.count("7"));</div><div class="line">            ASSERT_TRUE(m.count("8"));</div><div class="line">            //cout &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">            ASSERT_EQ(6u, m.size());</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.omap_clear(cid, hoid);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            bufferlist hdr;</div><div class="line">            map&lt;string,bufferlist&gt; m;</div><div class="line">            store-&gt;omap_get(ch, hoid, &amp;hdr, &amp;m);</div><div class="line">            ASSERT_EQ(0u, hdr.length());</div><div class="line">            ASSERT_EQ(0u, m.size());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove(cid, hoid);</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OMapIterator)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    int count = 0;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_clear(cid, hoid);</div><div class="line">        map&lt;string, bufferlist&gt; start_set;</div><div class="line">        t.omap_setkeys(cid, hoid, start_set);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectMap::ObjectMapIterator iter;</div><div class="line">    bool correct;</div><div class="line">    //basic iteration</div><div class="line">    for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        // FileStore may deadlock two active iterators over the same data</div><div class="line">        iter = ObjectMap::ObjectMapIterator();</div><div class="line"></div><div class="line">        iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;seek_to_first(), count=0; iter-&gt;valid(); iter-&gt;next(), count++) &#123;</div><div class="line">            string key = iter-&gt;key();</div><div class="line">            bufferlist value = iter-&gt;value();</div><div class="line">            correct = attrs.count(key) &amp;&amp; (string(value.c_str()) == string(attrs[key].c_str()));</div><div class="line">            if (!correct) &#123;</div><div class="line">                if (attrs.count(key) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; "key " &lt;&lt; key &lt;&lt; "in omap , " &lt;&lt; value.c_str() &lt;&lt; " : " &lt;&lt; attrs[key].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125; else</div><div class="line">                    std::cout &lt;&lt; "key " &lt;&lt; key &lt;&lt; "should not exists in omap" &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ((int)attrs.size(), count);</div><div class="line"></div><div class="line">        // FileStore may deadlock an active iterator vs queue_transaction</div><div class="line">        iter = ObjectMap::ObjectMapIterator();</div><div class="line"></div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        bl.clear();</div><div class="line">        bufferptr bp(buf, strlen(buf) + 1);</div><div class="line">        bl.append(bp);</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        attrs.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">    //lower bound</div><div class="line">    string bound_key = "key-5";</div><div class="line">    iter-&gt;lower_bound(bound_key);</div><div class="line">    correct = bound_key &lt;= iter-&gt;key();</div><div class="line">    if (!correct) &#123;</div><div class="line">        std::cout &lt;&lt; "lower bound, bound key is " &lt;&lt; bound_key &lt;&lt; " &lt; iter key is " &lt;&lt; iter-&gt;key() &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(correct, true);</div><div class="line">    //upper bound</div><div class="line">    iter-&gt;upper_bound(bound_key);</div><div class="line">    correct = iter-&gt;key() &gt; bound_key;</div><div class="line">    if (!correct) &#123;</div><div class="line">        std::cout &lt;&lt; "upper bound, bound key is " &lt;&lt; bound_key &lt;&lt; " &gt;= iter key is " &lt;&lt; iter-&gt;key() &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(correct, true);</div><div class="line"></div><div class="line">    // FileStore may deadlock an active iterator vs queue_transaction</div><div class="line">    iter = ObjectMap::ObjectMapIterator();</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, XattrTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    bufferlist big;</div><div class="line">    for (unsigned i = 0; i &lt; 10000; ++i) &#123;</div><div class="line">        big.append('\0');</div><div class="line">    &#125;</div><div class="line">    bufferlist small;</div><div class="line">    for (unsigned i = 0; i &lt; 10; ++i) &#123;</div><div class="line">        small.append('\0');</div><div class="line">    &#125;</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        attrs["attr1"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr2", big);</div><div class="line">        attrs["attr2"] = big;</div><div class="line">        t.setattr(cid, hoid, "attr3", small);</div><div class="line">        attrs["attr3"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        attrs["attr1"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr4", big);</div><div class="line">        attrs["attr4"] = big;</div><div class="line">        t.setattr(cid, hoid, "attr3", big);</div><div class="line">        attrs["attr3"] = big;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferptr&gt; aset;</div><div class="line">    store-&gt;getattrs(ch, hoid, aset);</div><div class="line">    ASSERT_EQ(aset.size(), attrs.size());</div><div class="line">    for (map&lt;string, bufferptr&gt;::iterator i = aset.begin();</div><div class="line">         i != aset.end();</div><div class="line">         ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.push_back(i-&gt;second);</div><div class="line">        ASSERT_TRUE(attrs[i-&gt;first] == bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.rmattr(cid, hoid, "attr2");</div><div class="line">        attrs.erase("attr2");</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aset.clear();</div><div class="line">    store-&gt;getattrs(ch, hoid, aset);</div><div class="line">    ASSERT_EQ(aset.size(), attrs.size());</div><div class="line">    for (map&lt;string, bufferptr&gt;::iterator i = aset.begin();</div><div class="line">         i != aset.end();</div><div class="line">         ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.push_back(i-&gt;second);</div><div class="line">        ASSERT_TRUE(attrs[i-&gt;first] == bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bufferptr bp;</div><div class="line">    r = store-&gt;getattr(ch, hoid, "attr2", bp);</div><div class="line">    ASSERT_EQ(r, -ENODATA);</div><div class="line"></div><div class="line">    r = store-&gt;getattr(ch, hoid, "attr3", bp);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    bufferlist bl2;</div><div class="line">    bl2.push_back(bp);</div><div class="line">    ASSERT_TRUE(bl2 == attrs["attr3"]);</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove(cid, hoid);</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void colsplittest(</div><div class="line">    ObjectStore *store,</div><div class="line">    unsigned num_objects,</div><div class="line">    unsigned common_suffix_size,</div><div class="line">    bool clones</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0,52),shard_id_t::NO_SHARD));</div><div class="line">    coll_t tid(spg_t(pg_t(1&lt;&lt;common_suffix_size,52),shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    auto tch = store-&gt;create_new_collection(tid);</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, common_suffix_size);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (uint32_t i = 0; i &lt; (2 - (int)clones)*num_objects; ++i) &#123;</div><div class="line">            stringstream objname;</div><div class="line">            objname &lt;&lt; "obj" &lt;&lt; i;</div><div class="line">            ghobject_t a(hobject_t(</div><div class="line">                             objname.str(),</div><div class="line">                             "",</div><div class="line">                             CEPH_NOSNAP,</div><div class="line">                             i&lt;&lt;common_suffix_size,</div><div class="line">                             52, ""));</div><div class="line">            t.write(cid, a, 0, small.length(), small,</div><div class="line">                    CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">            if (clones) &#123;</div><div class="line">                objname &lt;&lt; "-clone";</div><div class="line">                ghobject_t b(hobject_t(</div><div class="line">                                 objname.str(),</div><div class="line">                                 "",</div><div class="line">                                 CEPH_NOSNAP,</div><div class="line">                                 i&lt;&lt;common_suffix_size,</div><div class="line">                                 52, ""));</div><div class="line">                t.clone(cid, a, b);</div><div class="line">            &#125;</div><div class="line">            if (i % 100) &#123;</div><div class="line">                r = queue_transaction(store, ch, std::move(t));</div><div class="line">                ASSERT_EQ(r, 0);</div><div class="line">                t = ObjectStore::Transaction();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(tid, common_suffix_size + 1);</div><div class="line">        t.split_collection(cid, common_suffix_size+1, 1&lt;&lt;common_suffix_size, tid);</div><div class="line">        r = queue_transaction(store, tch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    tch-&gt;flush();</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_EQ(objects.size(), num_objects);</div><div class="line">    unsigned size = 0;</div><div class="line">    for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_EQ(!!(i-&gt;hobj.get_hash() &amp; (1&lt;&lt;common_suffix_size)), 0u);</div><div class="line">        t.remove(cid, *i);</div><div class="line">        if (++size &gt; 100) &#123;</div><div class="line">            size = 0;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">            // test environment may have a low open file limit</div><div class="line">            ch-&gt;flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">    objects.clear();</div><div class="line">    r = store-&gt;collection_list(tch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_EQ(objects.size(), num_objects);</div><div class="line">    for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_EQ(!(i-&gt;hobj.get_hash() &amp; (1&lt;&lt;common_suffix_size)), 0u);</div><div class="line">        t.remove(tid, *i);</div><div class="line">        if (++size &gt; 100) &#123;</div><div class="line">            size = 0;</div><div class="line">            r = queue_transaction(store, tch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">            // test environment may have a low open file limit</div><div class="line">            tch-&gt;flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t.remove_collection(tid);</div><div class="line">    r = queue_transaction(store, tch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ColSplitTest1)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 10000, 11, false);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest1Clones)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 10000, 11, true);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest2)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100, 7, false);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest2Clones)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100, 7, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if 0</div><div class="line">TEST_P(StoreTest, ColSplitTest3)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100000, 25);</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">/**</div><div class="line"> * This test tests adding two different groups</div><div class="line"> * of objects, each with 1 common prefix and 1</div><div class="line"> * different prefix.  We then remove half</div><div class="line"> * in order to verify that the merging correctly</div><div class="line"> * stops at the common prefix subdir.  See bug</div><div class="line"> * #5273 */</div><div class="line">TEST_P(StoreTest, TwoHash)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Making objects" &lt;&lt; std::endl;</div><div class="line">    for (int i = 0; i &lt; 360; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        if (i &lt; 8) &#123;</div><div class="line">            o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">            t.touch(cid, o);</div><div class="line">        &#125;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xB1);</div><div class="line">        t.touch(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Removing half" &lt;&lt; std::endl;</div><div class="line">    for (int i = 1; i &lt; 8; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        t.remove(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Checking" &lt;&lt; std::endl;</div><div class="line">    for (int i = 1; i &lt; 8; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        bool exists = store-&gt;exists(ch, o);</div><div class="line">        ASSERT_EQ(exists, false);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash(0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        bool exists = store-&gt;exists(ch, o);</div><div class="line">        ASSERT_EQ(exists, true);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Cleanup" &lt;&lt; std::endl;</div><div class="line">    for (int i = 0; i &lt; 360; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        t.remove(cid, o);</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xB1);</div><div class="line">        t.remove(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Rename)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 2122),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t srcoid(hobject_t("src_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    ghobject_t dstoid(hobject_t("dest_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    bufferlist a, b;</div><div class="line">    a.append("foo");</div><div class="line">    b.append("bar");</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.write(cid, srcoid, 0, a.length(), a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, srcoid));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.collection_move_rename(cid, srcoid, cid, dstoid);</div><div class="line">        t.write(cid, srcoid, 0, b.length(), b);</div><div class="line">        t.setattr(cid, srcoid, "attr", b);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, srcoid));</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, dstoid));</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;read(ch, srcoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(b, bl));</div><div class="line">        store-&gt;read(ch, dstoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(a, bl));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, dstoid);</div><div class="line">        t.collection_move_rename(cid, srcoid, cid, dstoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, dstoid));</div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, srcoid));</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;read(ch, dstoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(b, bl));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, dstoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MoveRename)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 212),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t temp_oid(hobject_t("tmp_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    ghobject_t oid(hobject_t("dest_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, oid));</div><div class="line">    bufferlist data, attr;</div><div class="line">    map&lt;string, bufferlist&gt; omap;</div><div class="line">    data.append("data payload");</div><div class="line">    attr.append("attr value");</div><div class="line">    omap["omap_key"].append("omap value");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, temp_oid);</div><div class="line">        t.write(cid, temp_oid, 0, data.length(), data);</div><div class="line">        t.setattr(cid, temp_oid, "attr", attr);</div><div class="line">        t.omap_setkeys(cid, temp_oid, omap);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, temp_oid));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.collection_move_rename(cid, temp_oid, cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, oid));</div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, temp_oid));</div><div class="line">    &#123;</div><div class="line">        bufferlist newdata;</div><div class="line">        r = store-&gt;read(ch, oid, 0, 1000, newdata);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(data, newdata));</div><div class="line">        bufferlist newattr;</div><div class="line">        r = store-&gt;getattr(ch, oid, "attr", newattr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(attr, newattr));</div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        keys.insert("omap_key");</div><div class="line">        map&lt;string, bufferlist&gt; newomap;</div><div class="line">        r = store-&gt;omap_get_values(ch, oid, keys, &amp;newomap);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">        ASSERT_EQ(1u, newomap.size());</div><div class="line">        ASSERT_TRUE(newomap.count("omap_key"));</div><div class="line">        ASSERT_TRUE(bl_eq(omap["omap_key"], newomap["omap_key"]));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BigRGWObjectName)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0,12),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t oid(</div><div class="line">        hobject_t(</div><div class="line">            "default.4106.50_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",</div><div class="line">            "",</div><div class="line">            CEPH_NOSNAP,</div><div class="line">            0x81920472,</div><div class="line">            12,</div><div class="line">            ""),</div><div class="line">        15,</div><div class="line">        shard_id_t::NO_SHARD);</div><div class="line">    ghobject_t oid2(oid);</div><div class="line">    oid2.generation = 17;</div><div class="line">    ghobject_t oidhead(oid);</div><div class="line">    oidhead.generation = ghobject_t::NO_GEN;</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oidhead);</div><div class="line">        t.collection_move_rename(cid, oidhead, cid, oid);</div><div class="line">        t.touch(cid, oidhead);</div><div class="line">        t.collection_move_rename(cid, oidhead, cid, oid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                   INT_MAX, &amp;objects, 0);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(objects.size(), 1u);</div><div class="line">        ASSERT_EQ(objects[0], oid2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, oid));</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SetAllocHint)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*4, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*4, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, TryMoveRename)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    ghobject_t hoid2(hobject_t("test_hint2", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.try_rename(cid, hoid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.try_rename(cid, hoid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    struct stat st;</div><div class="line">    ASSERT_EQ(store-&gt;stat(ch, hoid, &amp;st), -ENOENT);</div><div class="line">    ASSERT_EQ(store-&gt;stat(ch, hoid2, &amp;st), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTest, BluestoreOnOffCSumTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //write with csum enabled followed by read with csum disabled</div><div class="line">        size_t block_size = 64*1024;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //write with csum disabled followed by read with csum enabled</div><div class="line"></div><div class="line">        size_t block_size = 64*1024;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //'mixed' non-overlapping writes to the same blob</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        size_t block_size = 8000;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        t2.write(cid, hoid, block_size*2, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Append 'unprotected'" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t2));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size*2, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size*2, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //partially blob overwrite under a different csum enablement mode</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig, orig2;</div><div class="line">        size_t block_size0 = 0x10000;</div><div class="line">        size_t block_size = 9000;</div><div class="line">        size_t block_size2 = 5000;</div><div class="line">        bl.append(std::string(block_size0, 'a'));</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        bl.clear();</div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t2.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        t2.write(cid, hoid, block_size0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite with unprotected data" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t2));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        orig = bl;</div><div class="line">        orig2 = bl;</div><div class="line">        orig.append( std::string(block_size0 - block_size, 'a'));</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size0, in);</div><div class="line">        ASSERT_EQ((int)block_size0, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, block_size0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig2, in));</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t3;</div><div class="line">        bl.clear();</div><div class="line">        bl.append(std::string(block_size2, 'c'));</div><div class="line">        t3.write(cid, hoid, block_size0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite with protected data" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t3));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        in.clear();</div><div class="line">        orig = bl;</div><div class="line">        orig.append( std::string(block_size - block_size2, 'b'));</div><div class="line">        r = store-&gt;read(ch, hoid, block_size0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">INSTANTIATE_TEST_CASE_P(</div><div class="line">    ObjectStore,</div><div class="line">    StoreTest,</div><div class="line">    ::testing::Values(</div><div class="line">        "memstore",</div><div class="line">        "filestore",</div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">        "bluestore",</div><div class="line">#endif</div><div class="line">        "kstore"));</div><div class="line"></div><div class="line">// Note: instantiate all stores to preserve store numbering order only</div><div class="line">INSTANTIATE_TEST_CASE_P(</div><div class="line">    ObjectStore,</div><div class="line">    StoreTestSpecificAUSize,</div><div class="line">    ::testing::Values(</div><div class="line">        "memstore",</div><div class="line">        "filestore",</div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">        "bluestore",</div><div class="line">#endif</div><div class="line">        "kstore"));</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">// Google Test may not support value-parameterized tests with some</div><div class="line">// compilers. If we use conditional compilation to compile out all</div><div class="line">// code referring to the gtest_main library, MSVC linker will not link</div><div class="line">// that library at all and consequently complain about missing entry</div><div class="line">// point defined in that library (fatal error LNK1561: entry point</div><div class="line">// must be defined). This dummy test keeps gtest_main linked in.</div><div class="line">TEST(DummyTest, ValueParameterizedTestsAreNotSupportedOnThisPlatform) &#123;&#125;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">void doMany4KWritesTest(boost::scoped_ptr&lt;ObjectStore&gt;&amp; store,</div><div class="line">                        unsigned max_objects,</div><div class="line">                        unsigned max_ops,</div><div class="line">                        unsigned max_object_size,</div><div class="line">                        unsigned max_write_size,</div><div class="line">                        unsigned write_alignment)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(555);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line">    store_statfs_t res_stat;</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(),</div><div class="line">                                    &amp;gen,</div><div class="line">                                    &amp;rng,</div><div class="line">                                    cid,</div><div class="line">                                    max_object_size,</div><div class="line">                                    max_write_size,</div><div class="line">                                    write_alignment);</div><div class="line">    test_obj.init();</div><div class="line">    for (unsigned i = 0; i &lt; max_objects; ++i) &#123;</div><div class="line">        if (!(i % 500)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (unsigned i = 0; i &lt; max_ops; ++i) &#123;</div><div class="line">        if (!(i % 200)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        test_obj.write();</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.statfs(res_stat);</div><div class="line">    if (!(res_stat.stored &lt;= max_object_size) ||</div><div class="line">        !(res_stat.allocated &lt;= max_object_size)) &#123;</div><div class="line">        // this will provide more insight on the mismatch and</div><div class="line">        // helps to avoid any races during stats collection</div><div class="line">        test_obj.fsck(false);</div><div class="line">        // retrieving stats once again and assert if still broken</div><div class="line">        test_obj.statfs(res_stat);</div><div class="line">        ASSERT_LE(res_stat.stored, max_object_size);</div><div class="line">        ASSERT_LE(res_stat.allocated, max_object_size);</div><div class="line">    &#125;</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, Many4KWritesTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    StartDeferred(0x10000);</div><div class="line"></div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, Many4KWritesNoCSumTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line"></div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, TooManyBlobsTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">void get_mempool_stats(uint64_t* total_bytes, uint64_t* total_items)</div><div class="line">&#123;</div><div class="line">    uint64_t onode_allocated = mempool::bluestore_cache_onode::allocated_bytes();</div><div class="line">    uint64_t other_allocated = mempool::bluestore_cache_other::allocated_bytes();</div><div class="line"></div><div class="line">    uint64_t onode_items = mempool::bluestore_cache_onode::allocated_items();</div><div class="line">    uint64_t other_items = mempool::bluestore_cache_other::allocated_items();</div><div class="line">    cout &lt;&lt; "onode(" &lt;&lt; onode_allocated &lt;&lt; "/" &lt;&lt; onode_items</div><div class="line">         &lt;&lt; ") other(" &lt;&lt; other_allocated &lt;&lt; "/" &lt;&lt; other_items</div><div class="line">         &lt;&lt; ")" &lt;&lt; std::endl;</div><div class="line">    *total_bytes = onode_allocated + other_allocated;</div><div class="line">    *total_items = onode_items;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, OnodeSizeTracking)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "none");</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_hdd", "400000000");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_ssd", "400000000");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    size_t obj_size = 4 * 1024  * 1024;</div><div class="line">    uint64_t total_bytes, total_bytes2;</div><div class="line">    uint64_t total_onodes;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_EQ(total_onodes, 0u);</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig, orig2;</div><div class="line"></div><div class="line">        bl.append(std::string(obj_size, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_NE(total_bytes, 0u);</div><div class="line">    ASSERT_EQ(total_onodes, 1u);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, hoid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(size_t i = 0; i &lt; 1; ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(std::string(block_size * (i+1), 'a'));</div><div class="line">        for( size_t j = 0; j &lt; obj_size; j+= bl.length()) &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.write(cid, hoid, j, bl.length(), bl);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        get_mempool_stats(&amp;total_bytes2, &amp;total_onodes);</div><div class="line">        ASSERT_NE(total_bytes2, 0u);</div><div class="line">        ASSERT_EQ(total_onodes, 1u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt;" mempool dump:\n";</div><div class="line">        JSONFormatter f(true);</div><div class="line">        f.open_object_section("transaction");</div><div class="line">        mempool::dump(&amp;f);</div><div class="line">        f.close_section();</div><div class="line">        f.flush(cout);</div><div class="line">        cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        for (size_t i = 0; i &lt; obj_size; i += 0x1000) &#123;</div><div class="line">            store-&gt;read(ch, hoid, i, 0x1000, bl);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_NE(total_bytes, 0u);</div><div class="line">    ASSERT_EQ(total_onodes, 1u);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt;" mempool dump:\n";</div><div class="line">        JSONFormatter f(true);</div><div class="line">        f.open_object_section("transaction");</div><div class="line">        mempool::dump(&amp;f);</div><div class="line">        f.close_section();</div><div class="line">        f.flush(cout);</div><div class="line">        cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnOverwrite)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // overwrite at the beginning</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // append</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'c'));</div><div class="line">        t.write(cid, hoid, block_size * 2, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // append with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'd'));</div><div class="line">        t.write(cid, hoid, block_size * 5, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // overwrite at end</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'e'));</div><div class="line"></div><div class="line">        // Currently we are unable to reuse blob when overwriting in a single step</div><div class="line">        t.write(cid, hoid, block_size * 6, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fill the gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'f'));</div><div class="line"></div><div class="line">        t.write(cid, hoid, block_size * 4, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // we need to wait some time for mempool</div><div class="line">        // thread to update stats to be able to check blob/extent numbers from</div><div class="line">        // perf counters.</div><div class="line">        sleep(1);</div><div class="line"></div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 2, block_size * 2, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 2);</div><div class="line">        expected.append(string(block_size * 2, 'c'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 4, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 5, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 5, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        expected.append(string(block_size * 2, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">    ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 1u);</div><div class="line"></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnOverwriteReverse)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'a'));</div><div class="line">        t.write(cid, hoid, block_size * 10, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // prepend existing</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t.write(cid, hoid, block_size * 9, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 9, block_size * 2, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 2);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 1u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // prepend existing with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'c'));</div><div class="line">        t.write(cid, hoid, block_size * 7, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 7, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'c'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // append after existing with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'd'));</div><div class="line">        t.write(cid, hoid, block_size * 13, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 11, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 3u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // append twice to the next max_blob slot</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'e'));</div><div class="line">        t.write(cid, hoid, block_size * 17, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 19, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 17, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 2u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 5u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fill gaps at the second slot</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'f'));</div><div class="line">        t.write(cid, hoid, block_size * 16, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 18, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 16, block_size * 4, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 4);</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 2u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 4u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnSmallOverwrite)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 2, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // write small into the gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(3, 'b'));</div><div class="line">        t.write(cid, hoid, block_size + 1, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        expected.append(string(1, 0));</div><div class="line">        expected.append(string(3, 'b'));</div><div class="line">        expected.append(string(block_size - 4, 0));</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 3u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The test case to reproduce an issue when write happens</div><div class="line">// to a zero space between the extents sharing the same spanning blob</div><div class="line">// with unloaded shard map.</div><div class="line">// Second extent might be filled with zeros this way due to wrong result</div><div class="line">// returned by has_any_extents() call in do_write_small. The latter is caused</div><div class="line">// by incompletly loaded extent map.</div><div class="line">TEST_P(StoreTestSpecificAUSize, SmallWriteOnShardedExtents)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 0x10000;</div><div class="line">    StartDeferred(block_size);</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "xxhash64");</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "524288"); // for sure</div><div class="line"></div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid1(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //doing some tricks to have sharded extents/spanning objects</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2;</div><div class="line"></div><div class="line">        bl.append(std::string(0x80000, 'a'));</div><div class="line">        t.write(cid, hoid1, 0, bl.length(), bl, 0);</div><div class="line">        t.zero(cid, hoid1, 0x719e0, 0x75b0 );</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bl2.append(std::string(0x70000, 'b'));</div><div class="line">        t.write(cid, hoid1, 0, bl2.length(), bl2, 0);</div><div class="line">        t.zero(cid, hoid1, 0, 0x50000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    store-&gt;umount();</div><div class="line">    store-&gt;mount();</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // do a write to zero space in between some extents sharing the same blob</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2;</div><div class="line"></div><div class="line">        bl.append(std::string(0x6520, 'c'));</div><div class="line">        t.write(cid, hoid1, 0x71c00, bl.length(), bl, 0);</div><div class="line"></div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, expected;</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid1, 0x70000, 0x9c00, bl);</div><div class="line">        ASSERT_EQ(r, (int)0x9c00);</div><div class="line">        expected.append(string(0x19e0, 'a'));</div><div class="line">        expected.append(string(0x220, 0));</div><div class="line">        expected.append(string(0x6520, 'c'));</div><div class="line">        expected.append(string(0xe70, 0));</div><div class="line">        expected.append(string(0xc70, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        bl.clear();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid1);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, ExcessiveFragmentation)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify((uint64_t)2048 * 1024 * 1024).c_str());</div><div class="line"></div><div class="line">    ASSERT_EQ(g_conf-&gt;get_val&lt;uint64_t&gt;("bluefs_alloc_size"),</div><div class="line">              1024 * 1024);</div><div class="line"></div><div class="line">    size_t block_size = 0x10000;</div><div class="line">    StartDeferred(block_size);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid1(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // create 2x400MB objects in a way that their pextents are interleaved</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 4, 'a')); // 256KB</div><div class="line">        uint64_t offs = 0;</div><div class="line">        while(offs &lt; (uint64_t)400 * 1024 * 1024) &#123;</div><div class="line">            t.write(cid, hoid1, offs, bl.length(), bl, 0);</div><div class="line">            t.write(cid, hoid2, offs, bl.length(), bl, 0);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            offs += bl.length();</div><div class="line">            if( (offs % (100 * 1024 * 1024)) == 0) &#123;</div><div class="line">                std::cout&lt;&lt;"written " &lt;&lt; offs &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    std::cout&lt;&lt;"written 800MB"&lt;&lt;std::endl;</div><div class="line">    &#123;</div><div class="line">        // Partially overwrite objects with 100MB each leaving space</div><div class="line">        // fragmented and occuping still unfragmented space at the end</div><div class="line">        // So we'll have enough free space but it'll lack long enough (e.g. 1MB)</div><div class="line">        // contiguous pextents.</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 4, 'a'));</div><div class="line">        uint64_t offs = 0;</div><div class="line">        while(offs &lt; 112 * 1024 * 1024) &#123;</div><div class="line">            t.write(cid, hoid1, offs, bl.length(), bl, 0);</div><div class="line">            t.write(cid, hoid2, offs, bl.length(), bl, 0);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            // this will produce high fragmentation if original allocations</div><div class="line">            // were contiguous</div><div class="line">            offs += bl.length();</div><div class="line">            if( (offs % (10 * 1024 * 1024)) == 0) &#123;</div><div class="line">                std::cout&lt;&lt;"written " &lt;&lt; offs &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // remove one of the object producing much free space</div><div class="line">        // and hence triggering bluefs rebalance.</div><div class="line">        // Which should fail as there is no long enough pextents.</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    auto to_sleep = 5 *</div><div class="line">                    (int)g_conf-&gt;get_val&lt;double&gt;("bluestore_bluefs_balance_interval");</div><div class="line">    std::cout&lt;&lt;"sleeping... " &lt;&lt; std::endl;</div><div class="line">    sleep(to_sleep);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // touch another object to triggerrebalance</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid1);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid1);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif //#if defined(WITH_BLUESTORE)</div><div class="line"></div><div class="line">TEST_P(StoreTest, KVDBHistogramTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    int NUM_OBJS = 200;</div><div class="line">    int r = 0;</div><div class="line">    coll_t cid;</div><div class="line">    string base("testobj.");</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(base + string(buf), CEPH_NOSNAP)));</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    store-&gt;generate_db_histogram(f);</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, KVDBStatsTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "rocksdb_perf", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_compaction_stats", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_extended_stats","true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_memory_stats","true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    r = store-&gt;mount(); //to force rocksdb stats</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    int NUM_OBJS = 200;</div><div class="line">    coll_t cid;</div><div class="line">    string base("testobj.");</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(base + string(buf), CEPH_NOSNAP)));</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    store-&gt;get_db_statistics(f);</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTestSpecificAUSize, garbageCollection)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    int buf_len = 256 * 1024;</div><div class="line">    int overlap_offset = 64 * 1024;</div><div class="line">    int write_offset = buf_len;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">#define WRITE_AT(offset, _length) &#123;\</div><div class="line">      ObjectStore::Transaction t;\</div><div class="line">      if ((uint64_t)_length != bl.length()) &#123; \</div><div class="line">        buffer::ptr p(bl.c_str(), _length);\</div><div class="line">        bufferlist bl_tmp;\</div><div class="line">        bl_tmp.push_back(p);\</div><div class="line">        t.write(cid, hoid, offset, bl_tmp.length(), bl_tmp);\</div><div class="line">      &#125; else &#123;\</div><div class="line">        t.write(cid, hoid, offset, bl.length(), bl);\</div><div class="line">      &#125;\</div><div class="line">      r = queue_transaction(store, ch, std::move(t));\</div><div class="line">      ASSERT_EQ(r, 0);\</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    StartDeferred(65536);</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_max_blob_size", "524288");</div><div class="line">    SetVal(g_conf, "bluestore_compression_min_blob_size", "262144");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, in);</div><div class="line">        ASSERT_EQ(-ENOENT, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::string data;</div><div class="line">    data.resize(buf_len);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            bool exists = store-&gt;exists(ch, hoid);</div><div class="line">            ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">            exists = store-&gt;exists(ch, hoid);</div><div class="line">            ASSERT_EQ(true, exists);</div><div class="line">        &#125;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i % 256;</div><div class="line"></div><div class="line">        bl.append(data);</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(0, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - 2 * overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0u);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x10000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - 3 * overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x20000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset + 1, overlap_offset-1);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x20000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset + 1, overlap_offset);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x3ffffu);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(0, buf_len-1);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40001u);</div><div class="line">        &#125;</div><div class="line">        SetVal(g_conf, "bluestore_gc_enable_total_threshold", "1"); //forbid GC when saving = 0</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(1, overlap_offset-2);</div><div class="line">            WRITE_AT(overlap_offset * 2 + 1, overlap_offset-2);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40001u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(overlap_offset + 1, overlap_offset-2);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x0);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40007u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.remove(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, fsckOnUnalignedDevice)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify(0x280005000).c_str()); //10 Gb + 4K</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    StartDeferred(0x4000);</div><div class="line">    store-&gt;umount();</div><div class="line">    ASSERT_EQ(store-&gt;fsck(false), 0); // do fsck explicitly</div><div class="line">    store-&gt;mount();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, fsckOnUnalignedDevice2)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify(0x280005000).c_str()); //10 Gb + 20K</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    StartDeferred(0x1000);</div><div class="line">    store-&gt;umount();</div><div class="line">    ASSERT_EQ(store-&gt;fsck(false), 0); // do fsck explicitly</div><div class="line">    store-&gt;mount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BluestoreRepairTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    const size_t offs_base = 65536 / 2;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size",</div><div class="line">           stringify(2 * offs_base).c_str());</div><div class="line">    SetVal(g_conf, "bluestore_extent_map_shard_max_size", "12000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    BlueStore* bstore = dynamic_cast&lt;BlueStore*&gt; (store.get());</div><div class="line"></div><div class="line">    // fill the store with some data</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid_dup(hobject_t(sobject_t("Object 1(dup)", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid_cloned = hoid2;</div><div class="line">    hoid_cloned.hobj.snap = 1;</div><div class="line">    ghobject_t hoid3(hobject_t(sobject_t("Object 3", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid3_cloned = hoid3;</div><div class="line">    hoid3_cloned.hobj.snap = 1;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line">    const size_t repeats = 16;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        cerr &lt;&lt; "create collection + write" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        for( auto i = 0ul; i &lt; repeats; ++i ) &#123;</div><div class="line">            t.write(cid, hoid, i * offs_base, bl.length(), bl);</div><div class="line">            t.write(cid, hoid_dup, i * offs_base, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        for( auto i = 0ul; i &lt; repeats; ++i ) &#123;</div><div class="line">            t.write(cid, hoid2, i * offs_base, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        t.clone(cid, hoid2, hoid_cloned);</div><div class="line"></div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bstore-&gt;umount();</div><div class="line">    //////////// leaked pextent fix ////////////</div><div class="line">    cerr &lt;&lt; "fix leaked pextents" &lt;&lt; std::endl;</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_leaked(0x30000);</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 1);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    //////////// false free fix ////////////</div><div class="line">    cerr &lt;&lt; "fix false free pextents" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_false_free(cid, hoid);</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 2);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    //////////// verify invalid statfs ///////////</div><div class="line">    cerr &lt;&lt; "fix invalid statfs" &lt;&lt; std::endl;</div><div class="line">    store_statfs_t statfs0, statfs;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    ASSERT_EQ(bstore-&gt;statfs(&amp;statfs0), 0);</div><div class="line">    statfs = statfs0;</div><div class="line">    statfs.allocated += 0x10000;</div><div class="line">    statfs.stored += 0x10000;</div><div class="line">    ASSERT_FALSE(statfs0 == statfs);</div><div class="line">    bstore-&gt;inject_statfs(statfs);</div><div class="line">    bstore-&gt;umount();</div><div class="line"></div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 1);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;mount(), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;statfs(&amp;statfs), 0);</div><div class="line">    // adjust free space to success in comparison</div><div class="line">    statfs0.available = statfs.available;</div><div class="line">    ASSERT_EQ(statfs0, statfs);</div><div class="line"></div><div class="line">    ///////// undecodable shared blob key / stray shared blob records ///////</div><div class="line">    cerr &lt;&lt; "undecodable shared blob key" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undec1",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undecodable key 2",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undecodable key 3",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 3);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    cerr &lt;&lt; "misreferencing" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, 0);</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, (offs_base * repeats) / 2);</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, offs_base * (repeats -1) );</div><div class="line"></div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 6);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line"></div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(true), 0);</div><div class="line"></div><div class="line">    // reproducing issues #21040 &amp; 20983</div><div class="line">    SetVal(g_conf, "bluestore_debug_inject_bug21040", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    bstore-&gt;mount();</div><div class="line"></div><div class="line">    cerr &lt;&lt; "repro bug #21040" &lt;&lt; std::endl;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bl.append("0123456789012345");</div><div class="line">            t.write(cid, hoid3, offs_base, bl.length(), bl);</div><div class="line">            bl.clear();</div><div class="line">            bl.append('!');</div><div class="line">            t.write(cid, hoid3, 0, bl.length(), bl);</div><div class="line"></div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.clone(cid, hoid3, hoid3_cloned);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bstore-&gt;umount();</div><div class="line">        ASSERT_EQ(bstore-&gt;fsck(false), 3);</div><div class="line">        ASSERT_LE(bstore-&gt;repair(false), 0);</div><div class="line">        ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">        SetVal(g_conf, "bluestore_debug_inject_bug21040", "true");</div><div class="line">        g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    cerr &lt;&lt; "Completing" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, BluestoreStatistics)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "rocksdb_perf", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_compaction_stats", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_extended_stats","true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_memory_stats","true");</div><div class="line"></div><div class="line">    // disable cache</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_ssd", "0");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_hdd", "0");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size", "0");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    BlueStore* bstore = NULL;</div><div class="line">    EXPECT_NO_THROW(bstore = dynamic_cast&lt;BlueStore*&gt; (store.get()));</div><div class="line"></div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_db_statistics", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = bstore-&gt;create_new_collection(cid);</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("0123456789abcdefghi");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(bstore, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist readback;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, bl.length(), readback);</div><div class="line">        ASSERT_EQ(r, bl.length());</div><div class="line">        ASSERT_TRUE(bl_eq(bl, readback));</div><div class="line">    &#125;</div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    EXPECT_NO_THROW(store-&gt;get_db_statistics(f));</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line">#endif  // WITH_BLUESTORE</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    vector&lt;const char*&gt; args;</div><div class="line">    argv_to_vec(argc, (const char **)argv, args);</div><div class="line"></div><div class="line">    auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT,</div><div class="line">                           CODE_ENVIRONMENT_UTILITY,</div><div class="line">                           CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);</div><div class="line">    common_init_finish(g_ceph_context);</div><div class="line"></div><div class="line">    // make sure we can adjust any config settings</div><div class="line">    g_ceph_context-&gt;_conf-&gt;_clear_safe_to_start_threads();</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("osd_journal_size", "400");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_index_retry_probability", "0.5");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_op_thread_timeout", "1000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_op_thread_suicide_timeout", "10000");</div><div class="line">    //g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_fiemap", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_mkfs", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_mount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_umount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_misc", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_small_allocations", "4");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_freelist", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_clone_cow", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_max_alloc_size", "196608");</div><div class="line"></div><div class="line">    // set small cache sizes so we see trimming during Synthetic tests</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_cache_size_hdd", "4000000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_cache_size_ssd", "4000000");</div><div class="line"></div><div class="line">    // very short *_max prealloc so that we fall back to async submits</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_blobid_prealloc", "10");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_nid_prealloc", "10");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_randomize_serial_transaction",</div><div class="line">                                          "10");</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bdev_debug_aio", "true");</div><div class="line"></div><div class="line">    // specify device size</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_block_size",</div><div class="line">                                          stringify(DEF_STORE_TEST_BLOCKDEV_SIZE));</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die(</div><div class="line">        "enable_experimental_unrecoverable_data_corrupting_features", "*");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    ::testing::InitGoogleTest(&amp;argc, argv);</div><div class="line">    return RUN_ALL_TESTS();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * Local Variables:</div><div class="line"> * compile-command: "cd ../.. ; make ceph_test_objectstore &amp;&amp;</div><div class="line"> *    ./ceph_test_objectstore \</div><div class="line"> *        --gtest_filter=*.collect_metadata* --log-to-stderr=true --debug-filestore=20</div><div class="line"> *  "</div><div class="line"> * End:</div><div class="line"> */</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/6.store_test.cc" data-title="1.5 store_test.cc代码阅读" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/2.模板简介" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/31/stl/2.模板简介/" class="article-date">
  	<time datetime="2018-07-31T14:41:19.852Z" itemprop="datePublished">2018-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/31/stl/2.模板简介/">1.2 模板元编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板示例"><a href="#模板示例" class="headerlink" title="模板示例"></a>模板示例</h1><p>这里自己实现一个判断两个对象是否相等的模板函数。同时也定义一个模板类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equ</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !(a &lt; b) &amp;&amp; !(b &lt; a);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> number &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    number(<span class="keyword">const</span> T &amp;v): v_(v) &#123; &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> number &amp;n) <span class="keyword">const</span> ;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    T v_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">bool</span> number&lt;T&gt;::<span class="keyword">operator</span> &lt;(<span class="keyword">const</span> number &amp;n) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> v_ &lt; n.v_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    number&lt;<span class="keyword">int</span>&gt; a(<span class="number">1</span>), b(<span class="number">1</span>);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; equ(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; equ&lt;<span class="keyword">double</span>&gt;(<span class="number">1.0</span>, <span class="number">2.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模板的参数"><a href="#模板的参数" class="headerlink" title="模板的参数"></a>模板的参数</h1><ul>
<li>类型参数（type template parameter），用 typename 或 class 标记；(最好是用<code>typename</code>)</li>
<li>非类型参数（non-type template parameter）可以是：整数及枚举类型、对象或函数的指针、对象或函数的引用、对象的成员指针，非类型参数是模板实例的常量；</li>
<li>模板型参数（template template parameter），如<code>template&lt;typename T, template&lt;typename&gt; class A&gt; someclass {};</code>；</li>
<li>模板参数可以有默认值（函数模板参数默认是从 C++11 开始支持）；</li>
<li>函数模板的和函数参数类型有关的模板参数可以自动推导，<strong>类模板参数不存在推导机制</strong>；</li>
<li>C++11 引入变长模板参数。</li>
</ul>
<p>总结一下：</p>
<ul>
<li>参数必须是字面量。无论常数，类型，自定义类型，模板类型都是编译时的常量。运行时的变量是不能用的。</li>
<li>类和函数模板参数都可以有默认值</li>
<li>函数可以自动推导，类模板不可以。</li>
</ul>
<p><strong>运行时变量不可以</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; &#123;</div><div class="line">    <span class="keyword">float</span> v_[<span class="number">4</span>];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">bool</span>, N&gt;&#123;</div><div class="line">    <span class="keyword">char</span> v_[(N+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>)];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;        <span class="comment">// 这里是一个变量</span></div><div class="line">    Vec&lt;<span class="keyword">bool</span>, N&gt; bits; <span class="comment">// Compile ERROR! 利用变量来模板化类</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么函数是否可以呢？</p>
<h1 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h1><p>特化的时候，可以：</p>
<ul>
<li>将<code>Base</code>模板里面的类具体化。</li>
<li>只具体化某个模板参数，其他的保留。</li>
</ul>
<h2 id="所有的参数具体化"><a href="#所有的参数具体化" class="headerlink" title="所有的参数具体化"></a>所有的参数具体化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">float</span>, <span class="number">4</span>&gt; &#123;</div><div class="line">    <span class="keyword">float</span> v_[<span class="number">4</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如在<code>base</code>类里面声明了两个参数，这两个参数都可以具体化。<code>T = float, N = 4</code>。</p>
<h2 id="具体化某部分参数"><a href="#具体化某部分参数" class="headerlink" title="具体化某部分参数"></a>具体化某部分参数</h2><p><code>base</code>类的参数是<code>typename T, int N</code>，那么可不可以只具体化<code>typename T = bool</code>呢？答案是可以的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&#123;</div><div class="line">    T v_[N];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> Vec&lt;<span class="keyword">bool</span>, N&gt; &#123;</div><div class="line">    <span class="keyword">char</span> v_[(N+<span class="keyword">sizeof</span>(<span class="keyword">char</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>)];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>术语:</p>
<ul>
<li><p>最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（<code>full specialization</code>），</p>
</li>
<li><p>另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（<code>partial specialization</code>）</p>
</li>
</ul>
<p>用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/2.模板简介" data-title="1.2 模板元编程" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/4.CompatSet" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/31/ceph/4.CompatSet/" class="article-date">
  	<time datetime="2018-07-31T05:28:32.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/31/ceph/4.CompatSet/">1.3 CompatSet</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://blog.csdn.net/litianze99/article/details/74596843" target="_blank" rel="external">https://blog.csdn.net/litianze99/article/details/74596843</a></p>
<p><code>CompatSet</code>是一个结构体类型，其用于对特性兼容性进行管理。该类型的定义位于<code>src/include/CompatSet.h</code>文件中。</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p><code>OSD</code>对外提供一些功能特性，这个些特性需要<code>OSD</code>后端的存储驱动（或者文件系统）如filestore支持，如果后端驱动不支持，即两者之间在某些特性上不能兼容，就会影响读写操作，所以谨慎处理这些特性的兼容性是非常重要的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> CompatSet &#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> Feature &#123;</div><div class="line">        <span class="keyword">uint64_t</span> id;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;</div><div class="line"></div><div class="line">        Feature(<span class="keyword">uint64_t</span> <span class="number">_</span>id, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="number">_</span>name) : id(<span class="number">_</span>id), name(<span class="number">_</span>name) &#123;&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> FeatureSet &#123;</div><div class="line">        <span class="keyword">uint64_t</span> mask;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; names;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// These features have no impact on the read / write status</span></div><div class="line">    FeatureSet compat;</div><div class="line">    <span class="comment">// If any of these features are missing, read is possible ( as long</span></div><div class="line">    <span class="comment">// as no incompat feature is missing ) but it is not possible to write</span></div><div class="line">    FeatureSet ro_compat;</div><div class="line">    <span class="comment">// If any of these features are missing, read or write is not possible</span></div><div class="line">    FeatureSet incompat;</div></pre></td></tr></table></figure>
<h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><p>该类型包含两个重要属性： </p>
<ul>
<li>id：特性的唯一标识 </li>
<li>name：特性的名字</li>
</ul>
<h2 id="FeatureSet"><a href="#FeatureSet" class="headerlink" title="FeatureSet"></a>FeatureSet</h2><p>该类型包含两个重要属性： </p>
<ul>
<li>mask：标识该组特性的位图 </li>
<li>names：是一个map，key为特性的id，value为特性的name</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>该类型中包含了三个重要的属性，分别是：<code>compat</code>、<code>ro_compat</code>、<code>incompat</code>，都是<code>FeatureSet</code>实例。 </p>
<ul>
<li>compat：该组中的特性支持与否，对读写没有任何影响。 </li>
<li>ro_compat：该组中的特性，如果不支持，则会影响写入操作，读操作没有影响。 </li>
<li>incompat：该组中的特性，如果不支持，则会影响读写操作。</li>
</ul>
<h1 id="主要的功能与接口"><a href="#主要的功能与接口" class="headerlink" title="主要的功能与接口"></a>主要的功能与接口</h1><h2 id="readable"><a href="#readable" class="headerlink" title="readable"></a>readable</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 这个文件系统是否实现了相应的接口，进而可以读取另外一个file system.</span></div><div class="line"><span class="comment">/* does this filesystem implementation have the</span></div><div class="line">   features required to read the other? */</div><div class="line"><span class="keyword">bool</span> CompatSet::readable(CompatSet <span class="keyword">const</span>&amp; other) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> !((other.incompat.mask ^ incompat.mask) &amp; other.incompat.mask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="writeable"><a href="#writeable" class="headerlink" title="writeable"></a>writeable</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 这个文件系统的实现，是否有需要写other时所需的特性</span></div><div class="line"><span class="comment">/* does this filesystem implementation have the</span></div><div class="line">   features required to write the other? */</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writeable</span><span class="params">(CompatSet <span class="keyword">const</span>&amp; other)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> readable(other) &amp;&amp;</div><div class="line">           !((other.ro_compat.mask ^ ro_compat.mask) &amp; other.ro_compat.mask);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h2><p>注意这里的比较是基于特性的比较。<code>a&lt;b</code>时是不能保证<code>b&lt;a</code>的。这是因为</p>
<ul>
<li>0 表示两者的特性集是一样</li>
<li>1 表示a是b的超集</li>
<li>-1表示a缺少b里面至少一个特性</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* Compare this CompatSet to another.</span></div><div class="line"> * CAREFULLY <span class="doctag">NOTE:</span> This operation is NOT commutative.</div><div class="line"> * a &gt; b DOES NOT imply that b &lt; a.</div><div class="line"> * If returns:</div><div class="line"> * 0: The CompatSets have the same feature set.</div><div class="line"> * 1: This CompatSet's features are a strict superset of the other's.</div><div class="line"> * -1: This CompatSet is missing at least one feature</div><div class="line"> *     described in the other. It may still have more features, though.</div><div class="line"> */</div><div class="line"><span class="keyword">int</span> CompatSet::compare(<span class="keyword">const</span> CompatSet&amp; other) &#123;</div><div class="line">  <span class="keyword">if</span> ((other.compat.mask == compat.mask) &amp;&amp;</div><div class="line">      (other.ro_compat.mask == ro_compat.mask) &amp;&amp;</div><div class="line">      (other.incompat.mask == incompat.mask)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="comment">//okay, they're not the same</span></div><div class="line"></div><div class="line">  <span class="comment">//if we're writeable we have a superset of theirs on incompat and ro_compat</span></div><div class="line">  <span class="keyword">if</span> (writeable(other) &amp;&amp; !((other.compat.mask ^ compat.mask)</div><div class="line">                            &amp; other.compat.mask)) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="comment">//if we make it here, we weren't writeable or had a difference compat set</span></div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="unsupported"><a href="#unsupported" class="headerlink" title="unsupported"></a>unsupported</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/4.CompatSet" data-title="1.3 CompatSet" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/5.ObjectStore的接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/31/ceph/5.ObjectStore的接口/" class="article-date">
  	<time datetime="2018-07-31T05:28:32.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/31/ceph/5.ObjectStore的接口/">1.4 ObjectStore的接口</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Flag bits</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">osflagbits_t</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SKIP_JOURNAL_REPLAY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SKIP_MOUNT_OMAP = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这里主要是工程意义上的写法比较有意思，比如要设置第<code>x</code>位，就<br><code>1&lt;&lt;x</code>。</p>
<h1 id="成员以及函数"><a href="#成员以及函数" class="headerlink" title="成员以及函数"></a>成员以及函数</h1><p>以下部分都是<code>ObjectStore</code>的成员或者成员函数。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><code>ObjectStore</code>上下文以及路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ObjectStore的路径</span></div><div class="line"><span class="built_in">string</span> path;</div><div class="line">CephContext* cct;</div></pre></td></tr></table></figure>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>好像很多抽象类在有很多派生类的时候，都很喜欢用这种<code>create</code>工厂方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * create - create an ObjectStore instance.</div><div class="line"> *</div><div class="line"> * This is invoked once at initialization time.</div><div class="line"> *</div><div class="line"> * @param type type of store. This is a string from the configuration file.</div><div class="line"> * @param data path (or other descriptor) for data</div><div class="line"> * @param journal path (or other descriptor) for journal (optional)</div><div class="line"> * @param flags which filestores should check if applicable</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ObjectStore *<span class="title">create</span><span class="params">(CephContext *cct,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; type,</div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; data,</div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; journal,</div><div class="line">                           <span class="keyword">osflagbits_t</span> flags = <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>可以看到，这里需要指定：</p>
<ul>
<li>需要的<code>ObjectStore</code>的类型</li>
<li>需要的<code>ObjectStore</code>的数据区</li>
<li><code>ObjectStore</code>的日志区</li>
<li><code>ObjectStore</code>的标志位</li>
</ul>
<p>这里的标志位主要是两个：</p>
<ol>
<li>是否需要<code>journal</code>重放</li>
<li>是否需要<code>mount omap</code></li>
</ol>
<p>注意看前面给出的两个<code>SKIP_</code>标志位。</p>
<h2 id="读取fsid"><a href="#读取fsid" class="headerlink" title="读取fsid"></a>读取fsid</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * probe a block device to learn the uuid of the owning OSD</div><div class="line"> *</div><div class="line"> * @param cct cct</div><div class="line"> * @param path path to device</div><div class="line"> * @param fsid [out] osd uuid</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">probe_block_device_fsid</span><span class="params">(</span></span></div><div class="line">    CephContext *cct,</div><div class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path,</div><div class="line">    uuid_d *fsid);</div></pre></td></tr></table></figure>
<p>这里是用来读取<code>ObjectStore</code>的<code>fsid</code>，也就是看一下属于哪个cluster。<br>不同的<code>ObjectStore</code>的实现是不一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> ObjectStore::probe_block_device_fsid(</div><div class="line">    CephContext *cct,</div><div class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path,</div><div class="line">    uuid_d *fsid)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WITH_BLUESTORE)</span></div><div class="line">    <span class="comment">// first try bluestore -- it has a crc on its header and will fail</span></div><div class="line">    <span class="comment">// reliably.</span></div><div class="line">    r = BlueStore::get_block_device_fsid(cct, path, fsid);</div><div class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">        lgeneric_dout(cct, <span class="number">0</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">" "</span> &lt;&lt; path &lt;&lt; <span class="string">" is bluestore, "</span></div><div class="line">                              &lt;&lt; *fsid &lt;&lt; dendl;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// okay, try FileStore (journal).</span></div><div class="line">    r = FileStore::get_block_device_fsid(cct, path, fsid);</div><div class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">        lgeneric_dout(cct, <span class="number">0</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">" "</span> &lt;&lt; path &lt;&lt; <span class="string">" is filestore, "</span></div><div class="line">                              &lt;&lt; *fsid &lt;&lt; dendl;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> -EINVAL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码的设计上来，实际上最好是把各种代码，分散到自己的实现里面。而不是在这里通过<code>if else</code>来调用。这里稍微通过<code>FileStore</code>展开一下。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">int FileStore::get_block_device_fsid(CephContext* cct, const string&amp; path,</div><div class="line">                                     uuid_d *fsid)</div><div class="line">&#123;</div><div class="line">    // make sure we don't try to use aio or direct_io (and get annoying</div><div class="line">    // error messages from failing to do so); performance implications</div><div class="line">    // should be irrelevant for this use</div><div class="line">    FileJournal j(cct, *fsid, 0, 0, path.c_str(), false, false);</div><div class="line">    return j.peek_fsid(*fsid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// This can not be used on an active journal</div><div class="line">int FileJournal::peek_fsid(uuid_d&amp; fsid)</div><div class="line">&#123;</div><div class="line">    assert(fd == -1);</div><div class="line">    int r = _open(false, false);</div><div class="line">    if (r)</div><div class="line">        return r;</div><div class="line">    r = read_header(&amp;header);</div><div class="line">    if (r &lt; 0)</div><div class="line">        goto out;</div><div class="line">    fsid = header.fsid;</div><div class="line">out:</div><div class="line">    close();</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这段代码实际上就是打开<code>journal</code>，然后读取<code>journal</code>的头部，从头部中拿到<code>journal</code>的<code>header</code>信息，然后再取出其中的<code>fsid</code>。</p>
<h2 id="获取ObjectStore的性能数据"><a href="#获取ObjectStore的性能数据" class="headerlink" title="获取ObjectStore的性能数据"></a>获取ObjectStore的性能数据</h2><p>通过注释可以看出，这里主要是获取<code>ObjectStore</code>的<code>commit/apply</code>的latency信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Fetch Object Store statistics.</div><div class="line"> *</div><div class="line"> * Currently only latency of write and apply times are measured.</div><div class="line"> *</div><div class="line"> * This appears to be called with nothing locked.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">virtual</span> objectstore_perf_stat_t <span class="title">get_cur_stats</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>那么这里可以展开<code>get_cur_stats</code>看一下<code>FileStore.h</code>是如何处理的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> FSPerfTracker &#123;</div><div class="line">    PerfCounters::avg_tracker&lt;<span class="keyword">uint64_t</span>&gt; os_commit_latency_ns;</div><div class="line">    PerfCounters::avg_tracker&lt;<span class="keyword">uint64_t</span>&gt; os_apply_latency_ns;</div><div class="line"></div><div class="line">    <span class="keyword">objectstore_perf_stat_t</span> get_cur_stats() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">objectstore_perf_stat_t</span> ret;</div><div class="line">        ret.os_commit_latency_ns = os_commit_latency_ns.current_avg();</div><div class="line">        ret.os_apply_latency_ns = os_apply_latency_ns.current_avg();</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_from_perfcounters</span><span class="params">(PerfCounters &amp;logger)</span></span>;</div><div class="line">&#125; perf_tracker;</div><div class="line"></div><div class="line"><span class="keyword">objectstore_perf_stat_t</span> get_cur_stats() override &#123;</div><div class="line">    perf_tracker.update_from_perfcounters(*logger);</div><div class="line">    <span class="keyword">return</span> perf_tracker.get_cur_stats();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来，这里更新的变量主要是：</p>
<ul>
<li>os_commit_latency_ns</li>
<li>os_apply_latency_ns</li>
</ul>
<h2 id="拿到性能计数器"><a href="#拿到性能计数器" class="headerlink" title="拿到性能计数器"></a>拿到性能计数器</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Fetch Object Store performance counters.</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * This appears to be called with nothing locked.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> PerfCounters* <span class="title">get_perf_counters</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这里大部分子类，如果存在性能计数器，那么基本上都是一句话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> PerfCounters* <span class="title">get_perf_counters</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</div><div class="line">    <span class="keyword">return</span> logger;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Ceph在通常情况下认为事务之间是没有相关性的，也就是说<code>事务A</code>与<code>事务B</code>可以用任何顺序来进行提交。那么如果是用户对于某些事务有先后顺序的要求呢？</p>
<p>比如一定要<code>事务A， 事务B，事务C</code>，这个时候就需要利用<code>Collection</code>把<code>A,B,C</code>排好序并且放在一起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个collection里面包含的是一系列有先后顺序的事务</div><div class="line"> * 在同一个collection里面的事务队列，在apply的时候，必面根据先后顺序一个一个来。</div><div class="line"> * 在不同collection的事务是可以并行提交的。</div><div class="line"> *</div><div class="line"> * ObjectStore users可以得到collection的指针，通过两种方式</div><div class="line"> * - open_collection()</div><div class="line"> * - create_new_collection()</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> CollectionImpl : <span class="keyword">public</span> RefCountedObject &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">coll_t</span> cid;</div><div class="line"></div><div class="line">    CollectionImpl(<span class="keyword">const</span> <span class="keyword">coll_t</span>&amp; c)</div><div class="line">        : RefCountedObject(<span class="literal">NULL</span>, <span class="number">0</span>),</div><div class="line">          cid(c) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/// wait for any queued transactions to apply</span></div><div class="line">    <span class="comment">// block until any previous transactions are visible.  specifically,</span></div><div class="line">    <span class="comment">// collection_list and collection_empty need to reflect prior operations.</span></div><div class="line">    <span class="comment">// flush函数的作用就是一个一个地apply transactions</span></div><div class="line">    <span class="comment">// 必须要等到前面的事务都生效之后，后面的事务才可以推进。</span></div><div class="line">    <span class="comment">// collection_list()和collection_empty()这两个函数</span></div><div class="line">    <span class="comment">// 需要反映之前的操作。</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p><strong>问题</strong>暂时不去管这个<code>collection_list</code>和<code>collection_empty</code>这两个函数的具体作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Async flush_commit</div><div class="line">     * 这个是异步flush commit</div><div class="line">     * 两种情况：</div><div class="line">     * 1. collection当前是空闲的，flush_commit返回true</div><div class="line">     *    c不动</div><div class="line">     * 2. collection并不空闲，这个方法返回false并且c会被异步调用.</div><div class="line">     *    一旦这个collection里面所有的事务都先于flush_commit函数applied/commited了</div><div class="line">     *    那么一个0值就会返回</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">flush_commit</span><span class="params">(Context *c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">const</span> coll_t &amp;<span class="title">get_cid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cid; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 定义Collection的句柄</span></div><div class="line"><span class="keyword">typedef</span> boost::intrusive_ptr&lt;CollectionImpl&gt; CollectionHandle;</div></pre></td></tr></table></figure>
<h2 id="Object的内容与语义"><a href="#Object的内容与语义" class="headerlink" title="Object的内容与语义"></a>Object的内容与语义</h2><p>所有<code>ObjectStore</code>里面的<code>objects</code>都是唯一的，无论是<code>ghobject_t和hobject_t</code>。<br><code>ObjectStore</code>的操作支持<code>创建，修改，删除，罗列</code>collection中的<code>objects</code>。</p>
<p>但是这里的<code>罗列</code>是根据<code>object key</code>来进行排列的。所有的<code>object name</code>在整个<code>Ceph</code>系统里面<br>都是唯一的。</p>
<p>每个<code>object</code>都会有三个离散的三个部分：</p>
<ul>
<li>数据</li>
<li>xattrs</li>
<li>omap_header</li>
<li>omap_entries</li>
</ul>
<p>关于<code>Omap</code>可以看一下这个链表：<a href="http://bean-li.github.io/ceph-omap/" target="_blank" rel="external">http://bean-li.github.io/ceph-omap/</a></p>
<p>简单地概述一下就是。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">FileStore的omap中存放的都是对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢？</div><div class="line"></div><div class="line">最直接的想法就是（object_id + xattr_key），两者结合一起，形成对象的键值key，但是这种方法有一个问题，object_id可能会很长，尤其是当单个对象存在很多属性的时候，object_id不得不在key值中出现多次，这必然会造成存储空间的浪费。</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Ceph的FileStore分成了<span class="number">2</span>步：</div><div class="line"></div><div class="line">第一步: 根据object_id生成一个比较短的seq，然后把这个seq存放到omap_header中。</div><div class="line">第二步: 然后seq + xattr_key形成对象的某个属性的键值。</div></pre></td></tr></table></figure>
<h3 id="如何生成seq"><a href="#如何生成seq" class="headerlink" title="如何生成seq"></a>如何生成seq</h3><p>如果是<code>LevelDB</code>来实现<code>Omap</code>的话，那么就是在<code>LevelDB</code>中存储一个<code>OSD</code>当前全局的<code>key</code>值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">key: SYS_PREFIX + GLOBAL_STATE_KEY</div><div class="line">value: state</div></pre></td></tr></table></figure>
<p>要申请<code>seq</code>的时候，针对这个<code>seq</code>上锁然后递增。<code>seq</code>是放在<code>state</code>里面的。<code>state</code>的内容就存放到<code>LevelDB</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> State &#123;</div><div class="line">    <span class="number">__u</span>8 v;</div><div class="line">    <span class="keyword">uint64_t</span> seq;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="object-id到seq"><a href="#object-id到seq" class="headerlink" title="object_id到seq"></a>object_id到seq</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">_</span>Header &#123;</div><div class="line">    <span class="keyword">uint64_t</span> seq;</div><div class="line">    <span class="keyword">uint64_t</span> parent;</div><div class="line">    <span class="keyword">uint64_t</span> num_children;</div><div class="line">    <span class="keyword">coll_t</span> c;</div><div class="line">    <span class="keyword">ghobject_t</span> oid; </div><div class="line">    SequencerPosition spos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当生成<code>seq</code>之后，立即生成一个<code>header</code>结构。然后把这个<code>header</code>存放到<code>LevelDB</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">key： HOBJECT_TO_SEQ + ghobject_key(oid)</div><div class="line">value: header</div></pre></td></tr></table></figure>
<h3 id="Object的data"><a href="#Object的data" class="headerlink" title="Object的data"></a>Object的data</h3><p>object的数据部分理念上是等价于一个文件系统里面的文件。对于object的随机和部分读写都要可以进行。对于数据部分的稀疏处理并不是一个强需求。一般而言，单个object不要太大，大的话一般100MB左右。</p>
<h3 id="Object的xattrs"><a href="#Object的xattrs" class="headerlink" title="Object的xattrs"></a>Object的xattrs</h3><p>xattrs主要是存放在文件系统的attrs上。而omap一般则是存放在<code>leveldb</code>上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*********************************</span></div><div class="line"> * 事务</div><div class="line"> *</div><div class="line"> * 一个事务包含了一系列修改操作。</div><div class="line"> *</div><div class="line"> * 一个事务的三个事件会导致回调。任何一个事务都会带如下的</div><div class="line"> * 回调函数。</div><div class="line"> *</div><div class="line"> *    on_applied_sync, on_applied, and on_commit.</div><div class="line"> *</div><div class="line"> * `on_applied`和`on_applied_sync`这两个回调都是在修改正式生效之后才会被触发。所谓的修改生效就是指修改被后面的操作可见。</div><div class="line"> *</div><div class="line"> * 唯一理论上的差异`on_applied`和`on_applied_sync`是在于callback发生的操作线程以及锁环境。`on_applied_sync`语意上就是说直接会被执行线程触发，往往是在急着要执行，并且在当前的环境下不能持有锁的调用环境。(去申请锁可能会导致wait也就是等待)</div><div class="line"> * 相反地`on_applied`则是另外一个Finisher线程来调用的。这也就是意味着调用环境满足去申请锁的各种条件(这里主要是指申请的时候可以wait)。</div><div class="line"> * 需要注意的是：on_applied和on_applied_sync有时候也会被叫做on_readable和on_readable_sync。</div><div class="line"> *</div><div class="line"> * on_commit回调则肯定是由另外一个Finisher线程来调用的。并且所有的修改操作已经写到journal上。也就是持久化了。</div><div class="line"> *</div><div class="line"> * 就从journal写日志的实现上来说，每次原始的修改（包含相关的数据）都可以被串行化到一个单一的buffer里面。这个串行化并不会拷贝任何数据本身，而是直接引用到原有的数据。这样一来，就需要原有的数据保持不变，直接on_commit回调函数成功。在实践上，缓冲区处理所有的这种情况，主要是通过bufferlist::raw_static引用到相应的data缓冲区。</div><div class="line"> *</div><div class="line"> * 一些ObjectStore的实施选实施他们自己形式的journal并且利用串行化来实现一个事务。在这种情况下就需要保证encode/decode逻辑合理地处理好version,并且要处理好升级。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * TRANSACTION ISOLATION  事务独立性</div><div class="line"> *</div><div class="line"> * 事务的独立性是由于调用方来实施的。除此之外，独立性是指，</div><div class="line"> * object相关的四个部分被一个事务修改/删除的时候，调用方并不会说去读取这个object的相应元素，特别是当这个事务有可能被阻塞的情况下。这里阻塞指的是`one_applied_sync`回调被执行了。</div><div class="line"> * 对于这个规则的违反并不会被ObjectStore所监管到。并且也不会有相应的错误被raise出来。</div><div class="line"> * 简单地说就是事务与事务之间是相互独立的，事务之间的关系，需要调用者来加以保证。</div><div class="line"> * Except as noted above, isolation is the responsibility of the</div><div class="line"> * caller. In other words, if any storage element (storage element</div><div class="line"> * == any of the four portions of an object as described above) is</div><div class="line"> * altered by a transaction (including deletion), the caller</div><div class="line"> * promises not to attempt to read that element while the</div><div class="line"> * transaction is pending (here pending means from the time of</div><div class="line"> * issuance until the "on_applied_sync" callback has been</div><div class="line"> * received). Violations of isolation need not be detected by</div><div class="line"> * ObjectStore and there is no corresponding error mechanism for</div><div class="line"> * reporting an isolation violation (crashing would be the</div><div class="line"> * appropriate way to report an isolation violation if detected).</div><div class="line"> *</div><div class="line"> * Enumeration operations may violate transaction isolation as</div><div class="line"> * described above when a storage element is being created or</div><div class="line"> * deleted as part of a transaction. In this case, ObjectStore is</div><div class="line"> * allowed to consider the enumeration operation to either precede</div><div class="line"> * or follow the violating transaction element. In other words, the</div><div class="line"> * presence/absence of the mutated element in the enumeration is</div><div class="line"> * entirely at the discretion of ObjectStore. The arbitrary ordering</div><div class="line"> * applies independently to each transaction element. For example,</div><div class="line"> * if a transaction contains two mutating elements "create A" and</div><div class="line"> * "delete B". And an enumeration operation is performed while this</div><div class="line"> * transaction is pending. It is permissable for ObjectStore to</div><div class="line"> * report any of the four possible combinations of the existence of</div><div class="line"> * A and B.</div><div class="line"> *</div><div class="line"> */</div></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight"><table><tr><td class="code"><pre><div class="line">class Transaction &#123;</div><div class="line">public:</div><div class="line">    // 这里有点类似于设计了一套指令。</div><div class="line">    enum &#123;</div><div class="line">        OP_NOP =          0,</div><div class="line">        OP_TOUCH =        9,   // cid, oid</div><div class="line">        OP_WRITE =        10,  // cid, oid, offset, len, bl</div><div class="line">        OP_ZERO =         11,  // cid, oid, offset, len</div><div class="line">        OP_TRUNCATE =     12,  // cid, oid, len</div><div class="line">        OP_REMOVE =       13,  // cid, oid</div><div class="line">        OP_SETATTR =      14,  // cid, oid, attrname, bl</div><div class="line">        OP_SETATTRS =     15,  // cid, oid, attrset</div><div class="line">        OP_RMATTR =       16,  // cid, oid, attrname</div><div class="line">        OP_CLONE =        17,  // cid, oid, newoid</div><div class="line">        OP_CLONERANGE =   18,  // cid, oid, newoid, offset, len</div><div class="line">        OP_CLONERANGE2 =  30,  // cid, oid, newoid, srcoff, len, dstoff</div><div class="line"></div><div class="line">        OP_TRIMCACHE =    19,  // cid, oid, offset, len  **DEPRECATED**</div><div class="line"></div><div class="line">        OP_MKCOLL =       20,  // cid</div><div class="line">        OP_RMCOLL =       21,  // cid</div><div class="line">        OP_COLL_ADD =     22,  // cid, oldcid, oid</div><div class="line">        OP_COLL_REMOVE =  23,  // cid, oid</div><div class="line">        OP_COLL_SETATTR = 24,  // cid, attrname, bl</div><div class="line">        OP_COLL_RMATTR =  25,  // cid, attrname</div><div class="line">        OP_COLL_SETATTRS = 26,  // cid, attrset</div><div class="line">        OP_COLL_MOVE =    8,   // newcid, oldcid, oid</div><div class="line"></div><div class="line">        OP_RMATTRS =      28,  // cid, oid</div><div class="line">        OP_COLL_RENAME =       29,  // cid, newcid</div><div class="line"></div><div class="line">        OP_OMAP_CLEAR = 31,   // cid</div><div class="line">        OP_OMAP_SETKEYS = 32, // cid, attrset</div><div class="line">        OP_OMAP_RMKEYS = 33,  // cid, keyset</div><div class="line">        OP_OMAP_SETHEADER = 34, // cid, header</div><div class="line">        OP_SPLIT_COLLECTION = 35, // cid, bits, destination</div><div class="line">        OP_SPLIT_COLLECTION2 = 36, /* cid, bits, destination</div><div class="line">    doesn't create the destination */</div><div class="line">        OP_OMAP_RMKEYRANGE = 37,  // cid, oid, firstkey, lastkey</div><div class="line">        OP_COLL_MOVE_RENAME = 38,   // oldcid, oldoid, newcid, newoid</div><div class="line"></div><div class="line">        OP_SETALLOCHINT = 39,  // cid, oid, object_size, write_size</div><div class="line">        OP_COLL_HINT = 40, // cid, type, bl</div><div class="line"></div><div class="line">        OP_TRY_RENAME = 41,   // oldcid, oldoid, newoid</div><div class="line"></div><div class="line">        OP_COLL_SET_BITS = 42, // cid, bits</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // Transaction hint type</div><div class="line">    enum &#123;</div><div class="line">        COLL_HINT_EXPECTED_NUM_OBJECTS = 1,</div><div class="line">    &#125;;</div><div class="line">    // 真正的操作</div><div class="line">    struct Op &#123;</div><div class="line">        __le32 op;  // 这里用数字来表示操作的类型，也可以看做是指令的类型</div><div class="line">        __le32 cid;</div><div class="line">        __le32 oid;</div><div class="line">        __le64 off;</div><div class="line">        __le64 len;</div><div class="line">        __le32 dest_cid;</div><div class="line">        __le32 dest_oid;                  //OP_CLONE, OP_CLONERANGE</div><div class="line">        __le64 dest_off;                  //OP_CLONERANGE</div><div class="line">        union &#123;</div><div class="line">            struct &#123;</div><div class="line">                __le32 hint_type;             //OP_COLL_HINT</div><div class="line">            &#125;;</div><div class="line">            struct &#123;</div><div class="line">                __le32 alloc_hint_flags;      //OP_SETALLOCHINT</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        __le64 expected_object_size;      //OP_SETALLOCHINT</div><div class="line">        __le64 expected_write_size;       //OP_SETALLOCHINT</div><div class="line">        __le32 split_bits;                //OP_SPLIT_COLLECTION2,OP_COLL_SET_BITS,</div><div class="line">        //OP_MKCOLL</div><div class="line">        __le32 split_rem;                 //OP_SPLIT_COLLECTION2</div><div class="line">    &#125; __attribute__ ((packed)) ;</div><div class="line">    // </div><div class="line">    struct TransactionData &#123;</div><div class="line">        __le64 ops;  // 这个应该是指的操作的数量</div><div class="line">        __le32 largest_data_len;</div><div class="line">        __le32 largest_data_off;</div><div class="line">        __le32 largest_data_off_in_data_bl;</div><div class="line">        __le32 fadvise_flags;</div><div class="line">    &#125; __attribute__ ((packed)) ;</div><div class="line"></div><div class="line">private:</div><div class="line">    TransactionData data;</div><div class="line"></div><div class="line">    map&lt;coll_t, __le32&gt; coll_index;</div><div class="line">    map&lt;ghobject_t, __le32&gt; object_index;</div><div class="line"></div><div class="line">    __le32 coll_id &#123;0&#125;;</div><div class="line">    __le32 object_id &#123;0&#125;;</div><div class="line"></div><div class="line">    bufferlist data_bl;</div><div class="line">    bufferlist op_bl;</div><div class="line"></div><div class="line">    bufferptr op_ptr;</div><div class="line"></div><div class="line">    list&lt;Context *&gt; on_applied;</div><div class="line">    list&lt;Context *&gt; on_commit;</div><div class="line">    list&lt;Context *&gt; on_applied_sync;</div><div class="line"></div><div class="line">public:</div><div class="line">    void _update_op(Op* op,</div><div class="line">                    vector&lt;__le32&gt; &amp;cm,</div><div class="line">                    vector&lt;__le32&gt; &amp;om) &#123;</div><div class="line">        // 根据情况来决定是否需要更新collection id</div><div class="line">        // 或者是object id</div><div class="line">        // 根据op的类型来决定</div><div class="line">        op-&gt;cid = cm[op-&gt;cid];</div><div class="line">        op-&gt;oid = om[op-&gt;oid];</div><div class="line">        op-&gt;dest_oid = om[op-&gt;dest_oid];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // bl里面是一个list</div><div class="line">    // list里面的每个元素都是一个Op结构</div><div class="line">    // 然后再通过_update_op(op_memory, cm, om)</div><div class="line">    // 来进行更新</div><div class="line">    void _update_op_bl(</div><div class="line">        bufferlist&amp; bl,</div><div class="line">        vector&lt;__le32&gt; &amp;cm,</div><div class="line">        vector&lt;__le32&gt; &amp;om)</div><div class="line">    &#123;</div><div class="line">        list&lt;bufferptr&gt; list = bl.buffers();</div><div class="line">        std::list&lt;bufferptr&gt;::iterator p;</div><div class="line"></div><div class="line">        for(p = list.begin(); p != list.end(); ++p) &#123;</div><div class="line">            assert(p-&gt;length() % sizeof(Op) == 0);</div><div class="line">            char* raw_p = p-&gt;c_str();</div><div class="line">            char* raw_end = raw_p + p-&gt;length();</div><div class="line">            while (raw_p &lt; raw_end) &#123;</div><div class="line">                _update_op(reinterpret_cast&lt;Op*&gt;(raw_p), cm, om);</div><div class="line">                raw_p += sizeof(Op);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /// Append the operations of the parameter to this Transaction.</div><div class="line">    // Those operations are removed from the parameter Transaction</div><div class="line">    // 这里更加类似于两个事务的合并，注意：</div><div class="line">    // other.op_bl是深度复制了的。</div><div class="line">    // ohter.data_bl则是没有深度复制</div><div class="line">    // 可能是觉得other还会在别的地方会有用处</div><div class="line">    void append(Transaction&amp; other) &#123;</div><div class="line">        data.ops += other.data.ops;</div><div class="line">        if (other.data.largest_data_len &gt; data.largest_data_len) &#123;</div><div class="line">            data.largest_data_len = other.data.largest_data_len;</div><div class="line">            data.largest_data_off = other.data.largest_data_off;</div><div class="line">            data.largest_data_off_in_data_bl = data_bl.length() + other.data.largest_data_off_in_data_bl;</div><div class="line">        &#125;</div><div class="line">        data.fadvise_flags |= other.data.fadvise_flags;</div><div class="line">        // splice的含义是把另外一个list放到on_applied/on_commit后面</div><div class="line">        // splice函数是说</div><div class="line">        // splice(Iterator position, list&lt;T&gt; l);</div><div class="line">        // 把l插入到postion位置。然后l里面的元素被move过去。所以</div><div class="line">        // 操作之后l变成空的了。</div><div class="line">        on_applied.splice(on_applied.end(), other.on_applied);</div><div class="line">        on_commit.splice(on_commit.end(), other.on_commit);</div><div class="line">        on_applied_sync.splice(on_applied_sync.end(), other.on_applied_sync);</div><div class="line"></div><div class="line">        //append coll_index &amp; object_index</div><div class="line">        // cm新生成，后面用来更新</div><div class="line">        vector&lt;__le32&gt; cm(other.coll_index.size());</div><div class="line">        map&lt;coll_t, __le32&gt;::iterator coll_index_p;</div><div class="line">        for (coll_index_p = other.coll_index.begin();</div><div class="line">             coll_index_p != other.coll_index.end();</div><div class="line">             ++coll_index_p) &#123;</div><div class="line">            // 这里更新cm这个vector</div><div class="line">            cm[coll_index_p-&gt;second] = _get_coll_id(coll_index_p-&gt;first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        vector&lt;__le32&gt; om(other.object_index.size());</div><div class="line">        map&lt;ghobject_t, __le32&gt;::iterator object_index_p;</div><div class="line">        for (object_index_p = other.object_index.begin();</div><div class="line">             object_index_p != other.object_index.end();</div><div class="line">             ++object_index_p) &#123;</div><div class="line">            // 这里更新的是om这个vector</div><div class="line">            om[object_index_p-&gt;second] = _get_object_id(object_index_p-&gt;first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // other.op_bl在这里是不能被更改的</div><div class="line">        //the other.op_bl SHOULD NOT be changes during append operation,</div><div class="line">        // 这里使用了另外一个bufferlist来处理这种case. </div><div class="line">        //we use additional bufferlist to avoid this problem</div><div class="line">        // 申请一个新的内存，长度为other.op_bl.length()</div><div class="line">        bufferptr other_op_bl_ptr(other.op_bl.length());</div><div class="line">        // 这里把other.op_bl里面的内容复制到新申请的内存里</div><div class="line">        other.op_bl.copy(0, other.op_bl.length(), other_op_bl_ptr.c_str());</div><div class="line">        bufferlist other_op_bl;</div><div class="line">        // 注意这里是一个list&lt;bufferptr&gt;, 所以这里用append把前面的内存缓冲区放进去</div><div class="line">        other_op_bl.append(other_op_bl_ptr);</div><div class="line"></div><div class="line">        //update other_op_bl with cm &amp; om</div><div class="line">        //When the other is appended to current transaction, all coll_index and</div><div class="line">        //object_index in other.op_buffer should be updated by new index of the</div><div class="line">        //combined transaction</div><div class="line">        // 然后利用list&lt;buffer&gt;把当前的transaction更新一把</div><div class="line">        _update_op_bl(other_op_bl, cm, om);</div><div class="line"></div><div class="line">        //append op_bl</div><div class="line">        // 把other的op_bl list append到op_bl里面</div><div class="line">        // 完成两个事务的op的合并</div><div class="line">        op_bl.append(other_op_bl);</div><div class="line">        //append data_bl</div><div class="line">        // data bl也是需要合并</div><div class="line">        data_bl.append(other.data_bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Inquires about the Transaction as a whole. */</div><div class="line"></div><div class="line">    /// How big is the encoded Transaction buffer?</div><div class="line">    // 得到整个事务的长度</div><div class="line">    // 感觉这里不应该老是去计算</div><div class="line">    // 最好是有办法去优化</div><div class="line">    uint64_t get_encoded_bytes() &#123;</div><div class="line">        //layout: data_bl + op_bl + coll_index + object_index + data</div><div class="line"></div><div class="line">        // coll_index size, object_index size and sizeof(transaction_data)</div><div class="line">        // all here, so they may be computed at compile-time</div><div class="line">        size_t final_size = sizeof(__u32) * 2 + sizeof(data);</div><div class="line"></div><div class="line">        // coll_index second and object_index second</div><div class="line">        final_size += (coll_index.size() + object_index.size()) * sizeof(__le32);</div><div class="line"></div><div class="line">        // coll_index first</div><div class="line">        for (auto p = coll_index.begin(); p != coll_index.end(); ++p) &#123;</div><div class="line">            final_size += p-&gt;first.encoded_size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // object_index first</div><div class="line">        for (auto p = object_index.begin(); p != object_index.end(); ++p) &#123;</div><div class="line">            final_size += p-&gt;first.encoded_size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return data_bl.length() +</div><div class="line">               op_bl.length() +</div><div class="line">               final_size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint64_t get_num_bytes() &#123;</div><div class="line">        return get_encoded_bytes();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Size of largest data buffer to the "write" operation encountered so far</div><div class="line">    uint32_t get_data_length() &#123;</div><div class="line">        return data.largest_data_len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// offset within the encoded buffer to the start of the largest data buffer that's encoded</div><div class="line">    uint32_t get_data_offset()</div><div class="line">    &#123;</div><div class="line">        if (data.largest_data_off_in_data_bl) &#123;</div><div class="line">            return data.largest_data_off_in_data_bl +</div><div class="line">                   sizeof(__u8) +      // encode struct_v</div><div class="line">                   sizeof(__u8) +      // encode compat_v</div><div class="line">                   sizeof(__u32) +     // encode len</div><div class="line">                   sizeof(__u32);      // data_bl len</div><div class="line">        &#125;</div><div class="line">        return 0;  // none</div><div class="line">    &#125;</div><div class="line">    /// offset of buffer as aligned to destination within object.</div><div class="line">    int get_data_alignment()</div><div class="line">    &#123;</div><div class="line">        if (!data.largest_data_len)</div><div class="line">            return 0;</div><div class="line">        return (0 - get_data_offset()) &amp; ~CEPH_PAGE_MASK;</div><div class="line">    &#125;</div><div class="line">    /// Is the Transaction empty (no operations)</div><div class="line">    bool empty()</div><div class="line">    &#123;</div><div class="line">        // data里面的ops就是用来计数ops操作的数目</div><div class="line">        return !data.ops;</div><div class="line">    &#125;</div><div class="line">    /// Number of operations in the transation</div><div class="line">    int get_num_ops()</div><div class="line">    &#123;</div><div class="line">        return data.ops;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * iterator</div><div class="line">     *</div><div class="line">     * Helper object to parse Transactions.</div><div class="line">     *</div><div class="line">     * ObjectStore instances use this object to step down the encoded</div><div class="line">     * buffer decoding operation codes and parameters as we go.</div><div class="line">     *</div><div class="line">     */</div><div class="line">    class iterator</div><div class="line">    &#123;</div><div class="line">        Transaction *t;</div><div class="line"></div><div class="line">        uint64_t ops;</div><div class="line">        char* op_buffer_p;</div><div class="line"></div><div class="line">        bufferlist::const_iterator data_bl_p;</div><div class="line"></div><div class="line">    public:</div><div class="line">        vector&lt;coll_t&gt; colls;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line"></div><div class="line">    private:</div><div class="line">        explicit iterator(Transaction *t)</div><div class="line">            : t(t),</div><div class="line">              data_bl_p(t-&gt;data_bl.cbegin()),</div><div class="line">              colls(t-&gt;coll_index.size()),</div><div class="line">              objects(t-&gt;object_index.size())</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            ops = t-&gt;data.ops;</div><div class="line">            op_buffer_p = t-&gt;op_bl.get_contiguous(0, t-&gt;data.ops * sizeof(Op));</div><div class="line"></div><div class="line">            map&lt;coll_t, __le32&gt;::iterator coll_index_p;</div><div class="line">            for (coll_index_p = t-&gt;coll_index.begin();</div><div class="line">                 coll_index_p != t-&gt;coll_index.end();</div><div class="line">                 ++coll_index_p) &#123;</div><div class="line">                colls[coll_index_p-&gt;second] = coll_index_p-&gt;first;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            map&lt;ghobject_t, __le32&gt;::iterator object_index_p;</div><div class="line">            for (object_index_p = t-&gt;object_index.begin();</div><div class="line">                 object_index_p != t-&gt;object_index.end();</div><div class="line">                 ++object_index_p) &#123;</div><div class="line">                objects[object_index_p-&gt;second] = object_index_p-&gt;first;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        friend class Transaction;</div><div class="line"></div><div class="line">    public:</div><div class="line"></div><div class="line">        bool have_op()</div><div class="line">        &#123;</div><div class="line">            return ops &gt; 0;</div><div class="line">        &#125;</div><div class="line">        Op* decode_op()</div><div class="line">        &#123;</div><div class="line">            assert(ops &gt; 0);</div><div class="line"></div><div class="line">            Op* op = reinterpret_cast&lt;Op*&gt;(op_buffer_p);</div><div class="line">            op_buffer_p += sizeof(Op);</div><div class="line">            ops--;</div><div class="line"></div><div class="line">            return op;</div><div class="line">        &#125;</div><div class="line">        string decode_string()</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            string s;</div><div class="line">            decode(s, data_bl_p);</div><div class="line">            return s;</div><div class="line">        &#125;</div><div class="line">        void decode_bp(bufferptr&amp; bp)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(bp, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_bl(bufferlist&amp; bl)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(bl, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset(map&lt;string,bufferptr&gt;&amp; aset)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(aset, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset(map&lt;string,bufferlist&gt;&amp; aset)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(aset, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset_bl(bufferlist *pbl)</div><div class="line">        &#123;</div><div class="line">            decode_str_str_map_to_bl(data_bl_p, pbl);</div><div class="line">        &#125;</div><div class="line">        void decode_keyset(set&lt;string&gt; &amp;keys)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(keys, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_keyset_bl(bufferlist *pbl)</div><div class="line">        &#123;</div><div class="line">            decode_str_set_to_bl(data_bl_p, pbl);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        const ghobject_t &amp;get_oid(__le32 oid_id)</div><div class="line">        &#123;</div><div class="line">            assert(oid_id &lt; objects.size());</div><div class="line">            return objects[oid_id];</div><div class="line">        &#125;</div><div class="line">        const coll_t &amp;get_cid(__le32 cid_id)</div><div class="line">        &#123;</div><div class="line">            assert(cid_id &lt; colls.size());</div><div class="line">            return colls[cid_id];</div><div class="line">        &#125;</div><div class="line">        uint32_t get_fadvise_flags() const</div><div class="line">        &#123;</div><div class="line">            return t-&gt;get_fadvise_flags();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    iterator begin()</div><div class="line">    &#123;</div><div class="line">        return iterator(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    void _build_actions_from_tbl();</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * Helper functions to encode the various mutation elements of a</div><div class="line">     * transaction.  These are 1:1 with the operation codes (see</div><div class="line">     * enumeration above).  These routines ensure that the</div><div class="line">     * encoder/creator of a transaction gets the right data in the</div><div class="line">     * right place. Sadly, there's no corresponding version nor any</div><div class="line">     * form of seat belts for the decoder.</div><div class="line">     */</div><div class="line">    Op* _get_next_op()</div><div class="line">    &#123;</div><div class="line">        if (op_ptr.length() == 0 || op_ptr.offset() &gt;= op_ptr.length()) &#123;</div><div class="line">            op_ptr = bufferptr(sizeof(Op) * OPS_PER_PTR);</div><div class="line">        &#125;</div><div class="line">        bufferptr ptr(op_ptr, 0, sizeof(Op));</div><div class="line">        op_bl.append(ptr);</div><div class="line"></div><div class="line">        op_ptr.set_offset(op_ptr.offset() + sizeof(Op));</div><div class="line"></div><div class="line">        char* p = ptr.c_str();</div><div class="line">        memset(p, 0, sizeof(Op));</div><div class="line">        return reinterpret_cast&lt;Op*&gt;(p);</div><div class="line">    &#125;</div><div class="line">    __le32 _get_coll_id(const coll_t&amp; coll)</div><div class="line">    &#123;</div><div class="line">        map&lt;coll_t, __le32&gt;::iterator c = coll_index.find(coll);</div><div class="line">        if (c != coll_index.end())</div><div class="line">            return c-&gt;second;</div><div class="line"></div><div class="line">        __le32 index_id = coll_id++;</div><div class="line">        coll_index[coll] = index_id;</div><div class="line">        return index_id;</div><div class="line">    &#125;</div><div class="line">    __le32 _get_object_id(const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        map&lt;ghobject_t, __le32&gt;::iterator o = object_index.find(oid);</div><div class="line">        if (o != object_index.end())</div><div class="line">            return o-&gt;second;</div><div class="line"></div><div class="line">        __le32 index_id = object_id++;</div><div class="line">        object_index[oid] = index_id;</div><div class="line">        return index_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">    // 接下来这里生成各种事务的参数，指令</div><div class="line">    /// noop. 'nuf said</div><div class="line">    void nop()</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_NOP;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * touch</div><div class="line">     *</div><div class="line">     * Ensure the existance of an object in a collection. Create an</div><div class="line">     * empty object if necessary</div><div class="line">     */</div><div class="line">    void touch(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TOUCH;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Write data to an offset within an object. If the object is too</div><div class="line">     * small, it is expanded as needed.  It is possible to specify an</div><div class="line">     * offset beyond the current end of an object and it will be</div><div class="line">     * expanded as needed. Simple implementations of ObjectStore will</div><div class="line">     * just zero the data between the old end of the object and the</div><div class="line">     * newly provided data. More sophisticated implementations of</div><div class="line">     * ObjectStore will omit the untouched data and store it as a</div><div class="line">     * "hole" in the file.</div><div class="line">     *</div><div class="line">     * Note that a 0-length write does not affect the size of the object.</div><div class="line">     */</div><div class="line">    void write(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off, uint64_t len,</div><div class="line">               const bufferlist&amp; write_data, uint32_t flags = 0)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        uint32_t orig_len = data_bl.length();</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_WRITE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        _op-&gt;len = len;</div><div class="line">        encode(write_data, data_bl);</div><div class="line"></div><div class="line">        assert(len == write_data.length());</div><div class="line">        data.fadvise_flags = data.fadvise_flags | flags;</div><div class="line">        if (write_data.length() &gt; data.largest_data_len) &#123;</div><div class="line">            data.largest_data_len = write_data.length();</div><div class="line">            data.largest_data_off = off;</div><div class="line">            data.largest_data_off_in_data_bl = orig_len + sizeof(__u32);  // we are about to</div><div class="line">        &#125;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * zero out the indicated byte range within an object. Some</div><div class="line">     * ObjectStore instances may optimize this to release the</div><div class="line">     * underlying storage space.</div><div class="line">     *</div><div class="line">     * If the zero range extends beyond the end of the object, the object</div><div class="line">     * size is extended, just as if we were writing a buffer full of zeros.</div><div class="line">     * EXCEPT if the length is 0, in which case (just like a 0-length write)</div><div class="line">     * we do not adjust the object size.</div><div class="line">     */</div><div class="line">    void zero(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off, uint64_t len)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_ZERO;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        _op-&gt;len = len;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Discard all data in the object beyond the specified size.</div><div class="line">    void truncate(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TRUNCATE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Remove an object. All four parts of the object are removed.</div><div class="line">    void remove(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_REMOVE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set an xattr of an object</div><div class="line">    void setattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const char* name, bufferlist&amp; val)</div><div class="line">    &#123;</div><div class="line">        string n(name);</div><div class="line">        setattr(cid, oid, n, val);</div><div class="line">    &#125;</div><div class="line">    /// Set an xattr of an object</div><div class="line">    void setattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const string&amp; s, bufferlist&amp; val)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(s, data_bl);</div><div class="line">        encode(val, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set multiple xattrs of an object</div><div class="line">    void setattrs(const coll_t&amp; cid, const ghobject_t&amp; oid, const map&lt;string,bufferptr&gt;&amp; attrset)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set multiple xattrs of an object</div><div class="line">    void setattrs(const coll_t&amp; cid, const ghobject_t&amp; oid, const map&lt;string,bufferlist&gt;&amp; attrset)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// remove an xattr from an object</div><div class="line">    void rmattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const char *name)</div><div class="line">    &#123;</div><div class="line">        string n(name);</div><div class="line">        rmattr(cid, oid, n);</div><div class="line">    &#125;</div><div class="line">    /// remove an xattr from an object</div><div class="line">    void rmattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const string&amp; s)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMATTR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(s, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// remove all xattrs from an object</div><div class="line">    void rmattrs(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Clone an object into another object.</div><div class="line">     *</div><div class="line">     * Low-cost (e.g., O(1)) cloning (if supported) is best, but</div><div class="line">     * fallback to an O(n) copy is allowed.  All four parts of the</div><div class="line">     * object are cloned (data, xattrs, omap header, omap</div><div class="line">     * entries).</div><div class="line">     *</div><div class="line">     * The destination named object may already exist, in</div><div class="line">     * which case its previous contents are discarded.</div><div class="line">     */</div><div class="line">    void clone(const coll_t&amp; cid, const ghobject_t&amp; oid,</div><div class="line">               const ghobject_t&amp; noid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_CLONE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(noid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Clone a byte range from one object to another.</div><div class="line">     *</div><div class="line">     * The data portion of the destination object receives a copy of a</div><div class="line">     * portion of the data from the source object. None of the other</div><div class="line">     * three parts of an object is copied from the source.</div><div class="line">     *</div><div class="line">     * The destination object size may be extended to the dstoff + len.</div><div class="line">     *</div><div class="line">     * The source range *must* overlap with the source object data. If it does</div><div class="line">     * not the result is undefined.</div><div class="line">     */</div><div class="line">    void clone_range(const coll_t&amp; cid, const ghobject_t&amp; oid,</div><div class="line">                     const ghobject_t&amp; noid,</div><div class="line">                     uint64_t srcoff, uint64_t srclen, uint64_t dstoff)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_CLONERANGE2;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(noid);</div><div class="line">        _op-&gt;off = srcoff;</div><div class="line">        _op-&gt;len = srclen;</div><div class="line">        _op-&gt;dest_off = dstoff;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Create the collection</div><div class="line">    void create_collection(const coll_t&amp; cid, int bits)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_MKCOLL;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Give the collection a hint.</div><div class="line">     *</div><div class="line">     * @param cid  - collection id.</div><div class="line">     * @param type - hint type.</div><div class="line">     * @param hint - the hint payload, which contains the customized</div><div class="line">     *               data along with the hint type.</div><div class="line">     */</div><div class="line">    void collection_hint(const coll_t&amp; cid, uint32_t type, const bufferlist&amp; hint)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_HINT;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;hint_type = type;</div><div class="line">        encode(hint, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// remove the collection, the collection must be empty</div><div class="line">    void remove_collection(const coll_t&amp; cid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMCOLL;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void collection_move(const coll_t&amp; cid, const coll_t &amp;oldcid, const ghobject_t&amp; oid)</div><div class="line">    __attribute__ ((deprecated))</div><div class="line">    &#123;</div><div class="line">        // NOTE: we encode this as a fixed combo of ADD + REMOVE.  they</div><div class="line">        // always appear together, so this is effectively a single MOVE.</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_ADD;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(cid);</div><div class="line">        data.ops++;</div><div class="line"></div><div class="line">        _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_REMOVE;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void collection_move_rename(const coll_t&amp; oldcid, const ghobject_t&amp; oldoid,</div><div class="line">                                const coll_t &amp;cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_MOVE_RENAME;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oldoid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void try_rename(const coll_t &amp;cid, const ghobject_t&amp; oldoid,</div><div class="line">                    const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TRY_RENAME;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oldoid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove omap from oid</div><div class="line">    void omap_clear(</div><div class="line">        const coll_t &amp;cid,           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid  ///&lt; [in] Object from which to remove omap</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_CLEAR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set keys on oid omap.  Replaces duplicate keys.</div><div class="line">    void omap_setkeys(</div><div class="line">        const coll_t&amp; cid,                           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,                ///&lt; [in] Object to update</div><div class="line">        const map&lt;string, bufferlist&gt; &amp;attrset ///&lt; [in] Replacement keys and values</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set keys on an oid omap (bufferlist variant).</div><div class="line">    void omap_setkeys(</div><div class="line">        const coll_t &amp;cid,                           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,                ///&lt; [in] Object to update</div><div class="line">        const bufferlist &amp;attrset_bl          ///&lt; [in] Replacement keys and values</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data_bl.append(attrset_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove keys from oid omap</div><div class="line">    void omap_rmkeys(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap</div><div class="line">        const set&lt;string&gt; &amp;keys ///&lt; [in] Keys to clear</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(keys, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove keys from oid omap</div><div class="line">    void omap_rmkeys(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap</div><div class="line">        const bufferlist &amp;keys_bl ///&lt; [in] Keys to clear</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data_bl.append(keys_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove key range from oid omap</div><div class="line">    void omap_rmkeyrange(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap keys</div><div class="line">        const string&amp; first,    ///&lt; [in] first key in range</div><div class="line">        const string&amp; last      ///&lt; [in] first key past range, range is [first,last)</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYRANGE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(first, data_bl);</div><div class="line">        encode(last, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set omap header</div><div class="line">    void omap_setheader(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object</div><div class="line">        const bufferlist &amp;bl    ///&lt; [in] Header value</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETHEADER;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(bl, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Split collection based on given prefixes, objects matching the specified bits/rem are</div><div class="line">    /// moved to the new collection</div><div class="line">    void split_collection(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        uint32_t bits,</div><div class="line">        uint32_t rem,</div><div class="line">        const coll_t &amp;destination)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SPLIT_COLLECTION2;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(destination);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        _op-&gt;split_rem = rem;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void collection_set_bits(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        int bits)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_SET_BITS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set allocation hint for an object</div><div class="line">    /// make 0 values(expected_object_size, expected_write_size) noops for all implementations</div><div class="line">    void set_alloc_hint(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        const ghobject_t &amp;oid,</div><div class="line">        uint64_t expected_object_size,</div><div class="line">        uint64_t expected_write_size,</div><div class="line">        uint32_t flags</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETALLOCHINT;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;expected_object_size = expected_object_size;</div><div class="line">        _op-&gt;expected_write_size = expected_write_size;</div><div class="line">        _op-&gt;alloc_hint_flags = flags;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="事务入队"><a href="#事务入队" class="headerlink" title="事务入队"></a>事务入队</h1><figure class="highlight"><table><tr><td class="code"><pre><div class="line">int queue_transaction(CollectionHandle&amp; ch,</div><div class="line">                      Transaction&amp;&amp; t,</div><div class="line">                      TrackedOpRef op = TrackedOpRef(),</div><div class="line">                      ThreadPool::TPHandle *handle = NULL)</div><div class="line">&#123;</div><div class="line">    vector&lt;Transaction&gt; tls;</div><div class="line">    tls.push_back(std::move(t));</div><div class="line">    return queue_transactions(ch, tls, op, handle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual int queue_transactions(</div><div class="line">    CollectionHandle&amp; ch, vector&lt;Transaction&gt;&amp; tls,</div><div class="line">    TrackedOpRef op = TrackedOpRef(),</div><div class="line">    ThreadPool::TPHandle *handle = NULL) = 0;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// versioning</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">get_db_statistics</span><span class="params">(Formatter *f)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">generate_db_histogram</span><span class="params">(Formatter *f)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flush_cache</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dump_perf_counters</span><span class="params">(Formatter *f)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">get_type</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// mgmt</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">test_mount_in_use</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mount</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">umount</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fsck</span><span class="params">(<span class="keyword">bool</span> deep)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">repair</span><span class="params">(<span class="keyword">bool</span> deep)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_cache_shards</span><span class="params">(<span class="keyword">unsigned</span> num)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns 0 if the hobject is valid, -error otherwise</div><div class="line">     *</div><div class="line">     * Errors:</div><div class="line">     * -ENAMETOOLONG: locator/namespace/name too large</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">validate_hobject_key</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hobject_t</span> &amp;obj)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_max_attr_name_length</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mkfs</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// wipe</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mkjournal</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// journal only</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">needs_journal</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//&lt; requires a journal</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">wants_journal</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//&lt; prefers a journal</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">allows_journal</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//&lt; allows a journal</span></div><div class="line"></div><div class="line">    <span class="comment">/// enumerate hardware devices (by 'devname', e.g., 'sda' as in /sys/block/sda)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_devices</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *devls)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// true if a txn is readable immediately after it is queued.</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_sync_onreadable</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is_rotational</div><div class="line">     *</div><div class="line">     * Check whether store is backed by a rotational (HDD) or non-rotational</div><div class="line">     * (SSD) device.</div><div class="line">     *</div><div class="line">     * This must be usable *before* the store is mounted.</div><div class="line">     *</div><div class="line">     * @return true for HDD, false for SSD</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_rotational</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is_journal_rotational</div><div class="line">     *</div><div class="line">     * Check whether journal is backed by a rotational (HDD) or non-rotational</div><div class="line">     * (SSD) device.</div><div class="line">     *</div><div class="line">     *</div><div class="line">     * @return true for HDD, false for SSD</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_journal_rotational</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">get_default_device_class</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> is_rotational() ? <span class="string">"hdd"</span> : <span class="string">"ssd"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_sort_nibblewise</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// assume a backend cannot, unless it says otherwise</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">statfs</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">store_statfs_t</span> *buf)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collect_metadata</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; *pm)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * write_meta - write a simple configuration key out-of-band</div><div class="line">     *</div><div class="line">     * Write a simple key/value pair for basic store configuration</div><div class="line">     * (e.g., a uuid or magic number) to an unopened/unmounted store.</div><div class="line">     * The default implementation writes this to a plaintext file in the</div><div class="line">     * path.</div><div class="line">     *</div><div class="line">     * A newline is appended.</div><div class="line">     *</div><div class="line">     * @param key key name (e.g., "fsid")</div><div class="line">     * @param value value (e.g., a uuid rendered as a string)</div><div class="line">     * @returns 0 for success, or an error code</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">write_meta</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; value);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * read_meta - read a simple configuration key out-of-band</div><div class="line">     *</div><div class="line">     * Read a simple key value to an unopened/mounted store.</div><div class="line">     *</div><div class="line">     * Trailing whitespace is stripped off.</div><div class="line">     *</div><div class="line">     * @param key key name</div><div class="line">     * @param value pointer to value string</div><div class="line">     * @returns 0 for success, or an error code</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">read_meta</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key,</span></span></div><div class="line">                          <span class="built_in">std</span>::<span class="built_in">string</span> *value);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get ideal max value for collection_list()</div><div class="line">     *</div><div class="line">     * default to some arbitrary values; the implementation will override.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_ideal_list_max</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">64</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get a collection handle</div><div class="line">     *</div><div class="line">     * Provide a trivial handle as a default to avoid converting legacy</div><div class="line">     * implementations.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> CollectionHandle <span class="title">open_collection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span> &amp;cid)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get a collection handle for a soon-to-be-created collection</div><div class="line">     *</div><div class="line">     * This handle must be used by queue_transaction that includes a</div><div class="line">     * create_collection call in order to become valid.  It will become the</div><div class="line">     * reference to the created collection.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> CollectionHandle <span class="title">create_new_collection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span> &amp;cid)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Synchronous read operations</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * exists -- Test for existance of object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @returns true if object exists, false otherwise</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * set_collection_opts -- set pool options for a collectioninformation for an object</div><div class="line">     *</div><div class="line">     * @param cid collection</div><div class="line">     * @param opts new collection options</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">set_collection_opts</span><span class="params">(</span></span></div><div class="line">        CollectionHandle&amp; c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">pool_opts_t</span>&amp; opts) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * stat -- get information for an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param st output information for the object</div><div class="line">     * @param allow_eio if false, assert on -EIO operation failure</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">stat</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">struct</span> stat *st,</div><div class="line">        <span class="keyword">bool</span> allow_eio = <span class="literal">false</span>) = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * read -- read a byte range of data from an object</div><div class="line">     *</div><div class="line">     * Note: if reading from an offset past the end of the object, we</div><div class="line">     * return 0 (not, say, -EINVAL).</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param offset location offset of first byte to be read</div><div class="line">     * @param len number of bytes to be read</div><div class="line">     * @param bl output bufferlist</div><div class="line">     * @param op_flags is CEPH_OSD_OP_FLAG_*</div><div class="line">     * @returns number of bytes read on success, or negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">uint64_t</span> offset,</div><div class="line">        <span class="keyword">size_t</span> len,</div><div class="line">        bufferlist&amp; bl,</div><div class="line">        <span class="keyword">uint32_t</span> op_flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * fiemap -- get extent map of data of an object</div><div class="line">     *</div><div class="line">     * Returns an encoded map of the extents of an object's data portion</div><div class="line">     * (map&lt;offset,size&gt;).</div><div class="line">     *</div><div class="line">     * A non-enlightened implementation is free to return the extent (offset, len)</div><div class="line">     * as the sole extent.</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param offset location offset of first byte to be read</div><div class="line">     * @param len number of bytes to be read</div><div class="line">     * @param bl output bufferlist for extent map information.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fiemap</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                       <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> len, bufferlist&amp; bl) = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fiemap</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                       <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> len, <span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt;&amp; destmap) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattr -- get an xattr of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param name name of attr to read</div><div class="line">     * @param value place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getattr</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name, bufferptr&amp; value) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattr -- get an xattr of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param name name of attr to read</div><div class="line">     * @param value place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getattr</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">const</span> <span class="built_in">string</span>&amp; name, bufferlist&amp; value)</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        <span class="keyword">int</span> r = getattr(c, oid, name.c_str(), bp);</div><div class="line">        value.push_back(bp);</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattrs -- get all of the xattrs of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param aset place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getattrs</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                         <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt;&amp; aset) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattrs -- get all of the xattrs of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param aset place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getattrs</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                 <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferlist&gt;&amp; aset)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt; bmap;</div><div class="line">        <span class="keyword">int</span> r = getattrs(c, oid, bmap);</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt;::iterator i = bmap.begin();</div><div class="line">             i != bmap.end();</div><div class="line">             ++i) &#123;</div><div class="line">            aset[i-&gt;first].append(i-&gt;second);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// collections</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * list_collections -- get all of the collections known to this ObjectStore</div><div class="line">     *</div><div class="line">     * @param ls list of the collections in sorted order.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">list_collections</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">coll_t</span>&gt;&amp; ls)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * does a collection exist?</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @returns true if it exists, false otherwise</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">collection_exists</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span>&amp; c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is a collection empty?</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @param empty true if the specified collection is empty, false otherwise</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_empty</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">bool</span> *empty)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * return the number of significant bits of the coll_t::pgid.</div><div class="line">     *</div><div class="line">     * This should return what the last create_collection or split_collection</div><div class="line">     * set.  A legacy backend may return -EAGAIN if the value is unavailable</div><div class="line">     * (because we upgraded from an older version, e.g., FileStore).</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_bits</span><span class="params">(CollectionHandle&amp; c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * list contents of a collection that fall in the range [start, end) and no more than a specified many result</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @param start list object that sort &gt;= this value</div><div class="line">     * @param end list objects that sort &lt; this value</div><div class="line">     * @param max return no more than this many results</div><div class="line">     * @param seq return no objects with snap &lt; seq</div><div class="line">     * @param ls [out] result</div><div class="line">     * @param next [out] next item sorts &gt;= this value</div><div class="line">     * @return zero on success, or negative error</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_list</span><span class="params">(CollectionHandle &amp;c,</span></span></div><div class="line">                                <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; start, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; end,</div><div class="line">                                <span class="keyword">int</span> max,</div><div class="line">                                <span class="built_in">vector</span>&lt;<span class="keyword">ghobject_t</span>&gt; *ls, <span class="keyword">ghobject_t</span> *next) = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/// OMAP</span></div><div class="line">    <span class="comment">/// Get omap contents</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        bufferlist *header,      <span class="comment">///&lt; [out] omap header</span></div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, bufferlist&gt; *out <span class="comment">/// &lt; [out] Key to value map</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get omap header</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_header</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        bufferlist *header,      <span class="comment">///&lt; [out] omap header</span></div><div class="line">        <span class="keyword">bool</span> allow_eio = <span class="literal">false</span> <span class="comment">///&lt; [in] don't assert on eio</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get keys defined on oid</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_keys</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,   <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid, <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *keys      <span class="comment">///&lt; [out] Keys defined on oid</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get key values</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_values</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,         <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,       <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &amp;keys,     <span class="comment">///&lt; [in] Keys to get</span></div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, bufferlist&gt; *out <span class="comment">///&lt; [out] Returned keys and values</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Filters keys into out which are defined on oid</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_check_keys</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &amp;keys, <span class="comment">///&lt; [in] Keys to check</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *out         <span class="comment">///&lt; [out] Subset of keys defined on oid</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns an object map iterator</div><div class="line">     *</div><div class="line">     * Warning!  The returned iterator is an implicit lock on filestore</div><div class="line">     * operations in c.  Do not use filestore methods on c while the returned</div><div class="line">     * iterator is live.  (Filling in a transaction is no problem).</div><div class="line">     *</div><div class="line">     * @return iterator, null on error</div><div class="line">     */</div><div class="line">    <span class="keyword">virtual</span> ObjectMap::<span class="function">ObjectMapIterator <span class="title">get_omap_iterator</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,   <span class="comment">///&lt; [in] collection</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid  <span class="comment">///&lt; [in] object</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">flush_journal</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">dump_journal</span><span class="params">(ostream&amp; out)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">snapshot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set and get internal fsid for this instance. No external data is modified</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_fsid</span><span class="params">(uuid_d u)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uuid_d <span class="title">get_fsid</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * Estimates additional disk space used by the specified amount of objects and caused by file allocation granularity and metadata store</div><div class="line">    * - num objects - total (including witeouts) object count to measure used space for.</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint64_t <span class="title">estimate_objects_overhead</span><span class="params">(<span class="keyword">uint64_t</span> num_objects)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">compact</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">has_builtin_csum</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/5.ObjectStore的接口" data-title="1.4 ObjectStore的接口" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/11.type_traits" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/20/stl/11.type_traits/" class="article-date">
  	<time datetime="2018-07-20T05:30:32.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/20/stl/11.type_traits/">1.10 type traits</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// integral_constant</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="number">_</span>Tp <span class="number">__</span>v&gt;</div><div class="line"><span class="keyword">struct</span> integral_constant &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="number">_</span>Tp                  value = <span class="number">__</span>v; <span class="comment">// 注意static</span></div><div class="line">    <span class="keyword">typedef</span> <span class="number">_</span>Tp                           value_type;</div><div class="line">    <span class="keyword">typedef</span> integral_constant&lt;<span class="number">_</span>Tp, <span class="number">__</span>v&gt;   type;</div><div class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 类静态成员的再次声明，在c++11中，constexpr应该不是需要重新声明定义的。</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="number">_</span>Tp <span class="number">__</span>v&gt;</div><div class="line"><span class="keyword">constexpr</span> <span class="number">_</span>Tp integral_constant&lt;<span class="number">_</span>Tp, <span class="number">__</span>v&gt;::value;</div></pre></td></tr></table></figure>
<h1 id="不一样的operator"><a href="#不一样的operator" class="headerlink" title="不一样的operator"></a>不一样的operator</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value_type()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">100</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"operator()()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">101</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">  A a;</div><div class="line">  <span class="keyword">int</span> t = a; <span class="comment">// 这里调用operator int() const</span></div><div class="line">  a();       <span class="comment">// 这里是做为仿函数被调用</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以这里需要区别<code>operator type() const</code>和<code>type operator() const</code>。<br>一个是用来进行类型转换，一个是用来模拟仿函数。</p>
<h1 id="integral-constant-的作用"><a href="#integral-constant-的作用" class="headerlink" title="integral_constant 的作用"></a>integral_constant 的作用</h1><h2 id="字面常量参数"><a href="#字面常量参数" class="headerlink" title="字面常量参数"></a>字面常量参数</h2><p>在模板编程中，如果一个模板参数不是<code>typename T</code>而是<code>int N</code>或者<code>bool cond</code>这种参数，那么这个参数必须是字面常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> cond, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> A ...</div><div class="line"></div><div class="line"><span class="comment">// 使用时</span></div><div class="line">A&lt;<span class="literal">true</span>, <span class="keyword">int</span>&gt; aInt;</div><div class="line">A&lt;<span class="literal">false</span>, <span class="keyword">int</span>&gt; bInt;</div></pre></td></tr></table></figure>
<p>而不能用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> cond = <span class="literal">false</span>;</div><div class="line">A&lt;cond, <span class="keyword">int</span>&gt; aInt; <span class="comment">// 这里编译出错</span></div></pre></td></tr></table></figure>
<p>当然也可以使用<code>c++11</code>引入的字面常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> cond = <span class="literal">true</span>;</div><div class="line">A&lt;cond, <span class="keyword">int</span>&gt; aInt; <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<p><strong>总结</strong><br>使用模板的时候，编译器的输入就是文本里面的字符，是不能存在任何存储空间的变量。因此，模板参数只能使用类型或者是字面常量。</p>
<p>也就是说，模板元编程的输入有两种：</p>
<ul>
<li>类型，比如int, double, float, 以及自定义类型。</li>
<li>类型常量，比如自定义了某种类型，然后定义了这种类型的字面常量。或者内建类型的字段常量，比如<code>false/true</code>或者<code>constexpr bool cond = true</code>这里cond也是属生字面常量。</li>
</ul>
<h2 id="如何通用地定义字面常量"><a href="#如何通用地定义字面常量" class="headerlink" title="如何通用地定义字面常量"></a>如何通用地定义字面常量</h2><p>由前面的模板元输入的可以知道，类型有两种，一种是<code>类型</code>一种是<code>类型对应的常量</code>。那么是否有方法可以把两者统一起来?</p>
<p>首先看一下支持<code>类型</code>和<code>常量</code>的写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> X&gt;</div><div class="line">SomeCode</div><div class="line"></div><div class="line"><span class="comment">// use</span></div><div class="line">SomeCode&lt;someType, <span class="literal">true</span>&gt; x;</div></pre></td></tr></table></figure>
<p>在第二个参数这里就必须显示地指定类型。那么如何后面要支持其他通用的类型的常量，比如<code>int</code>类型的常量，又需要把同样的代码抄一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">temlate&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> X&gt;</div><div class="line">SomeCode</div><div class="line"><span class="comment">// use</span></div><div class="line">SomeCode&lt;someType, <span class="number">10</span>&gt; x;</div></pre></td></tr></table></figure>
<p>这样就显示得一点也不泛型了。那么最好的办法是利用一个抽象把<code>类型字面常量</code>表示起来。这就是<code>integral_constant</code>。</p>
<p>首先看一下如何定义<code>bool</code>类型的常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt; true_type</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type</div></pre></td></tr></table></figure>
<p>那么，后面在定义模板的时候，就可以只写一份了。为了区分，这里把<code>SomeCode</code>改成<code>SomeClass</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ConstValue&gt;</div><div class="line"><span class="keyword">class</span> SomeClass &#123;</div><div class="line">    <span class="comment">// 引用到给定的常量的类型</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ConstValue::type const_type;</div><div class="line">    <span class="comment">// 引用到给定的常量的值</span></div><div class="line">    <span class="keyword">constexpr</span> const_type value = ConstValue::value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是使用方式上就会有点麻烦了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 原来是SomeCode&lt;int, false&gt; aInst;</span></div><div class="line"><span class="comment">// 现在是</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt; true_type</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type</div><div class="line">SomeClass&lt;<span class="keyword">int</span>, false_type&gt; aInst;</div><div class="line"></div><div class="line"><span class="comment">// 原来是SomeCode&lt;int, 10&gt; bInst;</span></div><div class="line"><span class="comment">// 现在是如下</span></div><div class="line">SomeClass&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>,<span class="number">10</span>&gt;&gt; bInst;</div></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>从抽象上来说，代码的实现方直接把<code>类型字面常量</code>抽象成一个模板，并且<code>type/value</code>可以引用到相应的类型和值。</li>
<li>服务方<code>SomeClass</code>里面在引用到类型和字面常量值的时候，就通过<code>::type/::value</code>来引用。</li>
<li>客户端原本使用<code>SomeCode&lt;int, 10&gt;</code>的地方要修改成<code>SomeClass&lt;int, std::integral_constant&lt;int,10&gt;&gt;</code>。</li>
</ul>
<h1 id="定义一些常量"><a href="#定义一些常量" class="headerlink" title="定义一些常量"></a>定义一些常量</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// The type used as a compile-time boolean with true value.</span></div><div class="line"><span class="keyword">typedef</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt; true_type;</div><div class="line"></div><div class="line"><span class="comment">// The type used as a compile-time boolean with false value.</span></div><div class="line"><span class="keyword">typedef</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> <span class="number">__</span>v&gt;</div><div class="line">  <span class="keyword">using</span> <span class="number">__b</span>ool_constant = integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>v&gt;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> <span class="number">__</span>v&gt;</div><div class="line">  <span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>v&gt;;</div></pre></td></tr></table></figure>
<h1 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Primary template.</span></div><div class="line"><span class="comment">/// Define a member typedef @c type to one of two argument types.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> <span class="number">_</span>Cond, <span class="keyword">typename</span> <span class="number">_</span>Iftrue, <span class="keyword">typename</span> <span class="number">_</span>Iffalse&gt;</div><div class="line">  <span class="keyword">struct</span> conditional</div><div class="line">  &#123; <span class="keyword">typedef</span> <span class="number">_</span>Iftrue type; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Partial specialization for false.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Iftrue, <span class="keyword">typename</span> <span class="number">_</span>Iffalse&gt;</div><div class="line">  <span class="keyword">struct</span> conditional&lt;<span class="literal">false</span>, <span class="number">_</span>Iftrue, <span class="number">_</span>Iffalse&gt;</div><div class="line">  &#123; <span class="keyword">typedef</span> <span class="number">_</span>Iffalse type; &#125;;</div></pre></td></tr></table></figure>
<p>这个和前面自己实现的<code>if/else</code>模板元本质上没有太大区别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> cond, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF&lt;<span class="literal">false</span>, If, Then&gt; &#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了命名不一样，代码本质是一样的。</p>
<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p><code>c++11</code>开始支持模板可变参数，使用方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//前向声明</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="keyword">struct</span> Sum;</div><div class="line"></div><div class="line"><span class="comment">//基本定义</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> First, <span class="keyword">typename</span>... Rest&gt;</div><div class="line"><span class="keyword">struct</span> Sum&lt;First, Rest...&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Sum&lt;First&gt;::value + Sum&lt;Rest...&gt;::value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归终止</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Last&gt;</div><div class="line"><span class="keyword">struct</span> Sum&lt;Last&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="keyword">sizeof</span> (Last);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Sum&lt;<span class="keyword">float</span>, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="类型的or操作"><a href="#类型的or操作" class="headerlink" title="类型的or操作"></a>类型的or操作</h1><p>有了这个小程序，那么再看接下来的一个<code>stl</code>里面的模板就容易了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>or_;</div><div class="line"></div><div class="line"><span class="comment">// 当没有给定参数的时候，返回false_type</span></div><div class="line"><span class="comment">// 本质上就是一个false_type</span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>or_&lt;&gt;</div><div class="line">  : <span class="keyword">public</span> false_type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 如果只有一个参数B1, 那么返回值就是</span></div><div class="line"><span class="comment">// B1</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>or_&lt;<span class="number">_B</span>1&gt;</div><div class="line">  : <span class="keyword">public</span> <span class="number">_B</span>1</div><div class="line">  &#123; &#125;;</div><div class="line"><span class="comment">// 如果有两个参数的时候，那么就根据第一个参数的</span></div><div class="line"><span class="comment">// 值来决定返回的类型</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1, <span class="keyword">typename</span> <span class="number">_B</span>2&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>or_&lt;<span class="number">_B</span>1, <span class="number">_B</span>2&gt;</div><div class="line">  : <span class="keyword">public</span> conditional&lt;<span class="number">_B</span>1::value, <span class="number">_B</span>1, <span class="number">_B</span>2&gt;::type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 实际上等价的效果就是</span></div><div class="line"><span class="comment">// B1::value | B2::value .. | Bn::value</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1, <span class="keyword">typename</span> <span class="number">_B</span>2, <span class="keyword">typename</span> <span class="number">_B</span>3, <span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>or_&lt;<span class="number">_B</span>1, <span class="number">_B</span>2, <span class="number">_B</span>3, <span class="number">_B</span>n...&gt;</div><div class="line">  : <span class="keyword">public</span> conditional&lt;<span class="number">_B</span>1::value, <span class="number">_B</span>1, <span class="number">__</span>or_&lt;<span class="number">_B</span>2, <span class="number">_B</span>3, <span class="number">_B</span>n...&gt;&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这个<code>__or_</code>的作用就是取出所有给定类型的第一个<code>true/非零类型</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; int_10_cont;</div><div class="line">    <span class="keyword">auto</span> x = <span class="built_in">std</span>::<span class="number">__</span>or_&lt;int_10_cont, <span class="built_in">std</span>::true_type,<span class="built_in">std</span>::false_type,<span class="built_in">std</span>::true_type&gt;::value;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>关于<code>or</code>类型操作的总结就是，符合<code>C/C++</code>里面的<code>a||b</code>操作，如果<code>a</code>非0，那么就可以直接返回<code>a</code>了。</p>
<h1 id="类型的and操作"><a href="#类型的and操作" class="headerlink" title="类型的and操作"></a>类型的and操作</h1><p>了解了前面的<code>if/or</code>操作，可以利用<code>conditional</code>来操作了。只不过需要注意的是<code>conditional</code>的使用。在<code>a||b</code>的时候，使用是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (A::value) &#123;</div><div class="line">    <span class="keyword">return</span> A::type;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> B::type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么<code>and</code>操作的时候就需要这样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (A::value) &#123;</div><div class="line">    <span class="keyword">return</span> B::type;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> A::type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是正式的写法是<code>conditional&lt;A::value, B::type, A::type&gt;</code>。</p>
<p>所以原本一个非常简单的类型操作函数，需要写成如下格式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>and_;</div><div class="line"></div><div class="line"><span class="comment">// 注意空的时候，返回true_type</span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>and_&lt;&gt;</div><div class="line">  : <span class="keyword">public</span> true_type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 只有一个类型的时候，直接返回这个类型</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>and_&lt;<span class="number">_B</span>1&gt;</div><div class="line">  : <span class="keyword">public</span> <span class="number">_B</span>1</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 如同前面说的if的结构</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1, <span class="keyword">typename</span> <span class="number">_B</span>2&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>and_&lt;<span class="number">_B</span>1, <span class="number">_B</span>2&gt;</div><div class="line">  : <span class="keyword">public</span> conditional&lt;<span class="number">_B</span>1::value, <span class="number">_B</span>2, <span class="number">_B</span>1&gt;::type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_B</span>1, <span class="keyword">typename</span> <span class="number">_B</span>2, <span class="keyword">typename</span> <span class="number">_B</span>3, <span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>and_&lt;<span class="number">_B</span>1, <span class="number">_B</span>2, <span class="number">_B</span>3, <span class="number">_B</span>n...&gt;</div><div class="line">  : <span class="keyword">public</span> conditional&lt;<span class="number">_B</span>1::value, <span class="number">__</span>and_&lt;<span class="number">_B</span>2, <span class="number">_B</span>3, <span class="number">_B</span>n...&gt;, <span class="number">_B</span>1&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里需要特别注意一下。后面这段语句类似于下面这个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function">type <span class="title">and</span><span class="params">(B1, B2, B3, ... Bn)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (B1::value) &#123;</div><div class="line">        <span class="keyword">return</span> and(B2, B3, Bn...);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> B1::type;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="not类型"><a href="#not类型" class="headerlink" title="not类型"></a>not类型</h1><p>对于一个<code>字面常量类型</code>也可以进行<code>not</code>操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Pp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>not_</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, !<span class="number">_</span>Pp::value&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>可以发现，这里通过<code>!_Pp::value</code>直接转换成了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt; true_type</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type</div></pre></td></tr></table></figure>
<h1 id="交并补"><a href="#交并补" class="headerlink" title="交并补"></a>交并补</h1><p>这里针对类型的列表有如下操作<code>交/并/补</code>，只不过这里补操作只针对有一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">struct</span> conjunction</div><div class="line">  : <span class="number">__</span>and_&lt;<span class="number">_B</span>n...&gt;</div><div class="line">  &#123; &#125;;</div><div class="line">  <span class="comment">// 注意，... _Bn可变参数列表</span></div><div class="line">  <span class="comment">// 都是有::value类型的，</span></div><div class="line">  <span class="comment">// 后面声明了inline变量方便引用</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">struct</span> disjunction</div><div class="line">  : <span class="number">__</span>or_&lt;<span class="number">_B</span>n...&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Pp&gt;</div><div class="line">  <span class="keyword">struct</span> negation</div><div class="line">  : <span class="number">__</span>not_&lt;<span class="number">_</span>Pp&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>由于每个操作，都会返回相应的<code>integral_constant</code>类型，所以操作的结果是都会有<code>::value</code>成员。为了方便引用这些成员，又定义了别名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> conjunction_v</div><div class="line">  = conjunction&lt;<span class="number">_B</span>n...&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... <span class="number">_B</span>n&gt;</div><div class="line">  <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> disjunction_v</div><div class="line">  = disjunction&lt;<span class="number">_B</span>n...&gt;::value;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Pp&gt;</div><div class="line">  <span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> negation_v</div><div class="line">  = negation&lt;<span class="number">_</span>Pp&gt;::value;</div></pre></td></tr></table></figure>
<h1 id="是否有参数"><a href="#是否有参数" class="headerlink" title="是否有参数"></a>是否有参数</h1><p>有时候，需要判断是否有参数。那么写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>success_type</div><div class="line">  &#123; <span class="keyword">typedef</span> <span class="number">_</span>Tp type; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> <span class="number">__f</span>ailure_type</div><div class="line">&#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里定义的两个类型，需要重点看一下相应的这段注释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">  <span class="comment">// For several sfinae-friendly trait implementations we transport both the</span></div><div class="line">  <span class="comment">// result information (as the member type) and the failure information (no</span></div><div class="line">  <span class="comment">// member type). This is very similar to std::enable_if, but we cannot use</span></div><div class="line">  <span class="comment">// them, because we need to derive from them as an implementation detail.</span></div><div class="line"></div><div class="line"><span class="comment">// 对于某些sfinae友好的trait函数而言，返回值有两种，一种是需要返回相应的类型(毕竟是模板元编程，函数的输入与输出都是类型)，另外一种返回值是没有任何类型输出，这个时候就用`__failure_type`，这个与std::enable_if是相似的，但是不能用`enable_if`，因为需要得到实施的具体细节。</span></div></pre></td></tr></table></figure>
<h1 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h1><p>有时候我们想知道一个类型是否是<code>void</code>类型。那么如何判断？这个时候就需要利用偏特化。首先看一下客户端代码是如何使用这个<code>is_void</code>的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_void&lt;<span class="keyword">void</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_void&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么<code>is_void</code>是如何实现的呢？一种比较简单的实现可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_void &#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> is_void &#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，在之前的<code>type_traits</code>里面是定义了各种信息丰富的常量的。这里可以借助于<code>true_type/false_type</code>来定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> remove_cv;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_void_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_void_helper&lt;<span class="keyword">void</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_void</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_void</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_void_helper&lt;<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>当然，这里的实现还是比较细致的，还去除了<code>const void/volatile void</code>等修饰符之后再判断。</p>
<p>如果写成一个函数就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">bool_type <span class="number">__</span>is_void_helper(type) &#123;</div><div class="line">  <span class="keyword">if</span> (type == <span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">return</span> true_type;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> false_type;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">true_type/<span class="function">false_type <span class="title">is_void</span><span class="params">(input_type)</span> </span>&#123;</div><div class="line">  temp_type = remove_cv(input_type);</div><div class="line">  <span class="keyword">return</span> <span class="number">__</span>is_void_helper(temp_type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h2><p>这里需要说明，一种简单的实现是没有必要采用继承来处理的。比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_void &#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> is_void &#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是如果其他类型，比如<code>is_int/is_float</code>等等这样的函数都需要这么定义，就会显得特别的繁琐。每个都需要在里面进行相同的定义，那么一种简单的办法当然是采用C++的继承了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_void : <span class="keyword">public</span> false_type &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> is_void : <span class="keyword">public</span> true_type &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，这里还需要考虑的是，如果有<code>const void/volatile void</code>应该怎么办？这个时候，就需要先通过<code>remove_cv</code>把类型里面的<code>const/volatile</code>去掉。所以这里还需要中间加一层。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_void_helper : <span class="keyword">public</span> false_type &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_void_helper : <span class="keyword">public</span> true_type &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_void : <span class="keyword">public</span> <span class="number">__</span>is_void_helper&lt;<span class="keyword">typename</span> remove_cv&lt;T&gt;::type&gt;::type &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>需要注意，这里继承的是<code>: public __is_void_helper&lt;typename remove_cv&lt;T&gt;::type&gt;::type</code>注意，这里用的是<code>type</code>而不是<code>value_type</code>。这里再回顾一下<code>std::integral_constant</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, T v&gt;</div><div class="line"><span class="keyword">struct</span> integral_constant &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v;</div><div class="line">    <span class="keyword">typedef</span> T value_type;</div><div class="line">    <span class="keyword">typedef</span> integral_constant type; <span class="comment">// 使用注入的类名</span></div><div class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125;</div><div class="line">    <span class="function"><span class="keyword">constexpr</span> value_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// c++14 起</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意这里<code>type</code>与<code>value_type</code>的差别。</p>
<h1 id="is-void的另一种实现"><a href="#is-void的另一种实现" class="headerlink" title="is_void的另一种实现"></a>is_void的另一种实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="keyword">struct</span> is_void : <span class="built_in">std</span>::is_same&lt;<span class="keyword">void</span>, <span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt; &#123;&#125;;</div></pre></td></tr></table></figure>
<h1 id="判断内置类型"><a href="#判断内置类型" class="headerlink" title="判断内置类型"></a>判断内置类型</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">bool</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">char</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">signed</span> <span class="keyword">char</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">wchar_t</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">char16_t</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">char32_t</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">short</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">int</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">long</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="number">__</span>GLIBCXX_TYPE_INT_N_0&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="number">__</span>GLIBCXX_TYPE_INT_N_0&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="number">__</span>GLIBCXX_TYPE_INT_N_1&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="number">__</span>GLIBCXX_TYPE_INT_N_1&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="number">__</span>GLIBCXX_TYPE_INT_N_2&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="number">__</span>GLIBCXX_TYPE_INT_N_2&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="number">__</span>GLIBCXX_TYPE_INT_N_3&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">unsigned</span> <span class="number">__</span>GLIBCXX_TYPE_INT_N_3&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_integral</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_integral</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_integral_helper&lt;<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里的实现方式都是与前面提到的类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> xxx : <span class="keyword">public</span> <span class="number">__</span>xxx_helper&lt;<span class="keyword">typename</span> remove_cv&lt;T&gt;::type&gt;::type &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>基他所有的类型都是通过<code>__is_integral_helper</code>偏特化来实现的。</p>
<p>用同样的方式可以实现<code>is_floating_point</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="number">__</span>is_floating_point_helper</div><div class="line">    : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="number">__</span>is_floating_point_helper&lt;<span class="keyword">float</span>&gt;</div><div class="line">    : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="number">__</span>is_floating_point_helper&lt;<span class="keyword">double</span>&gt;</div><div class="line">    : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="number">__</span>is_floating_point_helper&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;</div><div class="line">    : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__STRICT_ANSI__) &amp;&amp; defined(_GLIBCXX_USE_FLOAT128)</span></div><div class="line">  <span class="keyword">template</span>&lt;&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="number">__</span>is_floating_point_helper&lt;<span class="number">__f</span>loat128&gt;</div><div class="line">    : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">  <span class="comment">/// is_floating_point</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">    <span class="keyword">struct</span> is_floating_point</div><div class="line">    : <span class="keyword">public</span> <span class="number">__</span>is_floating_point_helper&lt;<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">    &#123; &#125;;</div></pre></td></tr></table></figure>
<p>实现思路还是比较清晰的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_floating_helper : <span class="keyword">public</span> <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_floating_helper&lt;<span class="keyword">float</span>&gt; : <span class="keyword">public</span> <span class="built_in">std</span>::true_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_floating_helper&lt;<span class="keyword">double</span>&gt; : <span class="keyword">public</span> <span class="built_in">std</span>::true_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> <span class="number">__</span>is_floating_helper&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; : <span class="keyword">public</span> <span class="built_in">std</span>::true_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_floating : <span class="keyword">public</span> <span class="number">__</span>is_floating_helper&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt;::type</div><div class="line">&#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_floating&lt;<span class="keyword">float</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_floating&lt;<span class="keyword">double</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_floating&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种有趣的实现，也可以从<code>cppreference</code>网站得到。</p>
<p><a href="https://zh.cppreference.com/w/cpp/types/is_floating_point" target="_blank" rel="external">https://zh.cppreference.com/w/cpp/types/is_floating_point</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="keyword">struct</span> is_floating_point</div><div class="line">     : <span class="built_in">std</span>::integral_constant&lt;</div><div class="line">         <span class="keyword">bool</span>,</div><div class="line">         <span class="built_in">std</span>::is_same&lt;<span class="keyword">float</span>, <span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt;::value  ||</div><div class="line">         <span class="built_in">std</span>::is_same&lt;<span class="keyword">double</span>, <span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt;::value  ||</div><div class="line">         <span class="built_in">std</span>::is_same&lt;<span class="keyword">long</span> <span class="keyword">double</span>, <span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt;::value</div><div class="line">     &gt; &#123;&#125;;</div></pre></td></tr></table></figure>
<h1 id="is-array"><a href="#is-array" class="headerlink" title="is_array"></a>is_array</h1><p>判断一个类型是否是数组<code>is_array</code>？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_array</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="number">_</span>Size&gt;</div><div class="line">  <span class="keyword">struct</span> is_array&lt;<span class="number">_</span>Tp[<span class="number">_</span>Size]&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_array&lt;<span class="number">_</span>Tp[]&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div></pre></td></tr></table></figure>
<p>方法也很简单，就是通过偏特化处理<code>T[N]和T[]</code>。</p>
<h1 id="is-pointer"><a href="#is-pointer" class="headerlink" title="is_pointer"></a>is_pointer</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_pointer_helper&lt;<span class="number">_</span>Tp*&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_pointer</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_pointer_helper&lt;<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里的实现依然是采用偏特化来实现的<code>is_pointer</code>。实际上，偷懒一点也可以采用如下实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_pointer : <span class="keyword">public</span> <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_pointer&lt;T*&gt; : <span class="keyword">public</span> <span class="built_in">std</span>::true_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_pointer&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_pointer&lt;<span class="keyword">int</span> <span class="keyword">const</span>*&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并不需要处理<code>const/volatile</code>等情况。但是真正在实现中，依然处理了这种情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keyword">struct</span> is_pointer_helper     : <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keyword">struct</span> is_pointer_helper&lt;T*&gt; : <span class="built_in">std</span>::true_type &#123;&#125;;</div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt; <span class="keyword">struct</span> is_pointer : is_pointer_helper&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_cv&lt;T&gt;::type&gt; &#123;&#125;;</div></pre></td></tr></table></figure>
<h1 id="右引用与右引用"><a href="#右引用与右引用" class="headerlink" title="右引用与右引用"></a>右引用与右引用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// is_lvalue_reference</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_lvalue_reference</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_lvalue_reference&lt;<span class="number">_</span>Tp&amp;&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_rvalue_reference</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_rvalue_reference</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_rvalue_reference&lt;<span class="number">_</span>Tp&amp;&amp;&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里的实现就没有考虑<code>std::remove_cv</code>的情况。所以我觉得前面在查看是否有指针的时候，其实也可以不用<code>remove_cv</code>的。</p>
<h1 id="is-member-object-pointer"><a href="#is-member-object-pointer" class="headerlink" title="is_member_object_pointer"></a>is_member_object_pointer</h1><p>判断一个类型是不是<code>类成员指针</code>。检查<code>T</code>是否为非静态成员对象指针。若<code>T</code>是非静态成员对象指针类型，则提供等于 <code>true</code>的成员常量<code>value</code>。否则，<code>value</code> 等于<code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> is_member_object_pointer : <span class="built_in">std</span>::integral_constant&lt;</div><div class="line">  <span class="keyword">bool</span>,</div><div class="line">  <span class="built_in">std</span>::is_member_pointer&lt;T&gt;::value &amp;&amp;</div><div class="line">  !<span class="built_in">std</span>::is_member_function_pointer&lt;T&gt;::value</div><div class="line">&gt; &#123;&#125;;</div></pre></td></tr></table></figure>
<p>而<code>is_member_pointer</code>则是判断一个类型是否是<code>类成员指针</code>这个指针可能是指向某个成员的指针，也有可能是<strong>类成员函数指针</strong>。</p>
<p><code>is_member_function_pointer</code>而是指一个<code>成员函数指针</code>。</p>
<p>而这里的实现相对要复杂一些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_function;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_object_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 在这里利用偏特化的同时，</span></div><div class="line"><span class="comment">// 去掉了成员函数指针</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="keyword">typename</span> <span class="number">_</span>Cp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_object_pointer_helper&lt;<span class="number">_</span>Tp <span class="number">_</span>Cp::*&gt;</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, !is_function&lt;<span class="number">_</span>Tp&gt;::value&gt; &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_member_object_pointer</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_member_object_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_member_object_pointer_helper&lt;</div><div class="line">		<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div><div class="line"><span class="comment">// 这里没有必要remove_cv的。</span></div></pre></td></tr></table></figure>
<h1 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_function_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="keyword">typename</span> <span class="number">_</span>Cp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_function_pointer_helper&lt;<span class="number">_</span>Tp <span class="number">_</span>Cp::*&gt;</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, is_function&lt;<span class="number">_</span>Tp&gt;::value&gt; &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_member_function_pointer</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_member_function_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_member_function_pointer_helper&lt;</div><div class="line">		<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>成员函数<code>traits</code>的使用方式？在讲使用方式之前，需要先讲一个比较少见的<code>C++</code>的语法。</p>
<p>比如判断一个成员是不是<code>member object pointer</code>需要使用语法<code>int(cls::*)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">class</span> cls &#123;&#125;;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::is_member_object_pointer&lt;<span class="keyword">int</span>(cls::*)&gt;::value</div><div class="line">                     ? <span class="string">"T is member object pointer"</span></div><div class="line">                     : <span class="string">"T is not a member object pointer"</span>) &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">std</span>::is_member_object_pointer&lt;<span class="keyword">int</span>(cls::*)()&gt;::value</div><div class="line">                     ? <span class="string">"T is member object pointer"</span></div><div class="line">                     : <span class="string">"T is not a member object pointer"</span>) &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类成员类型声明"><a href="#类成员类型声明" class="headerlink" title="类成员类型声明"></a>类成员类型声明</h2><p>一般写代码的时候，都是如下方式使用类成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">  <span class="keyword">int</span> a;</div><div class="line">  <span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">  X x;</div><div class="line">  x.a; <span class="comment">// 这里使用a</span></div><div class="line">  x.b; <span class="comment">// 这里使用b</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是有时候可，可能会用一个变量指向<code>a/b</code>。比如使用一个变量<code>obj_ref</code>指向<code>a/b</code>，使用时，就使用<code>x</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">x.*obj_ref = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>这样就可以给<code>a/b</code>进行赋值了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">int</span> a;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of b is "</span>&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// declare pointer to data member</span></div><div class="line">  <span class="keyword">int</span> X::*ptiptr = &amp;X::a;</div><div class="line"></div><div class="line">  <span class="comment">// declare a pointer to member function</span></div><div class="line">  <span class="keyword">void</span> (X::* ptfptr) (<span class="keyword">int</span>) = &amp;X::f;</div><div class="line"></div><div class="line">  <span class="comment">// create an object of class type X</span></div><div class="line">  X xobject;</div><div class="line"></div><div class="line">  <span class="comment">// initialize data member</span></div><div class="line">  xobject.*ptiptr = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of a is "</span> &lt;&lt; xobject.*ptiptr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">  <span class="comment">// call member function</span></div><div class="line">  (xobject.*ptfptr) (<span class="number">20</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li><code>type X::*</code>引用的是成员指针。</li>
<li><code>type X::*(函数参数)</code>引用的是类成员的函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> X::*my_pointer_to_member;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(X::*my_pointer_to_function)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  my_pointer_to_member ptiptr = &amp;X::a;</div><div class="line">  my_pointer_to_function ptfptr = &amp;X::f;</div><div class="line">  X xobject;</div><div class="line">  xobject.*ptiptr = <span class="number">10</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The value of a is "</span> &lt;&lt; xobject.*ptiptr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  (xobject.*ptfptr) (<span class="number">20</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="成员的判断"><a href="#成员的判断" class="headerlink" title="成员的判断"></a>成员的判断</h2><p>成员的判断主要是有两种</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">- is_member_object_pointer</div><div class="line">- is_member_function_pointer</div></pre></td></tr></table></figure>
<p>实际上，也就是用来判断一个给定的类型是不是从属于这两种类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_member_object_pointer&lt;<span class="keyword">int</span>(X::*)&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="comment">// or</span></div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> X::* <span class="keyword">x_class_object_pointer_t</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_member_object_pointer&lt;<span class="keyword">x_class_object_pointer_t</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只是需要注意在声明模板的时候，这里需要用到两个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_function;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_object_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="keyword">typename</span> <span class="number">_</span>Cp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_object_pointer_helper&lt;<span class="number">_</span>Tp <span class="number">_</span>Cp::*&gt;</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, !is_function&lt;<span class="number">_</span>Tp&gt;::value&gt; &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_member_object_pointer</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_member_object_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_member_object_pointer_helper&lt;</div><div class="line">		<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>接下来的<code>is_member_function_pointer</code>就也可以顺理成章写出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_function_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp, <span class="keyword">typename</span> <span class="number">_</span>Cp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_member_function_pointer_helper&lt;<span class="number">_</span>Tp <span class="number">_</span>Cp::*&gt;</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, is_function&lt;<span class="number">_</span>Tp&gt;::value&gt; &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_member_function_pointer</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_member_function_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_member_function_pointer_helper&lt;</div><div class="line">		<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p><strong>总结</strong><br>无论是<code>类内部的成员指针</code>或者是<code>类内部的函数指针</code>，都可以通过<code>Type Class::*</code>这样来进行定义。只不过这个<code>Type</code>如果是<code>int/float/double</code>等类型或自定义类型，那么就是一个成员指针。如果<code>Type</code>是一个函数指针，那么指向的，就是一个<code>类内部函数指针</code>。</p>
<h1 id="编译器支持"><a href="#编译器支持" class="headerlink" title="编译器支持"></a>编译器支持</h1><p>接下来三项，就是需要编译器进行支持的。比如<code>__is_enum/__is_union/__is_class</code>这三个都是需要编译器支持的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// is_enum</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_enum</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_enum(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_union</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_union</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_union(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_class</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_class</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_class(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p><code>is_function</code>则是一个长长的偏特化处理，基本上包含了各种函数的写法。在这里忽略掉。不去展开讲这个宏。</p>
<h1 id="是否是nullptr"><a href="#是否是nullptr" class="headerlink" title="是否是nullptr"></a>是否是nullptr</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_null_pointer_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_null_pointer_helper&lt;<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_null_pointer (LWG 2247).</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_null_pointer</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_null_pointer_helper&lt;<span class="keyword">typename</span> remove_cv&lt;<span class="number">_</span>Tp&gt;::type&gt;::type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// __is_nullptr_t (extension).</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="keyword">__is_nullptr_t</span></div><div class="line">  : <span class="keyword">public</span> is_null_pointer&lt;<span class="number">_</span>Tp&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里的处理非常简单，就是利用<code>nullptr</code>来完成偏特化。</p>
<h1 id="const-amp-volatile"><a href="#const-amp-volatile" class="headerlink" title="const &amp; volatile"></a>const &amp; volatile</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// is_const</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_const</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_const&lt;<span class="number">_</span>Tp <span class="keyword">const</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_volatile</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</div><div class="line">  <span class="keyword">struct</span> is_volatile</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_volatile&lt;<span class="number">_</span>Tp <span class="keyword">volatile</span>&gt;</div><div class="line">  : <span class="keyword">public</span> true_type &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意的是，在<code>C++</code>里面，<code>int const</code>和<code>const int</code>这两者是差不多的作用。</p>
<h1 id="平凡和标准部局"><a href="#平凡和标准部局" class="headerlink" title="平凡和标准部局"></a>平凡和标准部局</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// is_trivial</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_trivial</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_trivial(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// is_trivially_copyable</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_trivially_copyable</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_trivially_copyable(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_standard_layout</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_standard_layout</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_standard_layout(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_pod</span></div><div class="line"><span class="comment">// Could use is_standard_layout &amp;&amp; is_trivial instead of the builtin.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_pod</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">__</span>is_pod(<span class="number">_</span>Tp)&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>
<p>这里在判断的时候，都是通过编译器内置的接口来进行判断。<br>除此之外，还有</p>
<ul>
<li>is_literal_type</li>
<li>is_empty 这个是指类是否是空的，里面啥都没有。</li>
<li>is_polymorphic 是不是多态</li>
<li>is_final 是否是final类，不可继承。</li>
<li>is_abstract 是否是抽象类</li>
</ul>
<h1 id="signed判断"><a href="#signed判断" class="headerlink" title="signed判断"></a>signed判断</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp,</div><div class="line">  <span class="keyword">bool</span> = is_arithmetic&lt;<span class="number">_</span>Tp&gt;::value&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_signed_helper</div><div class="line">  : <span class="keyword">public</span> false_type &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这里利用-1这个转换来进行判断</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> <span class="number">__</span>is_signed_helper&lt;<span class="number">_</span>Tp, <span class="literal">true</span>&gt;</div><div class="line">  : <span class="keyword">public</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="number">_</span>Tp(<span class="number">-1</span>) &lt; <span class="number">_</span>Tp(<span class="number">0</span>)&gt;</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_signed</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_signed</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>is_signed_helper&lt;<span class="number">_</span>Tp&gt;::type</div><div class="line">  &#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">/// is_unsigned</span></div><div class="line"><span class="comment">// 由于前面提供了not操作符</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Tp&gt;</div><div class="line">  <span class="keyword">struct</span> is_unsigned</div><div class="line">  : <span class="keyword">public</span> <span class="number">__</span>and_&lt;is_arithmetic&lt;<span class="number">_</span>Tp&gt;, <span class="number">__</span>not_&lt;is_signed&lt;<span class="number">_</span>Tp&gt;&gt;&gt;</div><div class="line">  &#123; &#125;;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/11.type_traits" data-title="1.10 type traits" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/10.循环展开" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/19/stl/10.循环展开/" class="article-date">
  	<time datetime="2018-07-19T05:30:32.000Z" itemprop="datePublished">2018-07-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/19/stl/10.循环展开/">1.9 循环展开</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="冒泡排序的展开"><a href="#冒泡排序的展开" class="headerlink" title="冒泡排序的展开"></a>冒泡排序的展开</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( n &lt;= <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; ++j)</div><div class="line">        <span class="keyword">if</span>(data[j] &gt; data[j+<span class="number">1</span>])</div><div class="line">            <span class="built_in">std</span>::swap(data[j], data[j+<span class="number">1</span>]);</div><div class="line">    bubbleSort(data, n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> j&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_swap</span><span class="params">(<span class="keyword">int</span> *data)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data[j] &gt; data[j+<span class="number">1</span>])</div><div class="line">        <span class="built_in">std</span>::swap(data[j], data[j+<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能让j==n</span></div><div class="line"><span class="comment">// 因为下一把递归到check_swap的时候</span></div><div class="line"><span class="comment">// j+1就超出n了。</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> n, <span class="keyword">int</span> j&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bloop</span><span class="params">(<span class="keyword">int</span> *data)</span> </span>&#123;</div><div class="line">    check_swap&lt;j&gt;(data);</div><div class="line">    <span class="comment">// 本来递归的写法就应该是</span></div><div class="line">    <span class="comment">// bloop&lt;n, j+1&gt;(data);</span></div><div class="line">    <span class="comment">// 但是这种写法以是无穷展开</span></div><div class="line">    <span class="comment">// 所以需要判断j+1 &gt; n</span></div><div class="line">    <span class="comment">// 如果j+1 &gt; n，然后把第二个模板参数</span></div><div class="line">    <span class="comment">// 设置为-1</span></div><div class="line">    bloop&lt; (j+<span class="number">1</span> &gt;= n? <span class="number">-1</span> : n), (j+<span class="number">1</span> &gt;= n? <span class="number">-1</span> : j+<span class="number">1</span>)&gt;(data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">void</span> bloop&lt;<span class="number">-1</span>,<span class="number">-1</span>&gt;(<span class="keyword">int</span> *data) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsort</span><span class="params">(<span class="keyword">int</span> *data)</span> </span>&#123;</div><div class="line">    <span class="comment">// for (i = 0, i &lt; N-1; check_swap(i,i+1))</span></div><div class="line">    <span class="comment">// 也就是0, N-1</span></div><div class="line">    bloop&lt;N<span class="number">-1</span>, <span class="number">0</span>&gt;(data);</div><div class="line">    bsort&lt;N<span class="number">-1</span>&gt;(data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">void</span> bsort&lt;<span class="number">1</span>&gt;(<span class="keyword">int</span> *data) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">void</span> bsort&lt;<span class="number">0</span>&gt;(<span class="keyword">int</span> *data) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">    bsort&lt;<span class="number">4</span>&gt;(data);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : data) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码膨胀"><a href="#代码膨胀" class="headerlink" title="代码膨胀"></a>代码膨胀</h1><p>为了实现封装细节，那么可以把上面的<code>bloop/check_swap</code>函数都放到一个类里面，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> n&gt;</div><div class="line"><span class="keyword">class</span> IntBubbleSortC &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> j&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> check_swap ....</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> n, <span class="keyword">int</span> j&gt;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> bloop ...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> bsort ...</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">class</span> IntBubbleSortC&lt;<span class="number">0</span>&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>* data)</span> </span>&#123; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</div><div class="line">    IntBubbleSortC&lt;<span class="number">4</span>&gt;::sort(data); <span class="comment">// 如此调用</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这里一定要注意的是类内部的函数定义一定要使用<code>inline</code>函数。否则会导致代码膨胀。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/10.循环展开" data-title="1.9 循环展开" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/9.模板的控制结构" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/9.模板的控制结构/" class="article-date">
  	<time datetime="2018-07-18T05:30:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/9.模板的控制结构/">1.9 模板的控制结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h1><p>这里可以拿最开始的那个例子。也就是通过<code>if/else</code>实现控制语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> value, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF&lt;<span class="literal">false</span>, If, Then&gt; &#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> IfClass &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"IfClass"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ThenClass &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ThenClass"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    IF&lt;<span class="literal">true</span>, IfClass, ThenClass&gt;::type x;</div><div class="line">    x.print();</div><div class="line">    IF&lt;<span class="literal">false</span>, IfClass, ThenClass&gt;::type y;</div><div class="line">    y.print();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">4</span>;</div><div class="line"><span class="keyword">typedef</span> IF&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)==len, <span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">void</span>&gt;::type <span class="keyword">long_long_or_void_t</span>;</div><div class="line"><span class="keyword">typedef</span> IF&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span>)==len, <span class="keyword">long</span>, <span class="keyword">long_long_or_void_t</span>&gt;::type <span class="keyword">long_or_llong_void_t</span>;</div><div class="line"><span class="keyword">typedef</span> IF&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)==len, <span class="keyword">int</span>, <span class="keyword">long_or_llong_void_t</span>&gt;::type <span class="keyword">int_long_llong_void_t</span>;</div><div class="line"><span class="keyword">typedef</span> IF&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span>)==len, <span class="keyword">short</span>, <span class="keyword">int_long_llong_void_t</span>&gt;::type <span class="keyword">short_int_long_llong_void_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">short_int_long_llong_void_t</span> <span class="keyword">int32_t</span>;</div></pre></td></tr></table></figure>
<p>这里实际上就是想定义一个完全<code>4bytes</code>的整数类型。</p>
<p>如果嵌套一点，就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">4</span>;</div><div class="line"><span class="keyword">typedef</span></div><div class="line">    IF_&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span>)==len, <span class="keyword">short</span>,</div><div class="line">    IF_&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)==len, <span class="keyword">int</span>,</div><div class="line">    IF_&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span>)==len, <span class="keyword">long</span>,</div><div class="line">    IF_&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)==len, <span class="keyword">long</span> <span class="keyword">long</span>,</div><div class="line">    <span class="keyword">void</span>&gt;::reType&gt;::reType&gt;::reType&gt;::reType</div><div class="line"><span class="keyword">int32_t</span>; <span class="comment">// 定义一个指定字节数的类型</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<h1 id="WHILE语句"><a href="#WHILE语句" class="headerlink" title="WHILE语句"></a>WHILE语句</h1><p>通过模板，也可以实现一个<code>WHILE</code>语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// cond需要有value/type</span></div><div class="line"><span class="comment">// statement需要有next</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> cond, <span class="keyword">typename</span> statement&gt;</div><div class="line"><span class="keyword">struct</span> WHILE &#123;</div><div class="line">    <span class="keyword">struct</span> STOP &#123;</div><div class="line">        <span class="keyword">typedef</span> statement type;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span></div><div class="line">        IF&lt;cond&lt;statement&gt;::value,</div><div class="line">            WHILE&lt;cond, <span class="keyword">typename</span> statement::next&gt;,</div><div class="line">            STOP</div><div class="line">        &gt;::type::type type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如下面这个程序就是用来求解<code>1^x + 2^x + 3^x + ... + n^x</code>。代码中用<code>e</code>表示<code>x</code>注意，不是自然对数的那个<code>e</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> cond, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF&lt;<span class="literal">false</span>, If, Then&gt; &#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// cond需要有value/type</span></div><div class="line"><span class="comment">// statement需要有next</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> cond, <span class="keyword">typename</span> statement&gt;</div><div class="line"><span class="keyword">struct</span> WHILE &#123;</div><div class="line">    <span class="keyword">struct</span> STOP &#123;</div><div class="line">        <span class="keyword">typedef</span> statement type;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span></div><div class="line">        IF&lt;cond&lt;statement&gt;::value,</div><div class="line">            WHILE&lt;cond, <span class="keyword">typename</span> statement::next&gt;,</div><div class="line">            STOP</div><div class="line">        &gt;::type::type type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 计算 1^e+2^e+...+n^e</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> n, <span class="keyword">int</span> e&gt;</div><div class="line"><span class="keyword">struct</span> sum_pow &#123;</div><div class="line">    <span class="comment">// pow是取x^e</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> x&gt;</div><div class="line">    <span class="keyword">struct</span> <span class="built_in">pow</span> &#123;</div><div class="line">        <span class="comment">// p^q的求解</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">int</span> p, <span class="keyword">int</span> q&gt;</div><div class="line">        <span class="keyword">struct</span> pow_q &#123;</div><div class="line">            <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = p * pow_q&lt;p,q<span class="number">-1</span>&gt;::value;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">int</span> p&gt;</div><div class="line">        <span class="keyword">struct</span> pow_q&lt;p, <span class="number">0</span>&gt; &#123;</div><div class="line">            <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1</span>;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = pow_q&lt;x,e&gt;::value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> statement&gt;</div><div class="line">    <span class="keyword">struct</span> cond &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = statement::iter &lt;= n;</div><div class="line">        <span class="keyword">typedef</span> statement type;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> i, <span class="keyword">int</span> sum&gt;</div><div class="line">    <span class="keyword">struct</span> statement &#123;</div><div class="line">        <span class="keyword">typedef</span> statement&lt;i+<span class="number">1</span>, sum+<span class="built_in">pow</span>&lt;i&gt;::value&gt; next;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> iter = i;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = sum;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = WHILE&lt;cond, statement&lt;<span class="number">1</span>,<span class="number">0</span>&gt;&gt;::type::value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1^2 + 2^2 + ... + 10^2</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum_pow&lt;<span class="number">10</span>,<span class="number">2</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="有趣的编译错误"><a href="#有趣的编译错误" class="headerlink" title="有趣的编译错误"></a>有趣的编译错误</h1><p>这个编译错误是在无意中写错程序发现的。那就是利用<code>WHILE</code>循环来求最大公约数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> cond, <span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF &#123;</div><div class="line">    <span class="keyword">typedef</span> If type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> If, <span class="keyword">typename</span> Then&gt;</div><div class="line"><span class="keyword">struct</span> IF&lt;<span class="literal">false</span>, If, Then&gt; &#123;</div><div class="line">    <span class="keyword">typedef</span> Then type;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// cond has type/value</span></div><div class="line"><span class="comment">// statement has next</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> cond, <span class="keyword">typename</span> statement&gt;</div><div class="line"><span class="keyword">struct</span> WHILE &#123;</div><div class="line">    <span class="keyword">struct</span> STOP &#123;</div><div class="line">        <span class="keyword">typedef</span> statement type;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IF&lt;</div><div class="line">        cond&lt;statement&gt;::value,</div><div class="line">        WHILE&lt;cond, <span class="keyword">typename</span> statement::next&gt;,</div><div class="line">        STOP</div><div class="line">    &gt;::type::type type; </div><div class="line">    <span class="comment">// 注意：这里有两层type,</span></div><div class="line">    <span class="comment">// 第一层是IF&lt;&gt;::type，比如递归结束时，定位到STOP</span></div><div class="line">    <span class="comment">// 第二层是通过剥开STOP，通过STOP拿到最后的类型=STOP::type</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Test GCD while循环</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * a,b</div><div class="line"> * while (b) &#123;</div><div class="line"> *     temp = b;</div><div class="line"> *     b = a % b;</div><div class="line"> *     a = b;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> a, <span class="keyword">int</span> b&gt;</div><div class="line"><span class="keyword">struct</span> GCD &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> statement&gt;</div><div class="line">    <span class="keyword">struct</span> cond &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = statement::i != <span class="number">0</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> x, <span class="keyword">int</span> y&gt;</div><div class="line">    <span class="keyword">struct</span> statement &#123;</div><div class="line">        <span class="keyword">typedef</span> statement&lt;y, x%y&gt; next;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> i = x%y;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = y;</div><div class="line">        <span class="comment">// 注意：i = y; value = x % y会导致编译通不过</span></div><div class="line">        <span class="comment">// 这里一定要注意，就是防止出现</span></div><div class="line">        <span class="comment">// x % 0 的情况</span></div><div class="line">        <span class="comment">// 由于当i = y, value = x % y的时候无法避免这种情况，</span></div><div class="line">        <span class="comment">// 报错信息就特别奇怪</span></div><div class="line">        <span class="comment">// non-type template argument is not a constant expression</span></div><div class="line">        <span class="comment">// division by zero -&gt; 这里才是关键</span></div><div class="line">        <span class="comment">// 如果给的值是statement&lt;10, 5&gt;</span></div><div class="line">        <span class="comment">//   -&gt; typedef statement&lt;5, 0&gt; next;</span></div><div class="line">        <span class="comment">//   -&gt; i = 5,</span></div><div class="line">        <span class="comment">//   -&gt; value = 0;</span></div><div class="line">        <span class="comment">// WHILE里面会发现i = 5，于是还可以展开statement&lt;5,0&gt;</span></div><div class="line">        <span class="comment">//   -&gt; typedef statement&lt;0,5%0&gt; next;  &lt;-- 这里也就报错了。</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>  <span class="keyword">const</span> <span class="keyword">int</span> value = WHILE&lt;cond, statement&lt;a,b&gt;&gt;::type::value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Sum&lt;<span class="number">100</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; PowSum&lt;<span class="number">10</span>,<span class="number">2</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GCD&lt;<span class="number">10</span>, <span class="number">5</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一定要注意程序中的注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注意：i = y; value = x % y会导致编译通不过</span></div><div class="line"><span class="comment">// 这里一定要注意，就是防止出现</span></div><div class="line"><span class="comment">// x % 0 的情况</span></div><div class="line"><span class="comment">// 由于当i = y, value = x % y的时候无法避免这种情况，</span></div><div class="line"><span class="comment">// 报错信息就特别奇怪</span></div><div class="line"><span class="comment">// non-type template argument is not a constant expression</span></div><div class="line"><span class="comment">// division by zero -&gt; 这里才是关键</span></div><div class="line"><span class="comment">// 如果给的值是statement&lt;10, 5&gt;</span></div><div class="line"><span class="comment">//   -&gt; typedef statement&lt;5, 0&gt; next;</span></div><div class="line"><span class="comment">//   -&gt; i = 5,</span></div><div class="line"><span class="comment">//   -&gt; value = 0;</span></div><div class="line"><span class="comment">// WHILE里面会发现i = 5，于是还可以展开statement&lt;5,0&gt;</span></div><div class="line"><span class="comment">//   -&gt; typedef statement&lt;0,5%0&gt; next;  &lt;-- 这里也就报错了。</span></div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/9.模板的控制结构" data-title="1.9 模板的控制结构" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/8.模板元编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/17/stl/8.模板元编程/" class="article-date">
  	<time datetime="2018-07-17T05:30:32.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/17/stl/8.模板元编程/">1.8 模板元编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h1><ul>
<li>编译期数值计算: 求阶乘</li>
<li>类型计算: <code>if/else</code>, <code>is_same_type</code></li>
<li>代码计算</li>
</ul>
<p><img src="/blog/img/compiler.meta.step.png" alt=""></p>
<p>注意元编程的位置。</p>
<h1 id="编程形式"><a href="#编程形式" class="headerlink" title="编程形式"></a>编程形式</h1><p>从编程范型（programming paradigm）上来说，<code>C++模板</code>是函数式编程（functional programming），它的主要特点是：<code>函数调用不产生任何副作用（没有可变的存储）</code>，用<code>递归</code>形式实现<code>循环</code>结构的功能。C++模板的特例化提供了<code>条件判断能力</code>，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。</p>
<p>总结一下就是：</p>
<ul>
<li>不能访问存储变量</li>
<li>偏特化来支持递归</li>
<li>偏特化实现<code>if/else</code>结构</li>
</ul>
<p>从<code>编程形式</code>来看，模板的<code>&lt;&gt;</code>中的模板参数相当于<code>函数调用</code>的<code>输入参数</code>，模板中的<code>typedef</code>或<code>static const</code>或<code>enum</code>定义函数返回值（<code>类型</code>或<code>数值</code>，<code>数值</code>仅支持<code>整型</code>，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。</p>
<p>这里需要解释一下：</p>
<ul>
<li>templnate&lt;.输入类型.&gt;是函数的输入</li>
<li>typedef ….或者static constexpr 整型是函数的返回值</li>
<li>代码计算是通过不同的类型跳转到不同的函数来运行。</li>
</ul>
<p>这里有个非常简单的例子来说明这三点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> i=<span class="number">1</span>&gt;</div><div class="line"><span class="keyword">class</span> someComputing &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">volatile</span> T* retType; <span class="comment">// 类型计算</span></div><div class="line">    <span class="keyword">enum</span> &#123; retValume = i + someComputing&lt;T, i<span class="number">-1</span>&gt;::retValume &#125;; <span class="comment">// 数值计算，递归</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"someComputing: i="</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特例，递归终止条件</span></div><div class="line"><span class="keyword">class</span> someComputing&lt;T, <span class="number">0</span>&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">enum</span> &#123; retValume = <span class="number">0</span> &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> codeComputing &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; T::f(); &#125; <span class="comment">// 根据类型调用函数，代码计算</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    someComputing&lt;<span class="keyword">int</span>&gt;::retType a=<span class="number">0</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 64-bit 程序指针</span></div><div class="line">    <span class="comment">// VS2013 默认最大递归深度500，GCC4.8 默认最大递归深度900（-ftemplate-depth=n）</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; someComputing&lt;<span class="keyword">int</span>, <span class="number">500</span>&gt;::retValume &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 1+2+...+500</span></div><div class="line">    codeComputing&lt;someComputing&lt;<span class="keyword">int</span>, <span class="number">99</span>&gt;&gt;::f();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模板元编程的组织形式</p>
<p><img src="/blog/img/meta.programming.png" alt=""></p>
<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p>前面已经介绍了连续求和的模板。这里写一个编译时计算一个数值是否是质数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> is_prime &#123;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> p, <span class="keyword">int</span> i&gt;</div><div class="line">    <span class="keyword">struct</span> check_prime &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = (p%i) &amp;&amp; check_prime&lt;p, i<span class="number">-1</span>&gt;::value;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> p&gt;</div><div class="line">    <span class="keyword">struct</span> check_prime&lt;p, <span class="number">2</span>&gt; &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = p == <span class="number">2</span> || (p &gt; <span class="number">2</span> &amp;&amp; (p&amp;<span class="number">0x01</span>));</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> p&gt;</div><div class="line">    <span class="keyword">struct</span> check_prime&lt;p, <span class="number">1</span>&gt; &#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = N == <span class="number">2</span> || check_prime&lt;N, N<span class="number">-1</span>&gt;::value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_prime&lt;<span class="number">5</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_prime&lt;<span class="number">7</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; is_prime&lt;<span class="number">2</span>&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是再写一个类，用来连续打印<code>&lt;=N</code>的所有的质数。写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">struct</span> print_prime &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = (N &lt; <span class="number">2</span>) ? <span class="literal">false</span> : is_prime&lt;N&gt;::value;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; N &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        print_prime&lt;N<span class="number">-1</span>&gt;::print();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keyword">struct</span> print_prime&lt;<span class="number">2</span>&gt; &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/8.模板元编程" data-title="1.8 模板元编程" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/7.Cpp11的扩展" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/16/stl/7.Cpp11的扩展/" class="article-date">
  	<time datetime="2018-07-16T05:30:32.000Z" itemprop="datePublished">2018-07-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/16/stl/7.Cpp11的扩展/">1.7 c++11的扩展</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><code>&gt;&gt;</code> 根据上下文自动识别正确语义；</li>
<li>函数模板参数默认值；</li>
<li>变长模板参数（扩展 sizeof…() 获取参数个数）；</li>
<li>模板别名（扩展 using 关键字）；</li>
<li>外部模板实例（拓展 extern 关键字），弃用 export template。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/7.Cpp11的扩展" data-title="1.7 c++11的扩展" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-stl/6.模板的编译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/15/stl/6.模板的编译/" class="article-date">
  	<time datetime="2018-07-15T05:29:32.000Z" itemprop="datePublished">2018-07-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/15/stl/6.模板的编译/">1.6 模板的编译</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>模板的编译一般采用包含编译，(其他比较偏门的会介绍<code>export</code>啥的)，<code>export</code>已经被废止了，所以不再去研究。</p>
<p>正确的做法是:</p>
<ul>
<li>模板的实现都放到<code>.h</code>也就是头文件里面</li>
<li>使用的时候直接包含头文件</li>
</ul>
<p>在链接阶段，如果是因为模板生成的代码，比如类定义或者函数义有多份，那么会自动去重。</p>
<h1 id="嵌套类型依赖"><a href="#嵌套类型依赖" class="headerlink" title="嵌套类型依赖"></a>嵌套类型依赖</h1><p>假设想使用<code>T</code>类里面的<code>iterator</code>，如果代码写做如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> T&amp; container)</span></span></div><div class="line">&#123;</div><div class="line">    T::const_iterator * x;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于编译器并不清楚<code>const_iterator</code>是一个类型，还是静态变量，大多数情况下会认为是一个<code>静态变量</code>。但是，这里实际上是一个类型，所以这里会编译报错。</p>
<p>那么正确的写法应该是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> T&amp; container)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typename</span> T::const_iterator *x;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，在嵌套类型依赖的时候，需要明确的指出<code>typename</code>这个类型。</p>
<h2 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h2><p>只有2个地方是不需要在嵌套依赖的时候来指明<code>typename</code>的，那么就是声明继承的时候。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">class Derived: public Base&lt;T&gt;::Nested // 1. 这里不需要</div><div class="line">&#123;</div><div class="line">　public:</div><div class="line">　　explicit Derived(int x)</div><div class="line">　　: Base&lt;T&gt;::Nested(x) //  2. 这里也不需要</div><div class="line">　　&#123;</div><div class="line">　　　typename Base&lt;T&gt;::Nested temp; //nested dependent type, need typename</div><div class="line">　　&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>比如，这里<code>Nested</code>就是<code>Base&lt;T&gt;</code>里面的一个类型。实际上，这里也很明显，那就是继承肯定是继承于类型，而不是一个静态变量。</p>
<h1 id="类中的模板函数"><a href="#类中的模板函数" class="headerlink" title="类中的模板函数"></a>类中的模板函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> aTMP&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T reType;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global f()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Base &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N = <span class="number">99</span>&gt;  <span class="comment">// 这里需要声明模板函数</span></div><div class="line">    <span class="keyword">void</span> f() &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"member f(): "</span> &lt;&lt; N &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><p>this 用于指定查找基类中的成员</p>
<ul>
<li>（当基类是依赖模板参数的类模板实例时，由于实例化总是推迟，这时不依赖模板参数的名字不在基类中查找，文献[1]第 166 页）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> aTMP&#123;</div><div class="line"><span class="keyword">public</span>: <span class="keyword">typedef</span> <span class="keyword">const</span> T reType;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"global f()\n"</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Base &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">int</span> N = <span class="number">99</span>&gt;</div><div class="line">    <span class="keyword">void</span> f() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"member f(): "</span> &lt;&lt; N &lt;&lt; <span class="string">'\n'</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base&lt;T&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typename</span> T::reType m; <span class="comment">// typename 不能省略</span></div><div class="line">    Derived(<span class="keyword">typename</span> T::reType a) : m(a) &#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">df1</span><span class="params">()</span> </span>&#123; f(); &#125;                       <span class="comment">// 调用全局 f()，而非想象中的基类 f()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">df2</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="function"><span class="keyword">template</span> <span class="title">f</span><span class="params">()</span></span>; &#125;        <span class="comment">// 基类 f&lt;99&gt;()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">df3</span><span class="params">()</span> </span>&#123; Base&lt;T&gt;::<span class="keyword">template</span> f&lt;<span class="number">22</span>&gt;(); &#125; <span class="comment">// 强制基类 f&lt;22&gt;()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">df4</span><span class="params">()</span> </span>&#123; ::f(); &#125;                     <span class="comment">// 强制全局 f()</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    Derived&lt;aTMP&lt;<span class="keyword">int</span>&gt;&gt; a(<span class="number">10</span>);</div><div class="line">    a.df1(); a.df2(); a.df3(); a.df4();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get(); <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/6.模板的编译" data-title="1.6 模板的编译" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>