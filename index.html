<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些有意思的事。">
<meta property="og:type" content="website">
<meta property="og:title" content="缘生故如幻">
<meta property="og:url" content="https://jiyou.github.io/blog/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="记录一些有意思的事。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘生故如幻">
<meta name="twitter:description" content="记录一些有意思的事。">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-mit.6.828/jos-lab3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/28/mit.6.828/jos-lab3/" class="article-date">
  	<time datetime="2018-04-28T02:28:32.000Z" itemprop="datePublished">2018-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/28/mit.6.828/jos-lab3/">MIT 6.828 Lab3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">athena% <span class="built_in">cd</span> ~/6.828/lab</div><div class="line">athena% add git</div><div class="line">athena% git commit -am <span class="string">'changes to lab2 after handin'</span></div><div class="line">Created commit 734fab7: changes to lab2 after handin</div><div class="line"> 4 files changed, 42 insertions(+), 9 deletions(-)</div><div class="line">athena% git pull</div><div class="line">Already up-to-date.</div><div class="line">athena% git checkout -b lab3 origin/lab3</div><div class="line">Branch lab3 <span class="built_in">set</span> up to track remote branch refs/remotes/origin/lab3.</div><div class="line">Switched to a new branch <span class="string">"lab3"</span></div><div class="line">athena% git merge lab2</div><div class="line">Merge made by recursive.</div><div class="line"> kern/pmap.c |   42 +++++++++++++++++++</div><div class="line"> 1 files changed, 42 insertions(+), 0 deletions(-)</div><div class="line">athena%</div></pre></td></tr></table></figure>
<h1 id="增加的文件"><a href="#增加的文件" class="headerlink" title="增加的文件"></a>增加的文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"></div><div class="line">inc/    env.h    Public definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        trap.h    Public definitions <span class="keyword">for</span> <span class="built_in">trap</span> handling</div><div class="line">        syscall.h    Public definitions <span class="keyword">for</span> system calls from user environments to the kernel</div><div class="line">        lib.h    Public definitions <span class="keyword">for</span> the user-mode support library</div><div class="line">kern/    env.h    Kernel-private definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        env.c    Kernel code implementing user-mode environments</div><div class="line">        trap.h    Kernel-private <span class="built_in">trap</span> handling definitions</div><div class="line">        trap.c    Trap handling code</div><div class="line">        trapentry.S    Assembly-language <span class="built_in">trap</span> handler entry-points</div><div class="line">        syscall.h    Kernel-private definitions <span class="keyword">for</span> system call handling</div><div class="line">        syscall.c    System call implementation code</div><div class="line">lib/    Makefrag    Makefile fragment to build user-mode library, obj/lib/libjos.a</div><div class="line">        entry.S    Assembly-language entry-point <span class="keyword">for</span> user environments</div><div class="line">        libmain.c    User-mode library setup code called from entry.S</div><div class="line">        syscall.c    User-mode system call stub <span class="built_in">functions</span></div><div class="line">        console.c    User-mode implementations of putchar and getchar, providing console I/O</div><div class="line">        exit.c    User-mode implementation of <span class="built_in">exit</span></div><div class="line">        panic.c    User-mode implementation of panic</div><div class="line">user/    *    Various <span class="built_in">test</span> programs to check kernel lab 3 code</div></pre></td></tr></table></figure>
<p>这里面就是lab3新增加的文件。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>JOS里面是把进程叫做<code>env</code>。定义是在<code>inc/env.h</code>。内核是用这个数据结构来管理用户的进程。</p>
<p>进程的结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env &#123;</div><div class="line">    struct Trapframe env_tf;    // Saved registers</div><div class="line">    struct Env *env_link;        // Next free Env</div><div class="line">    envid_t env_id;            // Unique environment identifier</div><div class="line">    envid_t env_parent_id;        // env_id of this env&apos;s parent</div><div class="line">    enum EnvType env_type;        // Indicates special system environments</div><div class="line">    unsigned env_status;        // Status of the environment</div><div class="line">    uint32_t env_runs;        // Number of times environment has run</div><div class="line"></div><div class="line">    // Address space</div><div class="line">    pde_t *env_pgdir;        // Kernel virtual address of page dir</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后详细介绍了每个字段。</p>
<p><strong>env_tf</strong><br>This structure, defined in inc/trap.h, holds the saved register values for the environment while that environment is not running: i.e., when the kernel or a different environment is running. The kernel saves these when switching from user to kernel mode, so that the environment can later be resumed where it left off.</p>
<p><strong>env_link</strong><br>This is a link to the next Env on the env_free_list. env_free_list points to the first free environment on the list.</p>
<p><strong>env_id</strong><br>The kernel stores here a value that uniquely identifiers the environment currently using this Env structure (i.e., using this particular slot in the envs array). After a user environment terminates, the kernel may re-allocate the same Env structure to a different environment - but the new environment will have a different env_id from the old one even though the new environment is re-using the same slot in the envs array.</p>
<p><strong>env_parent_id</strong><br>The kernel stores here the env_id of the environment that created this environment. In this way the environments can form a “family tree,” which will be useful for making security decisions about which environments are allowed to do what to whom.</p>
<p><strong>env_type</strong><br>This is used to distinguish special environments. For most environments, it will be ENV_TYPE_USER. We’ll introduce a few more types for special system service environments in later labs.</p>
<p><strong>env_status</strong><br>This variable holds one of the following values:</p>
<p><strong>ENV_FREE</strong><br>Indicates that the Env structure is inactive, and therefore on the<br>env_free_list.</p>
<p><strong>ENV_RUNNABLE</strong><br>Indicates that the Env structure represents an environment that is waiting to run on the processor.</p>
<p><strong>ENV_RUNNING</strong><br>Indicates that the Env structure represents the currently running environment.</p>
<p><strong>ENV_NOT_RUNNABLE</strong><br>Indicates that the Env structure represents a currently active environment, but it is not currently ready to run: for example, because it is waiting for an interprocess communication (IPC) from another environment.</p>
<p><strong>ENV_DYING</strong><br>Indicates that the Env structure represents a zombie environment. A zombie environment will be freed the next time it traps to the kernel. We will not use this flag until Lab 4.</p>
<p><strong>env_pgdir</strong><br>This variable holds the kernel virtual address of this environment’s page directory.</p>
<p>这个结构体是由一个链表来管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env *envs = NULL;        // All environments</div><div class="line">struct Env *curenv = NULL;        // The current env</div><div class="line">static struct Env *env_free_list;    // Free environment list</div></pre></td></tr></table></figure>
<h1 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exercise 1. Modify mem_init() in kern/pmap.c to allocate and map the envs array. This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.</div><div class="line"></div><div class="line">You should run your code and make sure check_kern_pgdir() succeeds.</div></pre></td></tr></table></figure>
<p>这里其实就是两个要求。一个是在内核内存区域分配一段区域来保存这个结构体。<br>另外就是把这个结构体映射到UENVS这个区域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</div><div class="line">// LAB 3: Your code here.</div><div class="line">n = sizeof(struct Env) * NENV;</div><div class="line">envs = (struct Env*) boot_alloc(n);</div><div class="line">memset(envs, 0, n);</div><div class="line"></div><div class="line">...</div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</div><div class="line">// (ie. perm = PTE_U | PTE_P).</div><div class="line">// Permissions:</div><div class="line">//    - the new image at UENVS  -- kernel R, user R</div><div class="line">//    - envs itself -- kernel RW, user NONE</div><div class="line">// LAB 3: Your code here.</div><div class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure>
<p>只需要认真读一注释就可以写出来。没有什么难度。</p>
<h1 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h1><p>配置运行环境。这里讲了一些有意思的用法。考虑这种情况。比如内核里面需要包含一个独立的程序。但是内核本身就是一个大的程序。那么如何把这个小程序放到内核里面去。</p>
<p>比如<code>obj/user/</code>这里生成一堆小程序。那么如何把这些程序放到内核程序里面？<br>实际上这些处理技巧在<code>kern/Makefrag</code>里面。</p>
<p>首先是定义需要生成的<code>binary</code>的文件列表</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Binary program images to embed within the kernel.</span></div><div class="line"><span class="comment"># Binary files for LAB3</span></div><div class="line">KERN_BINFILES :=    user/hello \</div><div class="line">            user/buggyhello \</div><div class="line">            user/buggyhello2 \</div><div class="line">            user/evilhello \</div><div class="line">            user/testbss \</div><div class="line">            user/divzero \</div><div class="line">            user/breakpoint \</div><div class="line">            user/softint \</div><div class="line">            user/badsegment \</div><div class="line">            user/faultread \</div><div class="line">            user/faultreadkernel \</div><div class="line">            user/faultwrite \</div><div class="line">            user/faultwritekernel</div><div class="line"></div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.c, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_SRCFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.S, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst $(OBJDIR)</span>/lib/%, <span class="variable">$(OBJDIR)</span>/kern/%, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line"></div><div class="line">KERN_BINFILES := <span class="variable">$(patsubst %, $(OBJDIR)</span>/%, <span class="variable">$(KERN_BINFILES)</span>)</div></pre></td></tr></table></figure>
<p>通过如下这种方式把<code>binary</code>放到kernel中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># How to build the kernel itself</div><div class="line">$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \</div><div class="line">      $(OBJDIR)/.vars.KERN_LDFLAGS</div><div class="line">    @echo + ld $@</div><div class="line">    $(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES)</div><div class="line">    $(V)$(OBJDUMP) -S $@ &gt; $@.asm</div><div class="line">    $(V)$(NM) -n $@ &gt; $@.sym</div></pre></td></tr></table></figure>
<p>注意后面<code>-b</code>这个参数就是把后面的文件直接加载到kernel里面。由于我们现在没有文件系统，内核就把用户程序一股脑链接到自己身上，在以后有了文件系统就不需要了。但是它给了我们一个便利，我们现在可以直接在内存上运行它。</p>
<p>可执行程序现在是加载到kernel的镜像里面了。可是如果想运行的时候，又如何定位到这些程序呢？</p>
<p>这个时候如果去看<code>obj/kern/kernel.sym</code>，就会发现这里面定义了很多变量。<code>gcc</code>生成的<code>.sym</code>文件里面包含的就是编译器生成的变量表，左边是虚拟地址，右边就是对应的变量。</p>
<p>链接命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo @ld -o obj/kern/kernel \</div><div class="line">    -m elf_i386 \</div><div class="line">    -T kern/kernel.ld \</div><div class="line">    -nostdlib \</div><div class="line">        obj/kern/entry.o \</div><div class="line">        obj/kern/entrypgdir.o \</div><div class="line">        obj/kern/init.o \</div><div class="line">        obj/kern/console.o \</div><div class="line">        obj/kern/monitor.o \</div><div class="line">        obj/kern/pmap.o \</div><div class="line">        obj/kern/env.o \</div><div class="line">        obj/kern/kclock.o \</div><div class="line">        obj/kern/printf.o \</div><div class="line">        obj/kern/trap.o \</div><div class="line">        obj/kern/trapentry.o \</div><div class="line">        obj/kern/syscall.o \</div><div class="line">        obj/kern/kdebug.o  \</div><div class="line">        obj/kern/printfmt.o  \</div><div class="line">        obj/kern/readline.o  \</div><div class="line">        obj/kern/string.o \</div><div class="line">        /usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a \</div><div class="line">    -b binary  \</div><div class="line">        obj/user/hello  \</div><div class="line">        obj/user/buggyhello \</div><div class="line">        obj/user/buggyhello2  \</div><div class="line">        obj/user/evilhello  \</div><div class="line">        obj/user/testbss  \</div><div class="line">        obj/user/divzero  \</div><div class="line">        obj/user/breakpoint \</div><div class="line">        obj/user/softint \</div><div class="line">        obj/user/badsegment \</div><div class="line">        obj/user/faultread \</div><div class="line">        obj/user/faultreadkernel \</div><div class="line">        obj/user/faultwrite \</div><div class="line">        obj/user/faultwritekernel</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f011b356 D _binary_obj_user_hello_start</div><div class="line">f0122b88 D _binary_obj_user_buggyhello_start</div><div class="line">f0122b88 D _binary_obj_user_hello_end</div><div class="line">f012a3bf D _binary_obj_user_buggyhello2_start</div><div class="line">f012a3bf D _binary_obj_user_buggyhello_end</div><div class="line">f0131c11 D _binary_obj_user_buggyhello2_end</div><div class="line">f0131c11 D _binary_obj_user_evilhello_start</div><div class="line">f0139447 D _binary_obj_user_evilhello_end</div><div class="line">f0139447 D _binary_obj_user_testbss_start</div><div class="line">f0140c94 D _binary_obj_user_divzero_start</div><div class="line">f0140c94 D _binary_obj_user_testbss_end</div><div class="line">f01484dd D _binary_obj_user_breakpoint_start</div><div class="line">f01484dd D _binary_obj_user_divzero_end</div><div class="line">f014fd14 D _binary_obj_user_breakpoint_end</div><div class="line">f014fd14 D _binary_obj_user_softint_start</div><div class="line">f0157548 D _binary_obj_user_badsegment_start</div><div class="line">f0157548 D _binary_obj_user_softint_end</div><div class="line">f015ed7f D _binary_obj_user_badsegment_end</div><div class="line">f015ed7f D _binary_obj_user_faultread_start</div><div class="line">f01665b5 D _binary_obj_user_faultread_end</div><div class="line">f01665b5 D _binary_obj_user_faultreadkernel_start</div><div class="line">f016ddf1 D _binary_obj_user_faultreadkernel_end</div><div class="line">f016ddf1 D _binary_obj_user_faultwrite_start</div><div class="line">f0175628 D _binary_obj_user_faultwrite_end</div><div class="line">f0175628 D _binary_obj_user_faultwritekernel_start</div><div class="line">f017ce65 D _binary_obj_user_faultwritekernel_end</div></pre></td></tr></table></figure>
<p>在内核代码里面就可以通过这些变量的指示来找到相应的程序的内存在哪里。<br>那么，这些变量又是如何生成的呢？</p>
<p><a href="https://balau82.wordpress.com/2012/02/19/linking-a-binary-blob-with-gcc/" target="_blank" rel="external">gcc include binary files</a></p>
<p>这里我们假设想把一个<code>hello.c</code>文件生成的<code>binary</code>放到<code>main.c</code>生成的<code>main</code>程序里面。操作如下：</p>
<p><strong>编译hello.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cat &lt;&lt;<span class="string">"EOF"</span>&gt; hello.<span class="function">c</span></div><div class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line">gcc hello.c -o hello</div></pre></td></tr></table></figure>
<p><strong>提取binary</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gcc hello.c -o hello</div><div class="line">objcopy -I binary -O elf32-i386 -B i386 hello hello.o</div></pre></td></tr></table></figure>
<p>首先说一下原理。</p>
<ul>
<li>编译生成<code>hello</code>，这是一个<code>elf</code>格式的完全可以独立运行的格式。</li>
<li>第二句话是将<code>hello</code>这个完整的<code>elf</code>当成一个巨大的<code>char binary[]</code>数组。类似于生成如下汇编代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">.global <span class="number">_b</span>inary_hello_start</div><div class="line">.global <span class="number">_b</span>inary_hello_end</div><div class="line">.global <span class="number">_b</span>inary_hello_size</div><div class="line"><span class="number">_b</span>inary_hello_start:</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line"><span class="number">_b</span>inary_hello_end:</div><div class="line"><span class="number">_b</span>inary_hello_size:</div><div class="line">    .dword x32xxx</div></pre></td></tr></table></figure>
<p>其中<code>xxxx</code>部分就是表示<code>hello</code>整个<code>ELF</code>文件的内容。</p>
<p><code>hello.o</code>就是把这个<code>.asm</code>汇编代码转成<code>object</code>文件。不信用<code>nm -n</code>命令查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># nm -n hello.o</span></div><div class="line">00000000 D _binary_hello_start</div><div class="line">00001c88 D _binary_hello_end</div><div class="line">00001c88 A _binary_hello_size</div><div class="line">root@debug:/tmp<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>所以这里需要明白。这里的<code>hello.o</code>与</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c hello.c -o hello.o</div></pre></td></tr></table></figure>
<p>是不一样的。这两个有本质的区别。并且比较<code>hello</code>与汇编生成的<code>hello.o</code>两者的大小，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># ls -al hello hello.o</span></div><div class="line">-rwxr-xr-x 1 root root 7304  4月 24 08:05 hello</div><div class="line">-rw-r--r-- 1 root root 7730  4月 24 08:05 hello.o  &lt;-- 要大很多</div></pre></td></tr></table></figure>
<p><strong>添加</strong></p>
<p>准备<code>main.c</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_start;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_end;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_size;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *pblob = &amp;<span class="number">_b</span>inary_hello_start;</div><div class="line">  <span class="keyword">while</span>(pblob &lt; &amp;<span class="number">_b</span>inary_hello_end)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %02X\n"</span>, pblob - &amp;<span class="number">_b</span>inary_hello_start, *pblob);</div><div class="line">    pblob++;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"size: %d\n"</span>, &amp;<span class="number">_b</span>inary_hello_size);</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>整合到一起</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c main.c -o main.o</div><div class="line">gcc main.o hello.o -o <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h2 id="env-init"><a href="#env-init" class="headerlink" title="env_init()"></a>env_init()</h2><p>这个函数的作用很简单，就是完成如下功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></div><div class="line"><span class="comment">// 把env_ids = 0</span></div><div class="line"><span class="comment">// and insert them into the env_free_list.</span></div><div class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></div><div class="line"><span class="comment">// 注意顺序，链表的是顺序与数组的顺序是完全一致的。</span></div><div class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></div><div class="line"><span class="comment">// env_alloc() returns envs[0]).</span></div><div class="line"><span class="comment">// 比如第一次申请的时候，肯定拿到的是envs[0]</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Set up envs array</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 直接用memset把所有元素清0了。</span></div><div class="line">    <span class="comment">// 这里其实不用清0也没有关系。是因为在mem_init里面已经清0b 。</span></div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(envs));</div><div class="line">    env_free_list = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        envs[i].env_link = env_free_list;</div><div class="line">        env_free_list = envs + i;</div><div class="line">    &#125;</div><div class="line">    assert(env_free_list == envs);</div><div class="line">    <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">    env_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里犯过的一个错误是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样操作，实际上是会造成溢出。这个循环也就会一直出问题。</p>
<h2 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm()"></a>env_setup_vm()</h2><p>这个函数的功能实际上就是给进程分配页目录表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></div><div class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></div><div class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></div><div class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></div><div class="line"><span class="comment">// of the environment's virtual address space.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></div><div class="line"><span class="comment">//    -E_NO_MEM if page directory or table could not be allocated.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">struct</span> PageInfo *p = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a page for the page directory</span></div><div class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">    <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//    - The VA space of all envs is identical above UTOP</span></div><div class="line">    <span class="comment">//    (except at UVPT, which we've set below).</span></div><div class="line">    <span class="comment">//    See inc/memlayout.h for permissions and layout.</span></div><div class="line">    <span class="comment">//    Can you use kern_pgdir as a template?  Hint: Yes.</span></div><div class="line">    <span class="comment">//    (Make sure you got the permissions right in Lab 2.)</span></div><div class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></div><div class="line">    <span class="comment">//    - You do not need to make any more calls to page_alloc.</span></div><div class="line">    <span class="comment">//    - Note: In general, pp_ref is not maintained for</span></div><div class="line">    <span class="comment">//    physical pages mapped only above UTOP, but env_pgdir</span></div><div class="line">    <span class="comment">//    is an exception -- you need to increment env_pgdir's</span></div><div class="line">    <span class="comment">//    pp_ref for env_free to work correctly.</span></div><div class="line">    <span class="comment">//    - The functions in kern/pmap.h are handy.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 要点：高于UTOP的虚拟地址都是一样的。因为给内核用了。但是UVPT除外。</span></div><div class="line">    <span class="comment">//      这里需要利用kern_pgdir作为一个模板</span></div><div class="line">    <span class="comment">// 确保kern_pgdir里面的权限是正确设置的。</span></div><div class="line">    <span class="comment">//      1. 小于UTOP的地址是空的</span></div><div class="line">    <span class="comment">//      2. 不需要调用page_alloc</span></div><div class="line">    <span class="comment">//      3. pp_ref高于UTOP的部分是不维护的。因为只有内核在用。</span></div><div class="line">    <span class="comment">//         但是env_pgdir是个例外，因为可能其他进程的页表会引用到</span></div><div class="line">    <span class="comment">//         所以需要p-&gt;pp_ref++;</span></div><div class="line">    e-&gt;env_pgdir = page2kva(p);</div><div class="line">    p-&gt;pp_ref++;</div><div class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"></div><div class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">    <span class="comment">// Permissions: kernel R, user R</span></div><div class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里也是像内核一样，把<code>UVPT</code>这块空间映射到了页目录表这里。通过这样一个映射。进程在查看自己的<br>内存信息的时候，可以直接通过<code>UVPT</code>这个地址得到。</p>
<p>这样可以发现，内核并没有提供一个叫<code>get_pgdir(void **pgdir)</code>这样的一个系统调用给用户进程。<br>而是通过一种共享内存的方式来实现的。而在<code>linux</code>系统里面，很多信息则是通过<code>/proc, /sysfs</code>这两个文件系统<br>接口来提供的。</p>
<h2 id="region-alloc"><a href="#region-alloc" class="headerlink" title="region_alloc"></a>region_alloc</h2><p><code>region_alloc</code>函数的功能就是填充<code>va</code>起始的虚拟地址。需要找到长度为<code>len</code>的物理内存地址来填满。<br>函数总的来说，还是比较简单。毕竟只是一个<code>lab</code>。并不需要考虑页面不够的情况。</p>
<p>唯一需要处理的就是把地址对齐之后，然后一页一页地开始处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></div><div class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></div><div class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></div><div class="line"><span class="comment">// Pages should be writable by user and kernel.</span></div><div class="line"><span class="comment">// Panic if any allocation attempt fails.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">    <span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">    <span class="comment">// 分配len字节的物理地址给进程env，并且要映射到虚拟地址va.</span></div><div class="line">    <span class="comment">// 不要初始化这个映射的页面。</span></div><div class="line">    <span class="comment">// 页面要可读，可写</span></div><div class="line">    <span class="comment">// 如果分配失败要panic.</span></div><div class="line">    <span class="comment">// region_alloc</span></div><div class="line">    <span class="keyword">void</span> *v = ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">size_t</span> l = ROUNDUP(len, PGSIZE);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; l; i += PGSIZE) &#123;</div><div class="line">        <span class="keyword">struct</span> PageInfo *p = page_alloc(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (!p) &#123;</div><div class="line">            panic(<span class="string">"region_alloc :%e"</span>, -E_NO_MEM);</div><div class="line">        &#125;</div><div class="line">        assert(!page_insert(e-&gt;env_pgdir, p, v, PTE_U | PTE_W));</div><div class="line">        v += PGSIZE;</div><div class="line">        <span class="comment">// 不要溢出</span></div><div class="line">        assert(v &gt; va &amp;&amp; i &lt; len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对于溢出的检查和处理。</p>
<h2 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h2><p><code>load_icode</code>函数本身是用来加载整个程序的。因为程序是<code>ELF</code>格式的。<br><code>ELF</code>里面提明了需要加到载的段内存地址<code>ph-&gt;p_va</code>，要加载的段的长度<code>ph-&gt;p_filesz</code>等信息。<br>仔细读一下注释就可以把代码写出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></div><div class="line"><span class="comment">// for a user process.</span></div><div class="line"><span class="comment">// 设置一个初始的程序代码段，栈，CPU标志位给用户程序。</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// 这个函数只会在内核初始化的时候被调用。并且是在第一次跳到用户</span></div><div class="line"><span class="comment">// 模式环境之前。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></div><div class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></div><div class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 这个函数加载所有从ELF二进制里面可加载的段到用户环境的内存里面。</span></div><div class="line"><span class="comment">// 加载到合适的想到的虚拟地址那里去。</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></div><div class="line"><span class="comment">// that are marked in the program header as being mapped</span></div><div class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 同时这个程序也会把应该清0的段对应的内存进行清0操作。比如程序里面的</span></div><div class="line"><span class="comment">// bss段。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></div><div class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></div><div class="line"><span class="comment">// boot/main.c to get ideas.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 实际上这个跟我们前面在bootloader里面做的事情是很像的。这个时候可以看</span></div><div class="line"><span class="comment">// 看boot/main.c。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Finally, this function maps one page for the program's initial stack.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 最后会加载一页做为程序初始的栈。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// load_icode panics if it encounters problems.</span></div><div class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></div><div class="line"><span class="comment">// 在什么情况下load_icode会挂掉。</span></div><div class="line"><span class="comment">// 给定的输入可能会出啥问题。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">uint8_t</span> *binary)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Hints:</span></div><div class="line">    <span class="comment">//  Load each program segment into virtual memory</span></div><div class="line">    <span class="comment">//  at the address specified in the ELF segment header.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF header里面记录了所有的段的信息。</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  只加载：ph-&gt;p_type = ELF_PROG_LOAD</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段的虚拟地址: ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  段大小: ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></div><div class="line">    <span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></div><div class="line">    <span class="comment">//  ph-&gt;p_va.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段起始: binary + ph-&gt;p_offset</span></div><div class="line">    <span class="comment">//  段长： ph-&gt;p_filesz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Any remaining memory bytes should be cleared to zero.</span></div><div class="line">    <span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  清零段：ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  All page protection bits should be user read/write for now.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  页权限: PTE_U | PTE_W</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></div><div class="line">    <span class="comment">//  assume for this function that no two segments will touch</span></div><div class="line">    <span class="comment">//  the same virtual page.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF段不需要页对齐：不会有两个段指向同样的虚拟地址</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You may find a function like region_alloc useful.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  region_alloc有用</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Loading the segments is much simpler if you can move data</span></div><div class="line">    <span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></div><div class="line">    <span class="comment">//  So which page directory should be in force during</span></div><div class="line">    <span class="comment">//  this function?</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  加载段还是比较简单的，比如可以把数据直接从含有ELF虚拟地址空间</span></div><div class="line">    <span class="comment">//  复制过去。所以这个时候应该加载的是哪个页目录表？</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You must also do something with the program's entry point,</span></div><div class="line">    <span class="comment">//  to make sure that the environment starts executing there.</span></div><div class="line">    <span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  你必须要利用program entry来做一些事情，以确保后面从这里开始执行。</span></div><div class="line">    <span class="comment">//  env_run &amp; env_pop_tf().</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Elf *ELFHDR = (<span class="keyword">struct</span> Elf*)binary;</div><div class="line">    assert(ELFHDR-&gt;e_magic == ELF_MAGIC);</div><div class="line">    <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></div><div class="line">    ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">    eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">            region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">            <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">            <span class="keyword">uint8_t</span> *dst = (<span class="keyword">uint8_t</span>*)ph-&gt;p_va;</div><div class="line">            <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">            <span class="comment">// uint8_t *dst = page2kva(page_lookup(e-&gt;env_pgdir, (void *)(ph-&gt;p_va), NULL));</span></div><div class="line">            <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">                <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lcr3(PADDR(kern_pgdir));</div><div class="line">    e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div><div class="line"></div><div class="line">    <span class="comment">// Now map one page for the program's initial stack</span></div><div class="line">    <span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    region_alloc(e, (<span class="keyword">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里唯一需要注意的是：以下这种方式是不工作的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">        region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">        <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">        <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">        <span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div><div class="line">        <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">            <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div></pre></td></tr></table></figure>
<p>首先说一下这种写法的意图。意图就是通过<code>kern_pgdir</code>这个虚拟地址空间把相应的页拷贝过去。<br>但是这里需要注意的是。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div></pre></td></tr></table></figure>
<p>这种拷贝方式只对单页面有效的。对于一个段，如果超出两个页，而这个两个页面在物理上并不连续的时候。<br>就出问题。</p>
<p>此外，一定要注意<code>tf_eip</code>的设置。</p>
<h2 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a>env_create</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></div><div class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// The new env's parent ID is set to 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Env *init_task = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 必须成功</span></div><div class="line">    assert(!env_alloc(&amp;init_task, <span class="number">0</span>));</div><div class="line">    init_task-&gt;env_parent_id = <span class="number">0</span>;</div><div class="line">    init_task-&gt;env_type = type;</div><div class="line">    load_icode(init_task, binary);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是申请一个进程描述符，然后把相应的代码加载上去。</p>
<h2 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a>env_run</h2><p>调度到用户进程上执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Context switch from curenv to env e.</span></div><div class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function does not return.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></div><div class="line">    <span class="comment">//       1. Set the current environment (if any) back to</span></div><div class="line">    <span class="comment">//          ENV_RUNNABLE if it is ENV_RUNNING (think about</span></div><div class="line">    <span class="comment">//          what other states it can be in),</span></div><div class="line">    <span class="comment">//       2. Set 'curenv' to the new environment,</span></div><div class="line">    <span class="comment">//       3. Set its status to ENV_RUNNING,</span></div><div class="line">    <span class="comment">//       4. Update its 'env_runs' counter,</span></div><div class="line">    <span class="comment">//       5. Use lcr3() to switch to its address space.</span></div><div class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></div><div class="line">    <span class="comment">//       registers and drop into user mode in the</span></div><div class="line">    <span class="comment">//       environment.</span></div><div class="line"></div><div class="line">    <span class="comment">// Hint: This function loads the new environment's state from</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf.  Go back through the code you wrote above</span></div><div class="line">    <span class="comment">//    and make sure you have set the relevant parts of</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf to sensible values.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">    curenv = e;</div><div class="line">    curenv-&gt;env_status = ENV_RUNNING;</div><div class="line">    e-&gt;env_runs++;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line">    <span class="comment">// panic("env_run not yet implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是做了一个非常简单的进程切换。把当前<code>curenv</code>进程切换到要运行的进程<code>e</code>上面。<br>过程还是比较简单，直接把页目录表加载上去之后，就开始跑了。</p>
<p>调用过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">start (kern/entry.S)</div><div class="line">i386_init (kern/init.c)</div><div class="line">    cons_init</div><div class="line">    mem_init</div><div class="line">    env_init</div><div class="line">    trap_init (still incomplete at this point)</div><div class="line">    env_create  # 建页目录表，加载代码</div><div class="line">    env_run     # 切换上下文</div><div class="line">        env_pop_tf</div></pre></td></tr></table></figure>
<p>注意，这里如果打算直接跑一下<code>make qemu-nox</code>的话。整个<code>OS</code>会不断地重启。<br>这是因为中断还没有设置。当<code>hello world</code>打算退出的时候，就会调用<code>sys_exit</code>系统调用。<br>中断还没有设置时，就会遇以保护错误。这个时候系统就会不断重启。</p>
<p><strong>注意</strong>如果是使用的MIT打补丁的<code>qemu</code>是不会重启的。只是这里没有必要专门为了这么一个实验去<br>搞他的那个补丁。</p>
<h1 id="中断号的描述"><a href="#中断号的描述" class="headerlink" title="中断号的描述"></a>中断号的描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:id :type :errorCode :info</div><div class="line">:0 :Fault :No :Divide Error</div><div class="line">:1 :Fault/Trap :No :Debug Exception</div><div class="line">:2 :Interrupt :No :NMI Interrupt</div><div class="line">:3 :Trap :No :Breakpoint</div><div class="line">:4 :Trap :No :Overflow</div><div class="line">:5 :Fault :No :Bound Check</div><div class="line">:6 :Fault :No :Illegal Opcode</div><div class="line">:7 :Fault :No :Device Not available</div><div class="line">:8 :Abort :Yes :Double Fault</div><div class="line">:10 :Fault :Yes :Invalid TSS</div><div class="line">:11 :Fault :Yes :Segment Not Present</div><div class="line">:12 :Fault :Yes :Stack Exception</div><div class="line">:13 :Fault :Yes :General Protection Fault</div><div class="line">:14 :Fault :Yes :Page Fault</div><div class="line">:16 :Fault :No :Floating Point Error</div><div class="line">:17 :Fault :Yes :Alignment Check</div><div class="line">:18 :Abort :No :Machine Check</div><div class="line">:19 :Fault :No :Simd Floating Point Error</div></pre></td></tr></table></figure>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>这里需要看一下这个图。</p>
<p><img src="/blog/img/mit.6.828/lab3.idt.jpeg" alt=""></p>
<p>如果对应到源码里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* Interrupt descriptor table.  (Must be built at run time because</span></div><div class="line"> * shifted function addresses can't be represented in relocation records.)</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> Gatedesc idt[<span class="number">256</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;</div><div class="line"><span class="keyword">struct</span> Pseudodesc idt_pd = &#123;</div><div class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>) idt</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的<code>idt</code>就是存放256个中断描述符的地方。只过这个时候还没有把<code>idt</code>加载到<code>CPU</code>上。而在<code>trap_init</code>的时候<br>把这些中断描述符填上去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">struct</span> Segdesc gdt[];</div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DIVIDE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEBUG_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_NMI_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BRKPT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_OFLOW_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BOUND_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ILLOP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEVICE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DBLFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_TSS_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SEGNP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_STACK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_GPFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_PGFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_FPERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ALIGN_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_MCHK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SIMDERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SYSCALL_handler</span><span class="params">()</span></span>;</div><div class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, T_DIVIDE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, T_DEBUG_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, T_NMI_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, T_BRKPT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_OFLOW], <span class="number">1</span>, GD_KT, T_OFLOW_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, T_BOUND_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, T_ILLOP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, T_DEVICE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, T_DBLFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, T_TSS_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, T_SEGNP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, T_STACK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, T_GPFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, T_PGFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, T_FPERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, T_ALIGN_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, T_MCHK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, T_SIMDERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, T_SYSCALL_handler, <span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Per-CPU setup </span></div><div class="line">    trap_init_percpu();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init_percpu</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></div><div class="line">    <span class="comment">// when we trap to the kernel.</span></div><div class="line">    ts.ts_esp0 = KSTACKTOP;</div><div class="line">    ts.ts_ss0 = GD_KD;</div><div class="line">    ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</div><div class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></div><div class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></div><div class="line">    ltr(GD_TSS0);</div><div class="line"></div><div class="line">    <span class="comment">// Load the IDT</span></div><div class="line">    lidt(&amp;idt_pd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可能的面临的一个问题是，这些中断处理程序是在哪里定义的呢？那么接下来写<code>trapentry.S</code>。</p>
<h3 id="trapentry-S"><a href="#trapentry-S" class="headerlink" title="trapentry.S"></a>trapentry.S</h3><p>整个中断的调用过程如下图所示：</p>
<p><img src="/blog/img/lab3.process.jpeg" alt=""></p>
<p>因此，在写代码的时候，需要先写<code>trapentry.S</code>里面的代码。首先读一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</div><div class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</div><div class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</div><div class="line"> *</div><div class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</div><div class="line"> * need to _declare_ one in C (for instance, to get a function pointer</div><div class="line"> * during IDT setup).  You can declare the function with</div><div class="line"> *   void NAME();</div><div class="line"> * where NAME is the argument passed to TRAPHANDLER.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER(name, num)                        \</div><div class="line">    .globl name;        /* define global symbol for &apos;name&apos; */    \</div><div class="line">    .type name, @function;    /* symbol type is function */        \</div><div class="line">    .align 2;        /* align function definition */        \</div><div class="line">    name:            /* function starts here */        \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div><div class="line"></div><div class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</div><div class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class="line"> * format in either case.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER_NOEC(name, num)                    \</div><div class="line">    .globl name;                            \</div><div class="line">    .type name, @function;                        \</div><div class="line">    .align 2;                            \</div><div class="line">    name:                                \</div><div class="line">    pushl $0;                            \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div></pre></td></tr></table></figure>
<p>这是因为<code>x86</code>的CPU硬件在遇到中断的时候，会进行自动化的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 如果是在ring <span class="number">0</span>，那么直接使用当前的ss/esp</div><div class="line"><span class="number">2.</span> 如果是在ring <span class="number">3</span>, 那么使用当前tss段里面的ss0/esp0。然后开始压栈</div></pre></td></tr></table></figure>
<p>无错误码时压栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>对于这种情况。<code>TRAPHANDLER_NOEC</code>会额外地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pushl $0;</div></pre></td></tr></table></figure>
<p>有错误码时压栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20</div><div class="line">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>因此，当压完栈之后。栈中的元素就是对应下面罗列的元素。由此可知，<br><strong>硬件栈是从上往下增长，一个结构体，代码最下面的元素是最先入栈。</strong></p>
<p>如果把结构体里面所有的元素放在从左往右的一行上。压栈顺序与函数入栈的顺序也是一样的。即从<strong>右往左</strong>入栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Trapframe &#123;</div><div class="line">    .....</div><div class="line">    <span class="keyword">uint32_t</span> tf_trapno;</div><div class="line">    <span class="comment">/* below here defined by x86 hardware */</span></div><div class="line">    <span class="keyword">uint32_t</span> tf_err;</div><div class="line">    <span class="keyword">uintptr_t</span> tf_eip;</div><div class="line">    <span class="keyword">uint16_t</span> tf_cs;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding3;</div><div class="line">    <span class="keyword">uint32_t</span> tf_eflags;</div><div class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></div><div class="line">    <span class="keyword">uintptr_t</span> tf_esp;</div><div class="line">    <span class="keyword">uint16_t</span> tf_ss;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding4;</div><div class="line">&#125; <span class="number">__</span>attribute__((packed));</div></pre></td></tr></table></figure>
<p>这些元素，有些是硬件压入栈的。有些是两个宏压入栈的。<br>但是，这两个宏的本意是用来声明中断处理函数的。这个时候可以根据硬件中断的描述编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line">TRAPHANDLER_NOEC(T_DIVIDE_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(T_DEBUG_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(T_NMI_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(T_BRKPT_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(T_OFLOW_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(T_BOUND_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(T_ILLOP_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(T_DEVICE_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(T_DBLFLT_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(T_TSS_handler, T_TSS)</div><div class="line">TRAPHANDLER(T_SEGNP_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(T_STACK_handler, T_STACK)</div><div class="line">TRAPHANDLER(T_GPFLT_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(T_PGFLT_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(T_FPERR_handler, T_FPERR)</div><div class="line">TRAPHANDLER(T_ALIGN_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(T_MCHK_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(T_SIMDERR_handler, T_SIMDERR)</div><div class="line">TRAPHANDLER_NOEC(T_SYSCALL_handler, T_SYSCALL)</div></pre></td></tr></table></figure>
<p>在写这里的时候，一定不要忘了系统调用号<code>T_SYSCALL</code>的设置。</p>
<h3 id="统一的中断处理"><a href="#统一的中断处理" class="headerlink" title="统一的中断处理"></a>统一的中断处理</h3><p>但是<code>struct Trapframe</code>里面还有好多其他元素。后面还是需要接着再入栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line"> * 注意压栈的顺序是从struct Trapframe的底部往上压</div><div class="line"> * 看一下前面的宏，已经压参数，压到了tf_trapno这里了。</div><div class="line"> * 注意：使用pusha指令</div><div class="line"> */</div><div class="line">_alltraps:</div><div class="line">    /*</div><div class="line">     * 注意这里直接用了pushl前面自动补0</div><div class="line">     * 如果要严格的对应</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %ds</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %es</div><div class="line">     */</div><div class="line">    pushl %ds</div><div class="line">    pushl %es</div><div class="line">    pushal</div><div class="line">    /*</div><div class="line">     * 这里是因为后面要调用trap函数</div><div class="line">     * 1. </div><div class="line">     *   trap函数的定义是trap(struct Trapframe *tf)</div><div class="line">     *   这里还有一个指针</div><div class="line">     *   这个时候压入pushl %esp这个寄存器的内容。</div><div class="line">     *   也就刚好是真正的指向struct Trapframe这个object的起始地址</div><div class="line">     * 2. </div><div class="line">     *   如果trap函数的定义是trap(struct Trapframe tfObject)</div><div class="line">     *   那么这个pushl %esp是没有必要压进去的</div><div class="line">     */</div><div class="line">    pushl %esp</div><div class="line">    /*然后指向内核数据段</div><div class="line">     * 硬件上中断门描述符进来的时候</div><div class="line">     * 已经把CPU设置成了GD_KT也就是内核代码段。</div><div class="line">     * 这个是硬件操作</div><div class="line">     */</div><div class="line">    movw $GD_KD, %ax</div><div class="line">    movw %ax, %ds</div><div class="line">    movw %ax, %es</div><div class="line">    call trap</div><div class="line"></div><div class="line">    /* 操作完成之后，</div><div class="line">     * 没有必要要按照反方向的顺序返回</div><div class="line">     * 因为trap函数最终会走到env_pop_tf()这个函数</div><div class="line">     * movl $tf, %esp</div><div class="line">     * popal</div><div class="line">     * popl %es</div><div class="line">     * popl %ds</div><div class="line">     * addl $0x08, %esp</div><div class="line">     * iret</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>注意上面代码中的注释。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个时候可以总结一下了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 发生中断或者trap，从ldtr里面找到ldt。</div><div class="line">2. 根据中断号找到这一项，即ldt[中断号]</div><div class="line">3. 根据ldt[中断号] == SETGATE(idt[T_MCHK], 0, GD_KT, T_MCHK_handler, 0);</div><div class="line">   取出当时设置的中断处理函数</div><div class="line">4. 跳转到中断函数</div><div class="line">5. 中断处理函数再跳转到trap函数。</div><div class="line">6. trap函数再根据tf-&gt;trap_no中断号来决定分发给哪个函数。</div></pre></td></tr></table></figure>
<p>也就是如下图：</p>
<p><img src="/blog/img/mit.6.828/lab3.irq.jpeg" alt=""></p>
<h2 id="trap-dispatch"><a href="#trap-dispatch" class="headerlink" title="trap_dispatch"></a>trap_dispatch</h2><p>trap函数接下来就是调用<code>trap_dispatch</code>分发了中断。所以函数的具体实现还得转到<code>trap_dispatch</code>这个函数里面来。<br>这个时候就要开始做练习5了。</p>
<p>Exercise 5. Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>.<br>You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>,<br><code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and<br>fix them. Remember that you can boot JOS into a particular user program using <code>make run-x</code><br>or <code>make run-x-nox</code>. For instance, <code>make run-hello-nox</code> runs the <code>hello</code> user program.</p>
<p>这里还是比较简单。<strong>注意</strong>这里只需要转到<code>page_fault_handler()</code>就可以了。并不需要在<code>page_fault_handler()</code>里面做任何真正的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"><span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</div><div class="line"><span class="keyword">case</span> T_PGFLT:</div><div class="line">    page_fault_handler(tf);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，对于断点来说，也是需要再加一个<code>case</code>就可了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_BRKPT:</div><div class="line">    monitor(tf);</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>但是需要注意，在以前写代码的时候，设置<code>SETGATE</code>的时候，需要设置<code>dpl=3</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SETGATE(idt[T_BRKPT], 1, GD_KT, T_BRKPT_handler, 3);</div></pre></td></tr></table></figure>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在开始写之前，需要考虑客户端是如何调用的。<code>inc/syscall.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* system call numbers */</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    SYS_cputs = <span class="number">0</span>,</div><div class="line">    SYS_cgetc,</div><div class="line">    SYS_getenvid,</div><div class="line">    SYS_env_destroy,</div><div class="line">    NSYSCALLS</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里定义了系统调用的数目。客户端的使用代码位于<code>lib/syscall.c</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">static inline int32_t</div><div class="line">syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</div><div class="line">&#123;</div><div class="line">    int32_t ret;</div><div class="line"></div><div class="line">    // Generic system call: pass system call number in AX,</div><div class="line">    // up to five parameters in DX, CX, BX, DI, SI.</div><div class="line">    // Interrupt kernel with T_SYSCALL.</div><div class="line">    //</div><div class="line">    // The "volatile" tells the assembler not to optimize</div><div class="line">    // this instruction away just because we don't use the</div><div class="line">    // return value.</div><div class="line">    //</div><div class="line">    // The last clause tells the assembler that this can</div><div class="line">    // potentially change the condition codes and arbitrary</div><div class="line">    // memory locations.</div><div class="line"></div><div class="line">    asm volatile("int %1\n"      // 这里指向num</div><div class="line">             : "=a" (ret)        // 返回值从eax 设置到 ret里面。</div><div class="line">             : "i" (T_SYSCALL),  // 这里随意选择一个寄存器</div><div class="line">               "a" (num),        // 把想要调用的中断号给eax</div><div class="line">               "d" (a1),         // 第一个参数给edx</div><div class="line">               "c" (a2),         // 第二个参数给ecx</div><div class="line">               "b" (a3),         // 第三个参数给ebx</div><div class="line">               "D" (a4),         // 第四个参数给edi</div><div class="line">               "S" (a5)          // 第五个参数给esi</div><div class="line">             : "cc", "memory");</div><div class="line"></div><div class="line">    // 如果我们的指令可以修改条件码寄存器（cc），我们必须将 "cc" 添加进修饰寄存器列表。</div><div class="line">    // 如果我们的指令以不可预测的方式修改了内存，那么需要将 "memory" 添加进修饰寄存器列表。</div><div class="line">    if(check &amp;&amp; ret &gt; 0)</div><div class="line">        panic("syscall %d returned %d (&gt; 0)", num, ret);</div><div class="line"></div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以在写底层<code>OS</code>的实现的时候，也一定要注意到这么一点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_SYSCALL:</div><div class="line">    <span class="keyword">if</span> (tf-&gt;tf_regs.reg_eax &gt;= NSYSCALLS) <span class="keyword">return</span> -E_INVAL;</div><div class="line">    tf-&gt;tf_regs.reg_eax = syscall(</div><div class="line">        tf-&gt;tf_regs.reg_eax,</div><div class="line">        tf-&gt;tf_regs.reg_edx,</div><div class="line">        tf-&gt;tf_regs.reg_ecx,</div><div class="line">        tf-&gt;tf_regs.reg_ebx,</div><div class="line">        tf-&gt;tf_regs.reg_edi,</div><div class="line">        tf-&gt;tf_regs.reg_esi</div><div class="line">    );</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>系统要实现的系统调用也没有太多。也就是<code>enum</code>那里列出来的那几个。所以在实现的时候，只需要通过<br><code>case</code>语句把系统调用引导过去就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></div><div class="line"><span class="keyword">int32_t</span></div><div class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></div><div class="line">    <span class="comment">// Return any appropriate return value.</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    <span class="keyword">switch</span> (syscallno) &#123;</div><div class="line">        <span class="keyword">case</span> SYS_cputs:</div><div class="line">            sys_cputs((<span class="keyword">char</span>*)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">        <span class="keyword">case</span> SYS_cgetc:</div><div class="line">            <span class="keyword">return</span> sys_cgetc();</div><div class="line">        <span class="keyword">case</span> SYS_getenvid:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_getenvid();</div><div class="line">        <span class="keyword">case</span> SYS_env_destroy:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_env_destroy(sys_getenvid());</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="内存的检测"><a href="#内存的检测" class="headerlink" title="内存的检测"></a>内存的检测</h2><p>接下来就会看到<code>SYS_cputs</code>函数里面是需要检查一下用户权限是否可以访问内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Print a string to the system console.</span></div><div class="line"><span class="comment">// The string is exactly 'len' characters long.</span></div><div class="line"><span class="comment">// Destroys the environment on memory errors.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></div><div class="line">    <span class="comment">// Destroy the environment if not.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_assert(curenv, s, len, PTE_P|PTE_U);</div><div class="line">    <span class="comment">// Print the string supplied by the user.</span></div><div class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这里<code>user_mem_assert</code>是需要在<code>kern/pmap.c</code>里面去实现的。代码跳转过去，会发现代码里<br>需要实现的是<code>user_mem_check()</code>。</p>
<p>首先给出一种低效的版本，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int</div><div class="line">user_mem_check(struct Env *env, const void *va, size_t len, int perm)</div><div class="line">&#123;</div><div class="line">    // LAB 3: Your code here.</div><div class="line">    // LAB 3: DONE</div><div class="line">    user_mem_check_addr = 0;</div><div class="line">    for (const void *b = va; (b - va) &lt; len; b++) &#123;</div><div class="line">        user_mem_check_addr = (size_t)b &lt; ULIM ? 0 : (size_t)b;</div><div class="line">        if (!user_mem_check_addr) &#123;</div><div class="line">            pte_t *pte = pgdir_walk(env-&gt;env_pgdir, b, 0);</div><div class="line">            if (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (size_t)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (user_mem_check_addr) return -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，为了防止溢出，在条件判断的时候，最好是使用<code>b-va &lt; len</code>这种格式。<br>这个处理实际上是比较简单粗爆的。每个内存地址都需要依次检查一下。<br>假设要检查的地址是<code>10 ~ 4097</code>。在检查完地址<code>10</code>之后。实际上是可以跳到下<br>一个页面大小对齐的地址上去的。也就是4096。这里处理起来非常简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">b = 当前地址</div><div class="line">// 要找到下一个页面对齐的地址</div><div class="line">b = ROUNDDOWN(b, PGSIZE) + PGSIZE</div></pre></td></tr></table></figure>
<p>那么代码就可以很容易地精简如下了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_check_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">void</span> *b = va; (b - va) &lt; len; b += PGSIZE) &#123;</div><div class="line">        <span class="comment">// 注意在这里检查一下内存地址的有效性</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">size_t</span>)b &lt; ULIM ? <span class="number">0</span> : (<span class="keyword">size_t</span>)b;</div><div class="line">        <span class="keyword">if</span> (!user_mem_check_addr) &#123;</div><div class="line">            <span class="keyword">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, b, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (<span class="keyword">size_t</span>)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (user_mem_check_addr) <span class="keyword">return</span> -E_FAULT;</div><div class="line">        b = ROUNDDOWN(b, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab3" data-title="MIT 6.828 Lab3" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/jos-lab2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/19/mit.6.828/jos-lab2/" class="article-date">
  	<time datetime="2018-04-19T14:28:32.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/19/mit.6.828/jos-lab2/">MIT 6.828 Lab2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h1><p>In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">boot_alloc()</div><div class="line">mem_init() (only up to the call to check_page_free_list(<span class="number">1</span>))</div><div class="line">page_init()</div><div class="line">page_alloc()</div><div class="line">page_free()</div></pre></td></tr></table></figure>
<p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</p>
<p>总的来说，就是需要实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">boot_alloc()</div><div class="line">mem_init() <span class="comment">// 只需要实现到check_page_free_list(1)这里。</span></div><div class="line">page_init()</div><div class="line">page_alloc()</div><div class="line">page_free()</div></pre></td></tr></table></figure>
<h1 id="bootloader读入内核代码之后的分布"><a href="#bootloader读入内核代码之后的分布" class="headerlink" title="bootloader读入内核代码之后的分布"></a>bootloader读入内核代码之后的分布</h1><p><a href="http://lzz5235.github.io/2014/03/04/jos.html" target="_blank" rel="external">内存分布</a></p>
<p>这里主要是引用一下这个图：</p>
<p><img src="http://lzz5235.github.io/assets/pic/235.png" alt=""></p>
<p>可以发现，在刚读取完成内核代码到内存之后。形成的结构如上图所示。</p>
<h1 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h1><p>分页的机制在《x86汇编语言－从实模式到保护模式》里面介绍得比较清楚。这里就不多说，只引用<a href="http://neilsh.me/2015/07/02/os_setup_and_virtual_memory_setup/" target="_blank" rel="external">一张图</a>：</p>
<p><img src="http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg" alt=""></p>
<h2 id="UVPT"><a href="#UVPT" class="headerlink" title="UVPT"></a>UVPT</h2><p>UVPT: 需要看 <a href="https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UVPT = 0x3BD &lt;&lt; 22</div></pre></td></tr></table></figure>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><p>如果一个虚拟地址等于<code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0</code>。<br>使用<code>kern_pgdir</code>的时候，这个虚拟地址MCU处理之后就是<code>kern_pgdir</code>。</p>
<p>所以 <code>*(0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0) == kern_pgdir</code>。<br>那么，假设有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    p[i]; <span class="comment">// 这里实际上就是在遍历kern_pgdir[i];    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0~4096</code>byte地址，就是映射到了<code>char kern_pgdir[4096]</code><br>这个数组。</p>
<h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><p>那么假设虚拟地址是<code>0x3BD  &lt;&lt; 22 | 0~1024 | 0</code>这个时候情况又是如何？比如用户程序访问<code>0x3BD &lt;&lt; 22</code>这个地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. CR3 = kern_pgdir</div><div class="line">2. 高10位值为0x3BD, 页目录项为kern_pgdir[0x3BD]</div><div class="line">   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</div><div class="line">   不用说，又回到了kern_pgdir</div><div class="line">3. 中间10位为0，那么页表为kern_pgdir[0x3BD]指向的物理地址的第0项。</div><div class="line">   由于kern_pgdir[0x3BD]指向的是kern_pgdir，所以这里页表为kern_pgdir[0]。</div><div class="line">   kern_pgdir[0]用户程序是可以访问的。在Case 1里面已经验证过了。</div><div class="line">4. 虚拟地址就是kern_pgdir[0]指向的物理地址的第0项。不过这个物理地址，用户程序不一定可以访问。</div></pre></td></tr></table></figure>
<p>所以总结一下就是<code>0x3BD &lt;&lt; 22 | 0 ~ 1024 | xxxx</code>。这个时候，前面<code>20</code>位的地址一解释。指向的地址就是一个<br>页表地址<code>kern_pgdir[i]</code>。如果再加上<code>offset = xxxx</code>。实际上这个地址，虚拟地址不一定可以访问。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0~4096</code>byte地址，就是映射到了<code>char kern_pgdir[4096]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    p[i]; <span class="comment">// 这里实际上就是在遍历uint32_t kern_pgdir[i];    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UVPT ~ UVPT + 4MB</code>这个虚拟地址应该会有至少一个页目录项。一个页目录项刚好点4MB。结合Case 2。可以发现，<br>用户程序通过kern_pgdir这个数组里面的内容，就知道这4MB空间里面的页表的内容。比如是否有物理地址映射？<br>是否已经分配内存。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (*(p+i) &amp; <span class="number">0x01</span>) &#123;</div><div class="line">        <span class="comment">// 二级页表存在</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 二级页表不存在</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h2><p>这个函数首先来，<code>end</code>变量是定义在<code>kernel.ld</code>文件里面的。指向了内核地址的尾巴。<br>也就是在向内核要虚拟地址的时候，可以从这里开始要。</p>
<p><strong>注意</strong>这里要到的地址是虚拟地址。不是物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></div><div class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span></div><div class="line"><span class="comment">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></div><div class="line"><span class="comment">// anything.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If we're out of memory, boot_alloc should panic.</span></div><div class="line"><span class="comment">// This function may ONLY be used during initialization,</span></div><div class="line"><span class="comment">// before the page_free_list list has been set up.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></div><div class="line">    <span class="keyword">char</span> *result;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></div><div class="line">    <span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></div><div class="line">    <span class="comment">// which points to the end of the kernel's bss segment:</span></div><div class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></div><div class="line">    <span class="comment">// to any kernel code or global variables.</span></div><div class="line">    <span class="keyword">if</span> (!nextfree) &#123;</div><div class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</div><div class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></div><div class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></div><div class="line">    <span class="comment">// to a multiple of PGSIZE.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// LAB 2: Your code here.</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == n) &#123;</div><div class="line">        <span class="keyword">return</span> nextfree;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    n = ROUNDUP(n, PGSIZE);</div><div class="line">    result = nextfree;</div><div class="line">    nextfree += n;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init"></a>mem_init</h2><p>这个函数里面分为页管理链表分配空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">n = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages;</div><div class="line">pages = (<span class="keyword">struct</span> PageInfo*)boot_alloc(n);</div><div class="line"><span class="built_in">memset</span>(pagees, <span class="number">0</span>, n);</div></pre></td></tr></table></figure>
<p>注意看注释，要求全部初始化为0的。</p>
<h2 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h2><p>这里要做的事情很简单，就是把空闲的内存通过双向链表串起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// The example code here marks all physical pages as free.</span></div><div class="line">    <span class="comment">// However this is not truly the case.  What memory is free?</span></div><div class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></div><div class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></div><div class="line">    <span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></div><div class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></div><div class="line">    <span class="comment">//     is free.</span></div><div class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></div><div class="line">    <span class="comment">//     never be allocated.</span></div><div class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></div><div class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></div><div class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></div><div class="line">    <span class="comment">//     page tables and other data structures?</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Change the code to reflect this.</span></div><div class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></div><div class="line">    <span class="comment">// free pages!</span></div><div class="line">    <span class="keyword">size_t</span> i;</div><div class="line">    <span class="comment">// 这里采用的思路是：凡是不能被分配的内存页，都不加到链表里面。</span></div><div class="line">    <span class="comment">// 只处理可以被使用的内存页。</span></div><div class="line">    assert(!page_free_list);</div><div class="line">    <span class="comment">// 1. page 0是要被用来做实模式的IDT BIOS数据结构，尽管从来不会用，以后也不会用</span></div><div class="line">    <span class="comment">//    这不是浪费么。不管了。</span></div><div class="line">    <span class="comment">// 2. 接下来的[PGSIZE, npages_basemem * PGSIZE)是可用的。</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</div><div class="line">        pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">        pages[i].pp_link = page_free_list;</div><div class="line">        page_free_list = &amp;pages[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3. IO空洞，绝对不能使用。</span></div><div class="line">    <span class="comment">//    链表直接跳过。不管。</span></div><div class="line"></div><div class="line">    <span class="comment">// 4. 直接找到kernel内存的尾巴</span></div><div class="line">    <span class="comment">//    注意这里取了PADDR之后要除PGSIZE.</span></div><div class="line">    <span class="keyword">for</span> (i = PADDR(boot_alloc(<span class="number">0</span>))/PGSIZE; i &lt; npages; i++) &#123;        </div><div class="line">        pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">        pages[i].pp_link = page_free_list;</div><div class="line">        page_free_list = &amp;pages[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc"></a>page_alloc</h2><p>page_alloc的功能就是从链表中分配一页。这里需要完全照着注释来实现。比如<code>pp_link</code>要设置为空。<code>pp_ref</code>不要去修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> PageInfo *</span></div><div class="line"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">struct</span> PageInfo *ret = page_free_list;</div><div class="line">    <span class="keyword">if</span> (!page_free_list) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    page_free_list = ret-&gt;pp_link;</div><div class="line">    ret-&gt;pp_link = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</div><div class="line">        <span class="built_in">memset</span>(page2kva(ret), <span class="number">0</span>, PGSIZE);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-free"><a href="#page-free" class="headerlink" title="page_free"></a>page_free</h2><p>这里会把一个<code>pp_ref</code>为0的页表放回到链表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></div><div class="line">    assert(!pp-&gt;pp_ref);</div><div class="line">    assert(!pp-&gt;pp_link);</div><div class="line"></div><div class="line">    pp-&gt;pp_link = page_free_list;</div><div class="line">    page_free_list = pp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Excersize-3"><a href="#Excersize-3" class="headerlink" title="Excersize 3"></a>Excersize 3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">　　xp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。</div><div class="line">　　info registers -- 展示所有内部寄存器的状态。</div><div class="line">　　info mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</div><div class="line">　　info pg -- 展示当前页表的结构。</div></pre></td></tr></table></figure>
<h1 id="Excersize-4"><a href="#Excersize-4" class="headerlink" title="Excersize 4"></a>Excersize 4</h1><h2 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h2><p><code>pgdir_walk</code>只是在给定的页表中查一下虚拟地址的<strong>页目录项</strong>。并不需要页目录项与虚拟地址绑定。如果存在页目录项，那么只需要直接返回相应的页目录项。<br>就是在写<code>if/else</code>的时候要考虑各种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pte_t</span> *</div><div class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    assert(pgdir);</div><div class="line">    <span class="keyword">pde_t</span> *pde = &amp;pgdir[PDX(va)];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(*pde &amp; PTE_P)) &#123;</div><div class="line">        <span class="keyword">if</span> (!create) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> PageInfo *page = page_alloc(ALLOC_ZERO);</div><div class="line">        <span class="keyword">if</span> (!page) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        page-&gt;pp_ref++;</div><div class="line">        assert(page-&gt;pp_ref == <span class="number">1</span>);</div><div class="line">        assert(page-&gt;pp_link == <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        *pde = page2pa(page) | PTE_P | PTE_U | PTE_W;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取页表项</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">pte_t</span>*)(KADDR(PTE_ADDR(*pde))) + PTX(va);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region"></a>boot_map_region</h2><p>把一个虚拟内存映射一个物理内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; size; i += PGSIZE) &#123;</div><div class="line">        <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="keyword">const</span> <span class="keyword">void</span> *)va, <span class="literal">true</span>);</div><div class="line">        *pte = pa | perm | PTE_P;</div><div class="line">        va += PGSIZE;</div><div class="line">        pa += PGSIZE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的设置。</p>
<h2 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert"></a>page_insert</h2><p>写这个函数的时候，要特别仔细地把注释读一下。<code>boot_map_region</code>在映射的时候。<br>并没有考虑到页表的占用释放回收什么的（直接把这个空间里面的物理内存映射到了<code>kern_pgdir</code>里面），这是因为<code>boot_map_region</code>这个函数操作的都是已经在kernel里面申请好的内存。并且页表的管理是从<code>boot_alloc(0)</code>之后才开始管理的。所以内核里面的页在添加到的<code>kernel_pgdir</code>的时候并不会用<code>PageInfo</code>来进行管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (!pte)</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">    pp-&gt;pp_ref++;</div><div class="line">    <span class="keyword">if</span> (*pte &amp; PTE_P)</div><div class="line">        page_remove(pgdir, va);</div><div class="line">    *pte = page2pa(pp) | perm | PTE_P;</div><div class="line">    tlb_invalidate(pgdir, va);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a>page_lookup</h2><p>这个函数的功能就是给定一个虚拟地址。然后根据这个虚拟地址来找到相应的物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> PageInfo *</span></div><div class="line"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">if</span> (!pte || !(*pte &amp; PTE_P)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (pte_store) *pte_store = pte;</div><div class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove"></a>page_remove</h2><p><code>page_remove</code>这个函数的功能主要是取消虚拟地址与物理地址的关联。<br>这里需要注意的是。释放了虚拟内存与物理内存的映射之后。并没有直接把相应的物理内存直接放到链表里面。这主要是因为，可能存在多个虚拟内存映射到同一个物理内页面的情况。虽然这个虚拟内存不在与这个物理内存发生联系了。但是其他的虚拟地址还是有可能继续与这个物理内存关联并且还在使用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> PageInfo *pp = page_lookup(pgdir, va, &amp;pte);</div><div class="line">    <span class="keyword">if</span> (!pp) <span class="keyword">return</span>;</div><div class="line">    *pte = <span class="number">0</span>;</div><div class="line">    page_decref(pp);</div><div class="line">    tlb_invalidate(pgdir, va);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Excersize-5"><a href="#Excersize-5" class="headerlink" title="Excersize 5"></a>Excersize 5</h2><p>mem_init()</p>
<p>这里主要是要把内核里面一些区域设置到页目录中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// 注意这里用的是PTSIZE</span></div><div class="line"><span class="comment">// 一种保守的作法是把pages align到页大小之后再进行映射。</span></div><div class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></div><div class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></div><div class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></div><div class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></div><div class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></div><div class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></div><div class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);    </div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></div><div class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></div><div class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></div><div class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></div><div class="line"><span class="comment">// we just set up the mapping anyway.</span></div><div class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// KERNBASE    0x F0000000</span></div><div class="line"><span class="comment">// 2^32 =      0x 1000 0000</span></div><div class="line"><span class="comment">// 256MB</span></div><div class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0x10000000</span>, <span class="number">0</span>, PTE_W);</div></pre></td></tr></table></figure>
<p>接下来还有一系列小问题。比如</p>
<h3 id="kern-pgdir里面的内容是什么？"><a href="#kern-pgdir里面的内容是什么？" class="headerlink" title="kern_pgdir里面的内容是什么？"></a>kern_pgdir里面的内容是什么？</h3><p>这个问题其实只需要看一下<code>mem_init</code>里面的<code>boot_map_region</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</div><div class="line">Entry    Base Virtual Address    Points to (logically):</div><div class="line">1023    ?    Page table for top 4MB of phys memory</div><div class="line">1022    ?    ?</div><div class="line">.    ?    ?</div><div class="line">.    ?    ?</div><div class="line">.    ?    ?</div><div class="line">2    0x00800000    ?</div><div class="line">1    0x00400000    ?</div><div class="line">0    0x00000000    [see next question]</div></pre></td></tr></table></figure>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
<p>这个问题是因为页表里面有各种保护机制。</p>
<h3 id="最大能支持的内存是多少？"><a href="#最大能支持的内存是多少？" class="headerlink" title="最大能支持的内存是多少？"></a>最大能支持的内存是多少？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</div><div class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</div><div class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</div><div class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</div><div class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</div></pre></td></tr></table></figure>
<p>这里UPAGES对应的就是<code>pages</code>这个链表。程序空间在利用虚拟地址访问<code>pages</code>的时候。一旦大于<code>4MB</code>，比如越界到了<code>UVPT</code>这个空间。由于这部分虚拟地址是放到了<code>kern_pgdir</code>里面。所以这个时候超出的部分就不能访问了。也就意味着：物理空间上，<code>pages</code>占用多大空间都没有问题。但是虚拟地址空间在访问<code>UPAGES</code>的时候就是不能访问全。因此，能支持的内存大小就变成了2GB。</p>
<h3 id="How-much-space-overhead-is-there-for-managing-memory-if-we-actually-had-the-maximum-amount-of-physical-memory-How-is-this-overhead-broken-down"><a href="#How-much-space-overhead-is-there-for-managing-memory-if-we-actually-had-the-maximum-amount-of-physical-memory-How-is-this-overhead-broken-down" class="headerlink" title="How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?"></a>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</h3><p>这里是说现在管理内存的开销是多少？其实直接看虚拟地址就可以明白了。一个页目录表占用4MB。而<code>UPAGES</code>占用了4MB。所以合在一起就是8MB。如果要减小开销。</p>
<h3 id="内存访问的问题"><a href="#内存访问的问题" class="headerlink" title="内存访问的问题"></a>内存访问的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Q1. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE?</div><div class="line"></div><div class="line">Q2. What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</div></pre></td></tr></table></figure>
<p>Q1. 当还在利用<code>kern/entry.S</code>和<code>kern/entrypgdir.c</code>的时候。一打开分页的时候，EIP还在一个低端的物理地址上。是通过什么方式让EIP跑到<code>KERNBASE</code>之上的内核虚拟地址空间运行的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    mov    $relocated, %eax</div><div class="line">    jmp    *%eax</div><div class="line">relocated:</div><div class="line"></div><div class="line">    # Clear the frame pointer register (EBP)</div><div class="line">    # so that once we get into debugging C code,</div><div class="line">    # stack backtraces will be terminated properly.</div><div class="line">    movl    $0x0,%ebp            # nuke frame pointer</div></pre></td></tr></table></figure>
<p>Q2. 问的是说，实际上当打开分页的时候，EIP还是在低地址运行。然后再通过跳转跑到高端地址。打开分页的时候，EIP指向下一条指令。即｀move $relocated, %eax`的内存地址。为什么访问这个内存地址不会失败?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> kern/entrypgdir.c 中将 0 ~ 4MB 和 KERNBASE ~ KERNBASE + 4 MB 的虚拟地址都映射到了 0 ~ 4MB 的物理地址上，因此无论 EIP 在高位和低位都能执行。必需这么做是因为如果只映射高位地址，那么在开启分页机制的下一条语句就会crash。</div><div class="line">`</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab2" data-title="MIT 6.828 Lab2" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/jos-lab1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/15/mit.6.828/jos-lab1/" class="article-date">
  	<time datetime="2018-04-14T21:28:32.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/15/mit.6.828/jos-lab1/">MIT 6.828 Lab1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原地址：</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="external">lab1</a><br>开坑。无视我的渣渣翻译。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验主要是分为三个部分。</p>
<ul>
<li>第一部分主要是需要熟悉x86的汇编语言，QEMU x86模拟器，以及PC上电之后的启动流程。</li>
<li>第二部分是验证6.828内核的boot loader，这里部分需要看的代码主要是位于boot目录。</li>
<li>第三部分主要是开始实施JOS操作系统。也就是MIT 6.828的内核部分。</li>
</ul>
<h2 id="软件的设置"><a href="#软件的设置" class="headerlink" title="软件的设置"></a>软件的设置</h2><p>首先我的环境是沿用了Linux-2.6.26内核调试环境搭建 里面的环境。<br>这里原来的网页讲了很多MIT学校里面上机环境。这部分没有必要去搞。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir ~/6.828</div><div class="line"><span class="built_in">cd</span> ~/6.828</div><div class="line">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2017/jos.git lab</div><div class="line"><span class="built_in">cd</span> lab</div></pre></td></tr></table></figure>
<h1 id="第一部分-PC-Bootstrap"><a href="#第一部分-PC-Bootstrap" class="headerlink" title="第一部分: PC Bootstrap"></a>第一部分: PC Bootstrap</h1><p>这个练习的作用完全是为了让你熟悉一下x86的汇编语言。以及PC启动的流程。并且可以熟练地使用QEMU/QEMU和GDB来调试了。在这里的实验里面你并不需要写任何的代码。但是需要有足够的理解来回答相应的问题。</p>
<p>Getting Started with x86 assembly<br>如果你对x86平台的汇编语言如果不是特别熟悉的话，可以使用这本书快速熟悉起来。 PC Assembly Language Book 这本书是一个不错的开始。因为里面包含了很多经典的和新的材料。</p>
<p>注意：这本书用的汇编语法是采用的NASM。但是在后面做实验的过程却是需要使用GAS语法。也就是AT &amp; T的语法。 Brennan’s Guide to Inline Assembly。</p>
<p>介绍了一些关于内联汇编需要注意的地方。关于内联汇编，可以看下面两本书</p>
<ul>
<li>Linux内核完全剖析 赵炯</li>
<li>Linux内核情景分析</li>
</ul>
<p>这两本书里面都讲到了C语言里面会用到的内联汇编。实际上，除此之外，也可以看一下xv6的代码。然后注意一下里面inline assemble的写法。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h2><p>这里主要是为了熟悉硬件&amp;汇编的。所以并不做过多的介绍。只是把资源记在这里面。</p>
<ul>
<li>the 6.828 reference page 提供了各种关于汇编的资料。</li>
<li>推荐阅读 in Brennan’s Guide to Inline Assembly. 内联汇编语法。</li>
<li>短一点的关于80386硬件特性 80386 Programmer’s Reference Manual</li>
<li>X86详细的架构信息 IA-32 Intel Architecture Software Developer’s Manuals<br>太长了。后面有时间再去翻这些本来是用来查的工具书。</li>
</ul>
<p><strong>Simulating the x86</strong></p>
<p>在作业里面并没有使用真实的PC，而是使用的是QEMU的模拟器。通过这个模拟器，可以很方便地与GDB一起合作，打断点什么的。Linux-2.6.26内核调试环境搭建  这里面已经上手玩过一次了。</p>
<p>在6.828里面，主要还是继续使用QEMU。一个现代的模拟器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># cd lab</span></div><div class="line"><span class="comment"># make</span></div><div class="line">+ as kern/entry.S</div><div class="line">+ cc kern/entrypgdir.c</div><div class="line">+ cc kern/init.c</div><div class="line">+ cc kern/console.c</div><div class="line">+ cc kern/monitor.c</div><div class="line">+ cc kern/printf.c</div><div class="line">+ cc kern/kdebug.c</div><div class="line">+ cc lib/printfmt.c</div><div class="line">+ cc lib/readline.c</div><div class="line">+ cc lib/string.c</div><div class="line">+ ld obj/kern/kernel</div><div class="line">+ as boot/boot.S</div><div class="line">+ cc -Os boot/main.c</div><div class="line">+ ld boot/boot</div><div class="line">boot block is 380 bytes (max 510)</div><div class="line">+ mk obj/kern/kernel.img</div></pre></td></tr></table></figure>
<p><strong>注意</strong> (由于我的实验环境采用的是32位的系统，不会存在这个问题。)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(If you get errors like <span class="string">"undefined reference to `__udivdi3'"</span>, you probably don<span class="string">'t have the 32-bit gcc multilib. If you'</span>re running Debian or Ubuntu, try installing the gcc-multilib package.)</div></pre></td></tr></table></figure>
<p>当make执行完成之后，运行结果就会生成obj/kern/kernel.img磁盘文件。利用这个虚拟的磁盘来启动一个PC。<br>仅管这里提供两种方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">make qemu</div></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">make qemu-nox</div></pre></td></tr></table></figure>
<p>尽量还是使用<code>make qemu-nox</code>，因为这种方式，在没有桌面环境的情况下也是可以正常工作的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># make qemu-nox</div><div class="line">Booting from Hard Disk...</div><div class="line">6828 decimal is XXX octal!</div><div class="line">entering test_backtrace 5</div><div class="line">entering test_backtrace 4</div><div class="line">entering test_backtrace 3</div><div class="line">entering test_backtrace 2</div><div class="line">entering test_backtrace 1</div><div class="line">entering test_backtrace 0</div><div class="line">leaving test_backtrace 0</div><div class="line">leaving test_backtrace 1</div><div class="line">leaving test_backtrace 2</div><div class="line">leaving test_backtrace 3</div><div class="line">leaving test_backtrace 4</div><div class="line">leaving test_backtrace 5</div><div class="line">Welcome to the JOS kernel monitor!</div><div class="line">Type &apos;help&apos; for a list of commands.</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>如果想要退出Qemu，那么只需要执行： <code>Ctrl+a x</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">There are only two commands you can give to the kernel monitor, <span class="built_in">help</span> and kerninfo.</div><div class="line">K&gt; <span class="built_in">help</span></div><div class="line"><span class="built_in">help</span> - display this list of commands</div><div class="line">kerninfo - display information about the kernel</div><div class="line">K&gt; kerninfo</div><div class="line">Special kernel symbols:</div><div class="line">  entry  f010000c (virt)  0010000c (phys)</div><div class="line">  etext  f0101a75 (virt)  00101a75 (phys)</div><div class="line">  edata  f0112300 (virt)  00112300 (phys)</div><div class="line">  end    f0112960 (virt)  00112960 (phys)</div><div class="line">Kernel executable memory footprint: 75KB</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>仅管看起来很简单。但是实际上这里面生成的<code>obj/kern/kernel.img</code>文件是可以放到真实的物理硬件上来执行的。</p>
<p><strong>批注</strong>：上面的内容其实动手的部分不多。大部分还是要求去熟悉汇编。怎么讲呢？最好的还是用到的时候再学吧。</p>
<h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>接下来会介绍PC的启动。一个PC的物理地址空间可以分成以下组成。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">We will now dive into a bit more detail about how a PC starts up. A PC<span class="string">'s physical address space is hard-wired to have the following general layout:</span></div><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |   64KB</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |    128KB</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure></p>
<p>为了兼容性的考虑。PC在一开始是16位的。但是地址线却有20位。也就是能够寻址1MB的地址空间。其中640KB为低端内存。<br>这段内容非常重要，所以需要好好注意。Lab2内存分配的时候会用到这个。<br>除去低端的640KB。那么1MB还留下 <code>1024KB - 640KB = 384KB</code>。这<code>384KB</code>的范围就是<br><code>0x000A0000 ~ 0x000FFFFF</code>。</p>
<p>其中BIOS占掉了顶端的<code>64KB</code>的内存。尽管后来内存从1MB前进到了16MB，后来又进展到了4GB。但是PC的内存布局还是没有改变。主要是为了兼容性考虑。因此，32位的CPU在这里还是会有个洞。<code>0x000A0000 〜 0x00100000</code>。</p>
<p>原本低端内存可以连续的1MB，变成了两段</p>
<ul>
<li>0~640KB，</li>
<li>然后1MB〜更高的内存。</li>
</ul>
<p>即</p>
<ul>
<li>“conventional memory” (the first 640KB) </li>
<li>“extended memory” 1MB以上</li>
</ul>
<p>最新的x86架构可以支持4GB以上的物理内存了。所以RAM也可以扩展到0xFFFFFFFF以上的地址。在这种情况下BIOS需要设置第二个洞。也就是在32位地址的顶端。但是JOS目前来说，只是支持256MB的物理内存。所以这里设计时只考虑到了具有32位地址的地址空间的情况。</p>
<h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>接下来的操作里面，你会用到QEMU的debug功能来深入了解IA-32计算机的启动流程。<br>需要做以下事情：<br>打开两个termainal</p>
<p>一个窗口运行<code>make qemu-nox-gdb</code><br>另外一个窗口运行<code>make gdb</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># make gdb</span></div><div class="line">GNU gdb (GDB) 6.8-debian</div><div class="line">Copyright (C) 2008 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"i486-linux-gnu"</span>.</div><div class="line">+ target remote localhost:26000</div><div class="line">The target architecture is assumed to be i8086</div><div class="line">[f000:fff0] 0xffff0:    ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></div><div class="line">0x0000fff0 <span class="keyword">in</span> ?? ()</div><div class="line">+ symbol-file obj/kern/kernel</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>这里能够通过gdb一下子就连接上来，这是因为提供了一个<code>.gdbinit</code>文件，能够自动地attach到想要调试的程序上来。当然前提是已经把这个debug的程序运行起来的情况。<br>第一条要执行的指令就是<code>ljmp</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[f000:fff0] 0xffff0:    ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></div></pre></td></tr></table></figure>
<p>从这个要执行的指令可以看出来。</p>
<p>IBM PC开始执行的物理位置是<code>0x000ffff0</code>。这个是位于1MB里面的很高的地址。也就是ROM BIOS最顶上<code>64KB</code>的顶部。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[f000:fff0]可以看出来，此时CS = 0xf000 and IP = 0xfff0.</div></pre></td></tr></table></figure>
<p>如果执行完这条指令之后 <code>CS = 0xf000 and IP = 0xe05b</code>.<br>为什么QEMU一开始执行的时候是这样的？这是因为8088的芯片就是这样的。<br>在IBM最原始的PC就是这么使用的。总之一句话，当PC上电之后。CS:IP两个寄存器就强制被设置为这个值。<code>CS = 0xf000 and IP = 0xfff0</code>。</p>
<p>注意16位的寻址模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">: physical address = 16 * segment + offset. </div><div class="line">16 * 0xf000 + 0xfff0   <span class="comment"># in hex multiplication by 16 is</span></div><div class="line">   = 0xf0000 + 0xfff0     <span class="comment"># easy--just append a 0.</span></div><div class="line">   = 0xffff0</div></pre></td></tr></table></figure>
<p>1MB尾巴上的地址就是<code>0xffff0 + 16bytes</code>。除了放个ljmp之外，你也不要指望16bytes能做啥了。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h2><p>用gdb的si指令来单步执行。看一下在启动的时候都做了些什么。可能需要查看的资料是<code>Phil Storrs I/O Ports Description</code> in <code>6.828 reference materials page</code>.</p>
<p>不需要非常详细，只需要大概了解一下就可以了。</p>
<ul>
<li>当BIOS在运行的时候。会在内存的超始地址处建立一个各种设备的16位的中断向量表，并且初始化各种设备。利用这个中断向量表，就可以成功输出”Start SeaBIOS”这种信息。</li>
<li>当各种初始化的硬件设备工作做完之后。BIOS就开始找启动设备，最终会在硬盘的起始sector里面找0x55, 0xaa这标志位的扇区。如果有，就加载到0x7c00处开始运行。也就是(31KB)的位置。</li>
</ul>
<h1 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h1><p>软盘和磁盘一般都是被切分为512 byte区域，也就是扇区。一个扇区是一个块设备的最小传输单位。每次读写都是必须是扇区的整数倍。<br>如果这个软盘或者磁盘是可启动的。那么第一个扇区被叫做可启动扇区。这里也存放的就是可启动的代码。当BIOS找到这个扇区的时候，就把这512 byte读到0x7c00至0x7cff。然后用一个跳转指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ljmp 0x07c0:0000</div></pre></td></tr></table></figure>
<p>对于CD-ROM的支持，需要看 “El Torito” Bootable CD-ROM Format Specification.<br>对于6.828来说，由于完全是使用硬盘来启动的。所以在硬盘的开始必须是boot loader，并且这个boot loader必须是512 bytes大小。<br>这个boot loader主要是由两个文件构成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">boot/boot.S</div><div class="line">boot/main.c</div></pre></td></tr></table></figure>
<p>这里需要好好地读一下这个文件。然后知道这两个文件做了些啥。<br>boot loader把模式切到了32位保护模式。因为只有在这种模式下软件才可以访问1MB+以上的内存空间。保护模式在<code>1.2.7</code> and <code>1.2.8</code> of <code>PC Assembly Language</code> 进行了介绍。 <code>Intel architecture manuals</code>也对这个有详细介绍。</p>
<p>在16位模式下只需要考虑段地址。<br>其次，需要注意的是<code>boot loader</code>读了kernel。从硬盘到内存。在操作的时候走的是PC的寄存器操作。如果想要了解更多，可以读一下<code>&quot;IDE hard drive controller&quot;</code> in  <code>the 6.828 reference page</code>.的这一部分。</p>
<p>当你理解了<code>boot loader</code>的源码之后。接下来可以看一下<code>obj/boot/boot.asm</code>。b *0x7c00<code>就可以把断点设置在</code>0x7c00`。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">b *0x7c00 <span class="comment"># 设置断点在0x7c00</span></div><div class="line">si 表示单步执行</div><div class="line">si 2 表示接着执行两条指令</div><div class="line">c 表示不再单步执行。直接开始运行了</div></pre></td></tr></table></figure>
<p>查看内存中的指令，有时候可能需要查看内存操作的结果。这个时候需要用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">x/i 调试命令</div><div class="line">x/Ni 基中N是指令的数目; 会把指定内存里面的指令翻译成汇编。</div></pre></td></tr></table></figure>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h2><p>特别需要注意看一下<code>lab tools guide</code>。里面介绍了很多<code>GDB</code>命令的<code>section</code>。这些命令对于开发操作系统特别有帮助。<br>在<code>0x7c00</code>这里设置一个断点。这个位置是启动扇区被加载到的内存位置。持续执行，一直跑到那个断点那里（按一下c就可以一直跑到断点那里了 ）。大概看一下<code>boot/boot.S</code>里面的代码。并且注意看一下<code>obj/boot/boot.asm</code>来跟踪当前所处的位置。</p>
<p>也可以用<code>x/i</code>命令来查看内存里面的汇编指令。并且与原本的<code>boot loader</code> 里面的代码进行比较。</p>
<p>接下来就可以通过<code>bootmain函数</code>进入到<code>boot/main.c</code>里面。然后开始执行<code>readsect函数</code>。注意<code>readsect</code>里面的汇编指令。一路跟踪<code>readsect函数</code>的执行，然后回到<code>bootmain函数</code>。</p>
<p>一直到读完余下的磁盘上的内核扇区。找出当循环结之后，会跳到哪里去执行？（肯定是跳到内核的第一条指令那里开始执行了）需要在那里设置一个断点。</p>
<p>接下来就需要回答如下问题：<br><strong>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">Q: 在哪里CPU开始进入到<span class="number">32</span>位模式。</div><div class="line">   哪条指令是带来了<span class="number">16</span>位到<span class="number">32</span>位的切换。</div><div class="line">A: </div><div class="line">movl    %eax, %cr0</div></pre></td></tr></table></figure>
<p>这条指令把cr0寄存器的最后一位，即PE位打开。也就是开启了保护模式。<br>CPU也就从这里开始进入到了32位模式。</p>
<p>只不过必须要清空一下流水线。这是规定。<br>所以接下来需要进入到32位的时候。<br>就需要用一个长跳转来进入到32位的代码那里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Jump to next instruction, but in 32-bit code segment.</div><div class="line"># Switches processor into 32-bit mode.</div><div class="line">ljmp    $PROT_MODE_CSEG, $protcseg</div></pre></td></tr></table></figure>
<p>需要注意的是，在长跳转的时候，<br>这个段描述符已经指向了代码段<code>$PROT_MODE_CSEG</code>。</p>
<p>也就是<code>lgdt</code>已经是设置好的。</p>
<p><strong>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Q: boot loader执行的最后一条指令是什么？kernel执行的第一条指令是什么？</div><div class="line">A:</div><div class="line"></div><div class="line">这个最简单的办法是打开obj/boot/boot.asm。找到bootmain函数的最后一条指令就可以了。</div><div class="line"></div><div class="line">        // call the entry point from the ELF header</div><div class="line">        // note: does not <span class="built_in">return</span>!</div><div class="line">        ((void (*)(void)) (ELFHDR-&gt;e_entry))();</div><div class="line">    7d61:       ff 15 18 00 01 00       call   *0x10018</div></pre></td></tr></table></figure>
<p>就是main.c中这个代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>
<p>Where is the first instruction of the kernel?<br>内核的第一条指令位于kern/entry.S里面的第一条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">movw    $0x1234,0x472                   # warm boot</div></pre></td></tr></table></figure>
<p>也可以通过命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump <span class="_">-f</span> kernel</div><div class="line">kernel:     file format elf32-i386</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div></pre></td></tr></table></figure>
<p><strong>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Q: boot loader在加载kernel的时候，是如何决定有多少个扇区需要读取的？</div><div class="line">   这部分信息是如何确定？</div><div class="line"></div><div class="line">A: 详细的信息会涉及到较多的ELF头文件格式。</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">        <span class="comment">// 这里把ELF文件的头读到内存里面。</span></div><div class="line">        readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// is this a valid ELF?</span></div><div class="line">        <span class="comment">// 检查一下ELF头文件的magic是不是与指定的ELF的格式相等。</span></div><div class="line">        <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</div><div class="line">                <span class="keyword">goto</span> bad;</div><div class="line"></div><div class="line">        <span class="comment">// load each program segment (ignores ph flags)</span></div><div class="line">        <span class="comment">// ELF header里面指明了第一个program section header的位置。</span></div><div class="line">        <span class="comment">// 也指明了最后一个位置在哪里</span></div><div class="line">        <span class="comment">// [ph, end_of_program_header)</span></div><div class="line">        <span class="comment">// 这里面表明了每个程序段的大小以及位置。</span></div><div class="line">        ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">        eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">        <span class="keyword">for</span> (; ph &lt; eph; ph++)</div><div class="line">                <span class="comment">// p_pa是需要被加载的地址。</span></div><div class="line">                <span class="comment">// p_memsz指的是需要的物理内存的大小</span></div><div class="line">                <span class="comment">// p_offset指的是在逻辑上相对于整个文件头的偏移量。</span></div><div class="line">                <span class="comment">// 虽然这里p_memsz表示的时候需要占用的内存的大小。</span></div><div class="line">                <span class="comment">// 实际上也是磁盘上需要读取的数据量的大小。</span></div><div class="line">                readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line"></div><div class="line">        <span class="comment">// 当把内存加载到内存里面之后。开始从这里开始执行第一条指令。</span></div><div class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</div><div class="line"></div><div class="line">bad:</div><div class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</div><div class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">                <span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// pa表示的是内存地址开始放磁盘内容的地方。</span></div><div class="line"><span class="comment">// count表示需要读的内容的长度。</span></div><div class="line"><span class="comment">// offset表示相对程序文件头的偏移量。这个传进来的参数还没有考虑到</span></div><div class="line"><span class="comment">// kernel在磁盘便移量。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">uint32_t</span> end_pa;</div><div class="line">        <span class="comment">// pa是开始放内容的内存起始地址</span></div><div class="line">        <span class="comment">// end_pa是指末尾地址</span></div><div class="line">        end_pa = pa + count;</div><div class="line">        <span class="comment">// 操作的时候，起始地址取一个512byte对齐的边界</span></div><div class="line">        <span class="comment">// 比如，如果起始地址addr =256, 那么内存开始放的地址就是addr = 0</span></div><div class="line">        pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 注意，这里把offset修正过了。由于第一个扇区放的是</span></div><div class="line">        <span class="comment">// boot loader。所以内存实际上是从第2个扇区开始放的。</span></div><div class="line">        <span class="comment">// 如果代码要更加友好一点。应该改成。</span></div><div class="line">        <span class="comment">// kernel_start_sector = 1;</span></div><div class="line">        <span class="comment">// offset = (offset / SECTSIZE) + kernel_start_sector;</span></div><div class="line">        <span class="comment">// 这样代码就比较容易理解了。</span></div><div class="line">        offset = (offset / SECTSIZE) + <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 本来这里可以用不着一个扇区一个扇区读的。</span></div><div class="line">        <span class="comment">// 可以读得快一点的。linux kernel里面就是利用较</span></div><div class="line">        <span class="comment">// 复杂的代码来加速了这个读取过程。</span></div><div class="line">        <span class="keyword">while</span> (pa &lt; end_pa) &#123;</div><div class="line">                <span class="comment">// 这里把磁盘扇区，注意，这个时候offset表示的是哪个扇区</span></div><div class="line">                <span class="comment">// 把这个扇区的内容读到内存地址pa处。</span></div><div class="line">                readsect((<span class="keyword">uint8_t</span>*) pa, offset);</div><div class="line">                <span class="comment">// 读完之后，移动内存地址以及扇区。</span></div><div class="line">                pa += SECTSIZE;</div><div class="line">                offset++;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然作业里面有个问题没有被问到。但是实际上是值得自己思考的。那就是。如果自己在写代码的时候，写的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *p = a;</div></pre></td></tr></table></figure>
<p>编译链接之后，a和p都会有个地址。这个地址应该就是程序员看到的虚拟地址空间的地址。平时自己写C程序可以不用关心这个虚拟地址与物理地址的对应。因为操作系统会利用分页技术把这个虚拟地址与真实的物理地址做好相应的对应。<br>但是现在在写的是操作系统。什么都是需要自己来进行操作的。所以考虑的一点是。<br>如果在编译的时候，这个地址被设定为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">p = 0x00ffffa;</div></pre></td></tr></table></figure>
<p>但是整个kernel加载的虚拟地址是<code>0xF0100000</code>。</p>
<p>这个时候就需要认真想一想了。是不是加载到虚拟地址0xF0200000也可以？物理地址的设定是什么？</p>
<p>思路如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kernel在编译的时候，采用的虚拟地址是0xF0100000。</div><div class="line">这是是在链接定义文件</div><div class="line">kern/kernel.ld指定的链接的起始地址。</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab<span class="comment"># cat kern/kernel.ld</span></div><div class="line">    /* Link the kernel at this address: <span class="string">"."</span> means the current address */</div><div class="line">    . = 0xF0100000;</div><div class="line"></div><div class="line">    /* AT(...) gives the load address of this section, <span class="built_in">which</span> tells</div><div class="line">       the boot loader <span class="built_in">where</span> to load the kernel <span class="keyword">in</span> physical memory */</div><div class="line">    .text : AT(0x100000) &#123;</div><div class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>kernel在加载到的物理地址是<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#define ELFHDR          ((struct Elf *) 0x10000)</div></pre></td></tr></table></figure></p>
<p>这两者之间的映射关系与用户的用应程序没有什么实质上的差异。也是通过页表来实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kern/entrypgdir.c</div></pre></td></tr></table></figure>
<p>完成了内核页表的设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">__</span>attribute__((<span class="number">__</span>aligned__(PGSIZE)))</div><div class="line"><span class="keyword">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</div><div class="line">        <span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB) </span></div><div class="line">        [<span class="number">0</span>]</div><div class="line">                = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</div><div class="line">        <span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></div><div class="line">        [KERNBASE&gt;&gt;PDXSHIFT]</div><div class="line">                = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里把物理起始地址4MB以及0xF0000000这里的4MB都映射到物理地址的<code>[0, 4MB)</code></p>
<h1 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h1><p>接下来就可以仔细地看一下C语言里面的内容。这里主要是看<code>boot loader</code>里面的C语言。即<code>boot/main.c</code>。</p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h2><p>这里需要对C语言的指针非常熟悉。最好的C语言的引用书籍就是<code>《The C Programming Language》</code>。<br>除非你对C语言已经非常熟悉。那么不要错过这些内容。<br>在开始读<code>boot/main.c</code>的时候。<br>需要对ELF二进制格式有一定的了解。这是因为经过编译链接之后，生成的<code>obj/kern/kernel</code>内核映像是一个ELF格式的。 <code>&quot;Executable and Linkable Format&quot;</code>。</p>
<p>关于ELF有如下完整的信息。 <code>the ELF specification on our reference page</code>, 但是实际上你是没有必要仔细从头到尾地看这个文档。里面有很多复杂的部分是关于动态链接库的支持的。</p>
<p>对于6.828这门课来说，只需要解的是ELF执行格式里面有个头，里面包含了各种每个程序段的加载信息。通过这些加载信息可以把整个程序正确地加载到内存里面。boot loader并不会去修正里面指针的指向。只是把磁盘上的kernel映像加开到内存里面，然后开始执行之。</p>
<p>ELF程序文是由一个固定长度的ELF头开始的。紧接着的是一个动态可变的程序头list。每个程序头，指明了每个程序段需要被加载的位置，长度，相对于整个程序的偏移量。</p>
<p><strong>注意：相对的是整个程序头的偏移量，而不是相对于磁盘头的偏移量</strong></p>
<p>由于在编译完成之后，才会把kernel写入磁盘的某个扇区。在编译的时候是无法知道会被写入到哪个扇区的。所以编译的时候只能说把相对的位置写入到ELF里面。<br>这些各种程序头比较常见的有以下几个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">.text: The program<span class="string">'s executable instructions.</span></div><div class="line">.rodata: Read-only data, such as ASCII string constants produced by the C compiler. (We will not bother setting up the hardware to prohibit writing, however.)</div><div class="line">.data: The data section holds the program's initialized data, such as global variables declared with initializers like int x = 5;.</div></pre></td></tr></table></figure>
<p>当链接器在计算内存部局的时候，也会保留足够的空间给各种未初始化的全局变量（初始化为0）。一般而言这个空间被称之为.bss段。<br>由于全部都是被设置为0.所以也就没有必要记录这些内容在ELF里面。所以ELF文件里面只需要记住.bss在内存里面的起始位置，以及大小。然后加载方需要确保这些.bss在内存里面正确的设置。以及初始化为0。<br>可以通过如下命令来查看<code>obj/kern/kernel</code>里面的<code>names, sizes</code>, 以及各种链接地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -h obj/kern/kernel</div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         00001917  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       00000714  f0101920  00101920  00002920  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003889  f0102034  00102034  00003034  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div></pre></td></tr></table></figure>
<p>真正要了解这个文件，需要查看链接设定文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kern/kernel.ld</div></pre></td></tr></table></figure>
<p>通过这个文件可以知道程序被加载的虚拟地址(VMA)，物理地址(LMA)分别是如何指定的。也可以通过File off查看相对文件的偏移量。这个File off偏移量是如何指定的？这个非常有意思。刚好在boot/main.c里面就是一开始就读了了8个扇区，也就是<code>0x1000 bytes</code>。</p>
<h3 id="ELF文件格式简图"><a href="#ELF文件格式简图" class="headerlink" title="ELF文件格式简图"></a>ELF文件格式简图</h3><p>kernel在编译和链接的时候，其虚拟地址与物理地址是不一样的。在加载的时候，也就相应地需要设置好页表。</p>
<p>但是考虑一下<code>boot loader</code>。在加载的时候，肯定是没有什么页表等着给你用的。<code>BIOS</code>可不会给你设置页表。所以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -h obj/boot/boot.out</div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  <span class="comment"># 注意这里的VMA与LMA是完全一致的。这是由于被加载进BIOS的时候，没有页表与段表可用。</span></div><div class="line">  <span class="comment"># size = 380 bytes.</span></div><div class="line">  <span class="comment"># 这里面就包含了boot loader所需要的所有信息。</span></div><div class="line">  0 .text         0000017c  00007c00  00007c00  00000074  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, CODE</div><div class="line"></div><div class="line">  <span class="comment"># size = 176这个段实际上是没有什么用的？</span></div><div class="line">  1 .eh_frame     000000b0  00007d7c  00007d7c  000001f0  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  <span class="comment"># 接下来的三个段，里面都是用于DEBUG的。所以真实用的时候，不会被用到。</span></div><div class="line">  2 .stab         000007b0  00000000  00000000  000002a0  2**2</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  3 .stabstr      00000846  00000000  00000000  00000a50  2**0</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  4 .comment      0000002b  00000000  00000000  00001296  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line"></div><div class="line">$ objdump -x obj/boot/boot.out</div><div class="line">obj/boot/boot.out:     file format elf32-i386</div><div class="line">obj/boot/boot.out</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00007c00</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00000074 vaddr 0x00007c00 paddr 0x00007c00 align 2**2</div><div class="line">         filesz 0x0000022c memsz 0x0000022c flags rwx</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         0000017c  00007c00  00007c00  00000074  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, CODE</div><div class="line">  1 .eh_frame     000000b0  00007d7c  00007d7c  000001f0  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         000007b0  00000000  00000000  000002a0  2**2</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  3 .stabstr      00000846  00000000  00000000  00000a50  2**0</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  4 .comment      0000002b  00000000  00000000  00001296  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line">SYMBOL TABLE:</div><div class="line">00007c00 l    d  .text    00000000 .text</div><div class="line">00007d7c l    d  .eh_frame    00000000 .eh_frame</div><div class="line">00000000 l    d  .stab    00000000 .stab</div><div class="line">00000000 l    d  .stabstr    00000000 .stabstr</div><div class="line">00000000 l    d  .comment    00000000 .comment</div><div class="line">00000000 l    df *ABS*    00000000 obj/boot/boot.o</div><div class="line">00000008 l       *ABS*    00000000 PROT_MODE_CSEG</div><div class="line">00000010 l       *ABS*    00000000 PROT_MODE_DSEG</div><div class="line">00000001 l       *ABS*    00000000 CR0_PE_ON</div><div class="line">00007c0a l       .text    00000000 seta20.1</div><div class="line">00007c14 l       .text    00000000 seta20.2</div><div class="line">00007c64 l       .text    00000000 gdtdesc</div><div class="line">00007c32 l       .text    00000000 protcseg</div><div class="line">00007c4a l       .text    00000000 spin</div><div class="line">00007c4c l       .text    00000000 gdt</div><div class="line">00000000 l    df *ABS*    00000000 main.c</div><div class="line">00000000 l    df *ABS*    00000000</div><div class="line">00007c6a g     F .text    00000012 waitdisk</div><div class="line">00007d0a g     F .text    00000072 bootmain</div><div class="line">00007<span class="built_in">cd</span>1 g     F .text    00000039 readseg</div><div class="line">00007e2c g       .eh_frame    00000000 __bss_start</div><div class="line">00007c7c g     F .text    00000055 readsect</div><div class="line">00007e2c g       .eh_frame    00000000 _edata</div><div class="line">00007e2c g       .eh_frame    00000000 _end</div><div class="line">00007c00 g       .text    00000000 start</div></pre></td></tr></table></figure>
<p>为什么说只有text段是被使用到的呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">boot/Makefrag</div><div class="line"></div><div class="line">$(OBJDIR)/boot/boot: $(BOOT_OBJS)</div><div class="line">    @<span class="built_in">echo</span> + ld boot/boot</div><div class="line">    $(V)$(LD) $(LDFLAGS) -N <span class="_">-e</span> start -Ttext 0x7C00 -o <span class="variable">$@</span>.out $^ </div><div class="line">    $(V)$(OBJDUMP) -S <span class="variable">$@</span>.out &gt;<span class="variable">$@</span>.asm</div><div class="line">    $(V)$(OBJCOPY) -S -O binary -j .text <span class="variable">$@</span>.out <span class="variable">$@</span> <span class="comment"># 380 bytes</span></div><div class="line">    $(V)perl boot/sign.pl $(OBJDIR)/boot/boot</div></pre></td></tr></table></figure>
<p>boot loader自己是没有利用ELF格式的。需要用boot sector固定的格式。不过加载的时候，却是采用了ELF格式来加载内核。<br>如果要详细看一下kernel各个段的加载情况，可以通过如下命令：<br>需要注意program header与sections的区别。program header是给加载程序方用的。<br>section是给写程序的人以及与编译器看的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -x obj/kern/kernel</div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line">obj/kern/kernel</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</div><div class="line">         filesz 0x0000716c memsz 0x0000716c flags r-x</div><div class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</div><div class="line">         filesz 0x0000a300 memsz 0x0000a944 flags rw-</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         00001917  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       00000714  f0101920  00101920  00002920  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003889  f0102034  00102034  00003034  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line">SYMBOL TABLE:</div><div class="line">f0100000 l    d  .text    00000000 .text</div><div class="line">f0101920 l    d  .rodata    00000000 .rodata</div><div class="line">f0102034 l    d  .stab    00000000 .stab</div><div class="line">f01058bd l    d  .stabstr    00000000 .stabstr</div><div class="line">f0108000 l    d  .data    00000000 .data</div><div class="line">f0112300 l    d  .bss    00000000 .bss</div><div class="line">00000000 l    d  .comment    00000000 .comment</div><div class="line">00000000 l    df *ABS*    00000000 obj/kern/entry.o</div><div class="line">f010002f l       .text    00000000 relocated</div><div class="line">f010003e l       .text    00000000 spin</div><div class="line">00000000 l    df *ABS*    00000000 entrypgdir.c</div><div class="line">00000000 l    df *ABS*    00000000 init.c</div><div class="line">00000000 l    df *ABS*    00000000 console.c</div><div class="line">f01001a0 l     F .text    0000001c serial_proc_data</div><div class="line">f01001bc l     F .text    00000044 cons_intr</div><div class="line">f0112320 l     O .bss    00000208 cons</div><div class="line">f0100200 l     F .text    00000117 kbd_proc_data</div><div class="line">f0112300 l     O .bss    00000004 shift.1330</div><div class="line">f0101b00 l     O .rodata    00000100 shiftcode</div><div class="line">f0101a00 l     O .rodata    00000100 togglecode</div><div class="line">f01019e0 l     O .rodata    00000010 charcode</div><div class="line">f0100317 l     F .text    000001e0 cons_putc</div><div class="line">f0112528 l     O .bss    00000002 crt_pos</div><div class="line">f011252c l     O .bss    00000004 crt_buf</div><div class="line">f0112530 l     O .bss    00000004 addr_6845</div><div class="line">f0112534 l     O .bss    00000001 serial_exists</div><div class="line">f0112200 l     O .data    00000100 normalmap</div><div class="line">f0112100 l     O .data    00000100 shiftmap</div><div class="line">f0112000 l     O .data    00000100 ctlmap</div><div class="line">00000000 l    df *ABS*    00000000 monitor.c</div><div class="line">f0101de4 l     O .rodata    00000018 commands</div><div class="line">00000000 l    df *ABS*    00000000 printf.c</div><div class="line">f01008eb l     F .text    00000013 putch</div><div class="line">00000000 l    df *ABS*    00000000 kdebug.c</div><div class="line">f010094b l     F .text    000000dd stab_binsearch</div><div class="line">00000000 l    df *ABS*    00000000 printfmt.c</div><div class="line">f0100c10 l     F .text    000000ef printnum</div><div class="line">f0100cff l     F .text    0000001d sprintputch</div><div class="line">f0102008 l     O .rodata    0000001c error_string</div><div class="line">00000000 l    df *ABS*    00000000 readline.c</div><div class="line">f0112540 l     O .bss    00000400 buf</div><div class="line">00000000 l    df *ABS*    00000000 string.c</div><div class="line">00000000 l    df *ABS*    00000000</div><div class="line">f010000c g       .text    00000000 entry</div><div class="line">f0101337 g     F .text    00000020 strcpy</div><div class="line">f0100513 g     F .text    00000012 kbd_intr</div><div class="line">f010079f g     F .text    0000000a mon_backtrace</div><div class="line">f01000f8 g     F .text    0000005f _panic</div><div class="line">f010009d g     F .text    0000005b i386_init</div><div class="line">f01014d4 g     F .text    00000068 memmove</div><div class="line">f0101208 g     F .text    00000028 snprintf</div><div class="line">f0100d44 g     F .text    0000046c vprintfmt</div><div class="line">f0100525 g     F .text    0000004a cons_getc</div><div class="line">f0100931 g     F .text    0000001a cprintf</div><div class="line">f010153c g     F .text    00000021 memcpy</div><div class="line">f0101230 g     F .text    000000ca readline</div><div class="line">f0111000 g     O .data    00001000 entry_pgtable</div><div class="line">f0100040 g     F .text    0000005d test_backtrace</div><div class="line">f01011b0 g     F .text    00000058 vsnprintf</div><div class="line">f0112300 g       .data    00000000 edata</div><div class="line">f010056f g     F .text    000000f2 cons_init</div><div class="line">f01058bc g       .stab    00000000 __STAB_END__</div><div class="line">f01058bd g       .stabstr    00000000 __STABSTR_BEGIN__</div><div class="line">f01017c0 g     F .text    00000157 .hidden __umoddi3</div><div class="line">f01004f7 g     F .text    0000001c serial_intr</div><div class="line">f0101690 g     F .text    00000124 .hidden __udivdi3</div><div class="line">f0100682 g     F .text    0000000a iscons</div><div class="line">f01015b3 g     F .text    000000d3 strtol</div><div class="line">f0101318 g     F .text    0000001f strnlen</div><div class="line">f0101357 g     F .text    0000002b strcat</div><div class="line">f0112940 g     O .bss    00000004 panicstr</div><div class="line">f0112944 g       .bss    00000000 end</div><div class="line">f0100157 g     F .text    00000045 _warn</div><div class="line">f010146b g     F .text    0000001c strfind</div><div class="line">f0101917 g       .text    00000000 etext</div><div class="line">0010000c g       .text    00000000 _start</div><div class="line">f01013af g     F .text    0000003d strlcpy</div><div class="line">f0101412 g     F .text    00000038 strncmp</div><div class="line">f0101382 g     F .text    0000002d strncpy</div><div class="line">f010155d g     F .text    00000039 memcmp</div><div class="line">f0100661 g     F .text    00000010 cputchar</div><div class="line">f0101487 g     F .text    0000004d memset</div><div class="line">f0100671 g     F .text    00000011 getchar</div><div class="line">f0100d1c g     F .text    00000028 printfmt</div><div class="line">f010716b g       .stabstr    00000000 __STABSTR_END__</div><div class="line">f01013ec g     F .text    00000026 strcmp</div><div class="line">f0100a28 g     F .text    000001d9 debuginfo_eip</div><div class="line">f01008fe g     F .text    00000033 vcprintf</div><div class="line">f0110000 g       .data    00000000 bootstacktop</div><div class="line">f0110000 g     O .data    00001000 entry_pgdir</div><div class="line">f0108000 g       .data    00000000 bootstack</div><div class="line">f0102034 g       .stab    00000000 __STAB_BEGIN__</div><div class="line">f0101300 g     F .text    00000018 strlen</div><div class="line">f010144a g     F .text    00000021 strchr</div><div class="line">f01006d5 g     F .text    000000ca mon_kerninfo</div><div class="line">f01007a9 g     F .text    00000142 monitor</div><div class="line">f0101596 g     F .text    0000001d memfind</div><div class="line">f0100690 g     F .text    00000045 mon_help</div></pre></td></tr></table></figure>
<p>因此，这里可以看出来。program headers 就是写在ELF头里面给加载程序用的。但是这里主要关注：</p>
<ul>
<li>vaddr  加载后程序内部引用的各种虚拟地址基地址</li>
<li>paddr  加载到的物理基地址</li>
<li>memsz  这个程序段的大小</li>
<li>filesz 这个程序段所在位置起始位置。注意，这里是相对于文件头而言。 ！！</li>
</ul>
<p>这么四个变量。使用-x 输出太长了。虽然里面有些信息lab2会用到。不过对于lab1而言。只需要如下命令就可以理解了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -p obj/kern/kernel</div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</div><div class="line">         filesz 0x0000716c memsz 0x0000716c flags r-x</div><div class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</div><div class="line">         filesz 0x0000a300 memsz 0x0000a944 flags rw-</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div></pre></td></tr></table></figure>
<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h2><p>这里比较有意的是试一下修改boot/Makefrag文件中的-Ttext里面的起始地址。如果修改了起始地址。<br>如此一来。后面程序加载的地址就发生了变化。但是需要注意的是：如果指令里面都是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mov ax, bx</div><div class="line">mov cx, ax</div><div class="line">mov dx, ax</div></pre></td></tr></table></figure>
<p>这样的操作是不会出错的。随便改了加载地址，也可以随意进行加载。都可以work。<br>但是这样的操作就会出问题了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   jmp jump_addr</div><div class="line"></div><div class="line">addr_tag:</div><div class="line">    .db varname 0</div><div class="line"></div><div class="line">jump_addr:</div></pre></td></tr></table></figure>
<p>任何引用到<code>addr_tag</code>和<code>jump_addr</code>这两个地址的地方都会出错。所以一旦不对应之后。运行必然出错。<br>需要注意的是kernel的地址与<code>boot loader</code>则是不一样的。</p>
<h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h2><p>接下来需要利用GDB的x命令查看内存中的指令。 GDB manual 有各种详细的细节。<br>但是现在而言，只需要知道x/Nx addr命令就是为了查看从ADDR开始的N字的指令。需要注意的是：字长并不是完全统一的。在GNU汇编里面。一个字长是两个byte。比如xorw指令里面的w表示产的是两个byte。<br>重置机器。当刚进入boot loader的时候，检查在内存0x00100000开头的8个字。然后再当需要跳转到内核开始执行的时候，看一下里面的指令。为什么会不一样呢？<br>这个应该很简单了。在boot loader刚进来的时候， kernel还没有被加载到内存里面。<br>当需要跳转到内核的时候，kernel image已经被加载到了0x00100000地址处。</p>
<p><strong>What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># The Multiboot header</div><div class="line">.align 4</div><div class="line">.long MULTIBOOT_HEADER_MAGIC</div><div class="line">.long MULTIBOOT_HEADER_FLAGS</div><div class="line">.long CHECKSUM</div><div class="line"></div><div class="line"># &apos;_start&apos; specifies the ELF entry point.  Since we haven&apos;t set up</div><div class="line"># virtual memory when the bootloader enters this code, we need the</div><div class="line"># bootloader to jump to the *physical* address of the entry point.</div><div class="line">.globl          _start</div><div class="line">_start = RELOC(entry)</div><div class="line"></div><div class="line">.globl entry</div><div class="line">entry:</div><div class="line">        movw    $0x1234,0x472                   # warm boot</div><div class="line">kernel的开头就是entry.S。</div><div class="line">(gdb) x/8x 0x100000</div><div class="line">0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766</div><div class="line">0x100010:    0x34000004    0x0000b812    0x220f0011    0xc0200fd8</div></pre></td></tr></table></figure>
<p>开头的三个值刚好是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_HEADER_MAGIC (0x1BADB002)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_HEADER_FLAGS (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))</span></div></pre></td></tr></table></figure>
<h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><p><strong>1. Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</strong></p>
<p>Ｑ：用Qemu和GDB跳到JOS的内核里面。并且暂停在movl %eax, %cr0这条指令这里。验证内存两个地址：0x00100000 and at 0xf0100000。接下来用s指令一条一条地执行。然后再验证一下这个两个内存地址的内容。确保你理解整个发生的过程。</p>
<p>首先需要明白：程序地址与寻址地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 程序代码地址</div><div class="line">2. 支持的寻址地址</div></pre></td></tr></table></figure>
<p>如果支持的寻址地址不支持汇编里面的地址（比如页表没有建立起来）。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mov %eax, *$0xf0100000</div></pre></td></tr></table></figure>
<p>这个时候必须要知道0xf0100000真正的物理地址是什么。程序代码里直接成相应的物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    RELOC(x) ((x) - KERNBASE)</span></div></pre></td></tr></table></figure>
<p>示例1： kernel的入口地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># &apos;_start&apos; specifies the ELF entry point.  Since we haven&apos;t set up</div><div class="line"># virtual memory when the bootloader enters this code, we need the</div><div class="line"># bootloader to jump to the *physical* address of the entry point.</div><div class="line">.globl        _start</div><div class="line">_start = RELOC(entry)</div><div class="line"></div><div class="line">.globl entry</div><div class="line">entry:</div></pre></td></tr></table></figure>
<p>kernel在编译的时候是并不知道会被加载到哪里的。通过链接的时候kern/kernel.ld链接脚本可以指令被加载到的物理地址。但是程序的入口地址仍然需要告知ELF。<br>ELF执行的格式是<code>_start</code>是入口。如果不加任何处理，那么<code>_start</code>就是一个虚拟地址。这个值会反应在ELF header-&gt;e_entry值上面。(看boot/main.c)里面的跳转到内核的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// call the entry point from the ELF header</div><div class="line"> // note: does not return!</div><div class="line"> ((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>
<p>这里面<code>e_entry</code>就指向<code>_start</code>值。由于从<code>boot loader</code>跳转到的内核的时候，还在物理地址与虚拟地址完全重合的情况。并且也没有开启分页。所以这个时候必须在kern/entry.S里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.globl        _start</div><div class="line">_start = RELOC(entry)</div></pre></td></tr></table></figure>
<p>把<code>_start</code>地址改造成物理地址。这会儿，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab<span class="comment"># objdump -f obj/kern/kernel</span></div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div></pre></td></tr></table></figure>
<p>这个时候<code>start address</code>就是一个物理地址。</p>
<p><strong>原问题的正解</strong></p>
<p>首先对<code>entry.S</code>代码加以注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">       # Load the physical address of entry_pgdir into cr3.  entry_pgdir</div><div class="line">        # is defined in entrypgdir.c.</div><div class="line"></div><div class="line">这里把页表加载到cr3寄存器。注意加载的时候，这里是直接用的物理地址。</div><div class="line">页表还没有打开，当然是不能用到虚拟地址了。</div><div class="line"></div><div class="line">        movl    $(RELOC(entry_pgdir)), %eax</div><div class="line">f0100015:       b8 00 00 11 00          mov    $0x110000,%eax</div><div class="line">        movl    %eax, %cr3</div><div class="line">f010001a:       0f 22 d8                mov    %eax,%cr3</div><div class="line"></div><div class="line"># 开启分页模式</div><div class="line">        # Turn on paging.</div><div class="line">        movl    %cr0, %eax</div><div class="line">f010001d:       0f 20 c0                mov    %cr0,%eax</div><div class="line">        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</div><div class="line">f0100020:       0d 01 00 01 80          or     $0x80010001,%eax</div><div class="line">        movl    %eax, %cr0</div><div class="line">f0100025:       0f 22 c0                mov    %eax,%cr0</div></pre></td></tr></table></figure>
<p>所以原问题中在开启分页前去看<code>0xf0100000</code>地址时。肯定为0。因为在当前地址空间里面，这部分虚拟地址是没有内容的。页表也还没有。只能是假装去访问物理地址。<br>分页后去查看地址时。<code>0xf0100000</code>与<code>0x00100000</code>内容就完全一样了。这是因为把<code>[0, 4MB)</code>映射到了<code>[0xf0000000, 0xf0000000 + 4MB)</code>的地方了。<br>开启分页后的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">       # Now paging is enabled, but we&apos;re still running at a low EIP</div><div class="line">        # (why is this okay?).  Jump up above KERNBASE before entering</div><div class="line">        # C code.</div><div class="line">        mov     $relocated, %eax</div><div class="line">        jmp     *%eax</div><div class="line">relocated:</div></pre></td></tr></table></figure>
<p>当开启分页之后，立马会进行相应的跳转。这里主要是因为后面会开始执行C语言的函数了。必须设置好相应的CS:IP, esp, ebp, ss等寄存器。如果还是在物理地址空间运行。但是C语言是以为自己在虚拟地址空间运行的。</p>
<ul>
<li><ol>
<li>CPU跑在物理地址空间上，而不是虚拟地址空间上。（尽管CS:IP会被翻译到真正的地址。）</li>
</ol>
</li>
<li><ol>
<li>C语言认为是自己是跑在虚拟地址空间。</li>
</ol>
</li>
</ul>
<p>通过jmp，可以使得两者正常化。CPU在取指，寻址的时候，就会在有页映射的地址空间里面了。环境设置好，就可以开始跳转到C语言里面了。</p>
<p><strong>2. What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace into it, and see if you were right.</strong></p>
<p>这个问题其实也比较扯的。主要意思是说，如果把movl %eax, %cr0删除掉会发生什么样的情况。<br>删除掉之后，只要后面有涉及到寻址的地方，就会立马出错。假设把这一行注释掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    # movl    %eax, %cr0</div><div class="line"></div><div class="line">    # Now paging is enabled, but we&apos;re still running at a low EIP</div><div class="line">    # (why is this okay?).  Jump up above KERNBASE before entering</div><div class="line">    # C code.</div><div class="line">    mov    $relocated, %eax</div><div class="line">    jmp    *%eax</div><div class="line">relocated:</div><div class="line"></div><div class="line">    # Clear the frame pointer register (EBP)</div><div class="line">    # so that once we get into debugging C code,</div><div class="line">    # stack backtraces will be terminated properly.</div><div class="line">    movl    $0x0,%ebp            # nuke frame pointer</div><div class="line"></div><div class="line">    # Set the stack pointer</div><div class="line">    movl    $(bootstacktop),%esp</div></pre></td></tr></table></figure>
<p>那么在<code>movl $(bootstacktop), %esp</code>这里就立马出错了。</p>
<p>因为把<code>$bootstacktop</code>当成物理地址了。但是实际上，哪有那么大的物理地址空间。所以肯定会报错了。(万一真给了qemu那么大的物理地址空间，那边物理地址也没有内容，跳到C语言之后就会出错。)</p>
<h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><p><strong>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</strong></p>
<p>这里的意思是说，去修改程序，使得程序能够正确地输出%o。这里还是比较简单的，只需要参考一下%d的输出代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">root@debug:~/<span class="number">6.828</span>/lab<span class="meta"># git diff</span></div><div class="line">diff --git a/lib/printfmt.c b/lib/printfmt.c</div><div class="line">index <span class="number">28e01</span>c9.<span class="number">.1</span>d3a5fa <span class="number">100644</span></div><div class="line">--- a/lib/printfmt.c</div><div class="line">+++ b/lib/printfmt.c</div><div class="line">@@ <span class="number">-206</span>,<span class="number">10</span> +<span class="number">206</span>,<span class="number">13</span> @@ vprintfmt(<span class="keyword">void</span> (*putch)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *putdat, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</div><div class="line">                <span class="comment">// (unsigned) octal</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">                        <span class="comment">// Replace this with your code.</span></div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       <span class="keyword">break</span>;</div><div class="line">+                       num = getint(&amp;ap, lflag);</div><div class="line">+                       <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123;</div><div class="line">+                               putch(<span class="string">'-'</span>, putdat);</div><div class="line">+                               num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</div><div class="line">+                       &#125;</div><div class="line">+                       base = <span class="number">8</span>;</div><div class="line">+                       <span class="keyword">goto</span> number;</div><div class="line"></div><div class="line">                <span class="comment">// pointer</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</div></pre></td></tr></table></figure>
<p>然后运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ make</div><div class="line">$ make qemu-nox</div><div class="line">6828 decimal is 15254 octal!</div></pre></td></tr></table></figure>
<p>就会看到相应的输出了。</p>
<p><strong>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</strong></p>
<p>console.c与printf.c里面有什么样的接口？<br>console.c里面暴露了哪个端口给printf.c使用？<br>答：<br>这里分析过程如下：<br>printf.c里面的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar</div></pre></td></tr></table></figure>
<p>然后cputchar的声明是在<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">./inc/stdio.h:<span class="number">11</span>:<span class="function"><span class="keyword">void</span>    <span class="title">cputchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数的定义是在console.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cputchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">        cons_putc(c);</div><div class="line">&#125;</div><div class="line"><span class="comment">// output a character to the console</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">cons_putc</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">        serial_putc(c);</div><div class="line">        lpt_putc(c);</div><div class="line">        cga_putc(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下主要就是看<code>cga_putc</code>。也就是显示到屏幕上的函数。首先看一下<code>cga_init</code>。这个函数的功能就是选定特定的屏幕。比如<code>vga, cga</code>等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">uint16_t</span> *cp;</div><div class="line">        <span class="keyword">uint16_t</span> was;</div><div class="line">        <span class="keyword">unsigned</span> pos;</div><div class="line"></div><div class="line">        cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + CGA_BUF);</div><div class="line">        was = *cp;</div><div class="line">        *cp = (<span class="keyword">uint16_t</span>) <span class="number">0xA55A</span>;</div><div class="line">        <span class="keyword">if</span> (*cp != <span class="number">0xA55A</span>) &#123;</div><div class="line">                cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + MONO_BUF);</div><div class="line">                addr_6845 = MONO_BASE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                *cp = was;</div><div class="line">                addr_6845 = CGA_BASE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Extract cursor location */</span></div><div class="line">        outb(addr_6845, <span class="number">14</span>);</div><div class="line">        pos = inb(addr_6845 + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>;</div><div class="line">        outb(addr_6845, <span class="number">15</span>);</div><div class="line">        pos |= inb(addr_6845 + <span class="number">1</span>);</div><div class="line"></div><div class="line">        crt_buf = (<span class="keyword">uint16_t</span>*) cp;</div><div class="line">        crt_pos = pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，显示操作的时候，启动的时候，都是使用提<code>CGA</code>。也就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">./kern/console.h:<span class="number">14</span>:<span class="meta">#<span class="meta-keyword">define</span> CGA_BUF        0xB8000</span></div></pre></td></tr></table></figure>
<p>初始化的时候，需要设定光标的位置。设置完成之后。就可以利用<code>cga_putc</code>来CGA屏幕上显示字符了。这里可以看出来，除了各个字符的设定之外。还随时移动的光标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="comment">// if no attribute given, then use black on white</span></div><div class="line">        <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</div><div class="line">                c |= <span class="number">0x0700</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>:</div><div class="line">                <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</div><div class="line">                        crt_pos--;</div><div class="line">                        crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">' '</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</div><div class="line">                crt_pos += CRT_COLS;</div><div class="line">                <span class="comment">/* fallthru */</span></div><div class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</div><div class="line">                crt_pos -= (crt_pos % CRT_COLS);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">                crt_buf[crt_pos++] = c;         <span class="comment">/* write the character */</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// What is the purpose of this?</span></div><div class="line">        <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">                <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">                memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">                <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">                        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line">                crt_pos -= CRT_COLS;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* move that little blinky thing */</span></div><div class="line">        outb(addr_6845, <span class="number">14</span>);</div><div class="line">        outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</div><div class="line">        outb(addr_6845, <span class="number">15</span>);</div><div class="line">        outb(addr_6845 + <span class="number">1</span>, crt_pos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Explain the following from <code>console.c</code>:</strong></p>
<p>这段代码的作用就是在当写满一个屏幕的时候，把整个字符串往上滚动一行。<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一页写满，滚动一行。</span></div><div class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 把从第1~n行的内容复制到0~(n-1)行，第n行未变化</span></div><div class="line">    <span class="comment">// 通过这一行代码完成了整个屏幕向上移动一行的操作。</span></div><div class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">    <span class="comment">// 把最后一行清空</span></div><div class="line">    <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 清空了最后一行，同步crt_pos</span></div><div class="line">    crt_pos -= CRT_COLS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</strong></p>
<p>单步执行以下代码。然后回答以下问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</div><div class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</div></pre></td></tr></table></figure>
<ul>
<li>In the call to cprintf(), to what does fmt point? To what does ap point?</li>
<li>List (in order of execution) each call to <code>cons_putc, va_arg</code>, and vcprintf. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what ap points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
<p>单步执行其实没有太多的必要。仔细读一下<code>cprintf</code>函数代码实现就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">putch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span></div><div class="line">&#123;</div><div class="line">        cputchar(ch);</div><div class="line">        *cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">        vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></div><div class="line">&#123;</div><div class="line">        va_list ap;</div><div class="line">        <span class="keyword">int</span> cnt;</div><div class="line"></div><div class="line">        va_start(ap, fmt);</div><div class="line">        cnt = vcprintf(fmt, ap);</div><div class="line">        va_end(ap);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面<code>va_list</code>的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="number">__b</span>uiltin_va_list va_list;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap, last) __builtin_va_start(ap, last)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap, type) __builtin_va_arg(ap, type)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap) __builtin_va_end(ap)</span></div></pre></td></tr></table></figure>
<p>结果发现这几个宏都是由<code>GCC</code>来提供了。嗯。这样实际上是不太容易能够分析清楚的。<br>最好还是看<code>mit 6.828 2007</code>版本的代码。</p>
<p>在读下面的代码的时候，一定要注意栈的方向是从高地址往低地址前进。并且压栈的时候，<br>如果是一个char，也是压入一个long。所以需要注意字长。也就是所以单位是以long对齐的。<br>比如压入了5个char。也是需要用到2个long。在32位机器上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 指针定义为char *可以指向任意一个内存地址。</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</div><div class="line"></div><div class="line"><span class="comment">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    __va_size(type) \</span></div><div class="line">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))</div><div class="line"></div><div class="line"><span class="comment">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line"><span class="comment">// va_arg就是用来取参数的起始地址的。然后返回type类型。</span></div><div class="line"><span class="comment">// 从整个表达式的意义来说没有什么好用的。</span></div><div class="line"><span class="comment">// 其实等价于(*(type*)ap)</span></div><div class="line"><span class="comment">// 但是实际上使ap指针移动一个参数大小。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// 空指令，没有什么用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_end(ap)    ((void)0)</span></div></pre></td></tr></table></figure>
<p>所以这里回到原来的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</div><div class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</div></pre></td></tr></table></figure>
<p><code>fmt</code>就是指向那个<code>const char *</code>的字符串。当调用的时候，栈中的结构是如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     X           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;-----------+&amp;fmt</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">va_start(fmt, ap) 作用如下</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line">展开就是</div><div class="line">ap = (<span class="keyword">char</span> *)(&amp;fmt) + align_long(fmt);</div><div class="line"></div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     X           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;--------------+ap</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>接下来简单一点，看一下调用到<code>%c</code>输出的时候，代码是怎么走的</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">void</div><div class="line">vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    while (1) &#123;</div><div class="line">        // 如果只是一般的字符串，直接输出。</div><div class="line">        while ((ch = *(unsigned char *) fmt++) != '%') &#123;</div><div class="line">            if (ch == '\0')</div><div class="line">                return;</div><div class="line">            putch(ch, putdat);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果发现是%c</div><div class="line">    reswitch:</div><div class="line">        // 先把%号跳掉，取出'c'</div><div class="line">        switch (ch = *(unsigned char *) fmt++) &#123;</div><div class="line">        // .. </div><div class="line">        case 'c':</div><div class="line">            putch(va_arg(ap, int), putdat);</div><div class="line">            break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候通过<code>%c</code>就知道应该从栈中取出一个参数char类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">va_arg(ap, <span class="keyword">int</span>) 展开后就是</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// putat用来统计输出的字符的个数。在这里可以不用去管</span></div><div class="line"><span class="keyword">char</span> temp = *(<span class="keyword">char</span>*)ap;</div><div class="line">putch(temp, putdat); <span class="comment">// 输出到console上。</span></div><div class="line"></div><div class="line">ap += align_long(<span class="keyword">char</span>);</div><div class="line"></div><div class="line">执行完成之后。</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;------+ap</div><div class="line">|                 |</div><div class="line">|     X           |   这个x会被%d提出来进行输出。</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>从这里也可以总结出来。ap的作用实际上就是利用fmt里面的<code>%</code>依次把后面的类型提出来。<br>然后去栈中找到参数。一个一个输出。</p>
<p><strong>问题4</strong>运行如下代码会输出什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">unsigned int i = 0x00646c72;</div><div class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</div></pre></td></tr></table></figure>
<p>输出是什么？解释一下?</p>
<p>首先<code>%x</code>是输出16进制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">57616</span> = <span class="number">0xE110</span>。</div><div class="line"></div><div class="line">i = <span class="number">0x00646c72</span></div><div class="line">那么如果把i占用的<span class="number">4b</span>yte转换成为<span class="keyword">char</span>[<span class="number">4</span>]数组。结果就是：</div><div class="line"></div><div class="line"><span class="keyword">char</span> str[<span class="number">4</span>] = &#123;<span class="number">0x72</span>, <span class="number">0x6c</span>, <span class="number">0x64</span>, <span class="number">0x00</span>&#125;; <span class="comment">// = &#123;'r', 'l', 'd', 0&#125;</span></div><div class="line">所以输出就是</div><div class="line"></div><div class="line">Hell0 World</div></pre></td></tr></table></figure>
<p><strong>问题5</strong></p>
<p>y后面会输出啥？这种栈越界操作，其实是无法判定的。因为不知道越界这个内存里面以前放的内容是什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cprintf(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>GCC里面输出的时候，入栈的顺序是从函数调用方的右往左入栈。所以，最后一个参数最先入栈。第一个栈入最后入栈。<br>如果入栈顺序反过来会怎么样？</p>
<p>其实也还是可以拿到参数的。只不过需要把宏的加减法改一下就可以了。把这里的加法改成减法，减法改成加法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 指针定义为char *可以指向任意一个内存地址。</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</div><div class="line"></div><div class="line"><span class="comment">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    __va_size(type) \</span></div><div class="line">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))</div><div class="line"></div><div class="line"><span class="comment">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line"><span class="comment">// va_arg就是用来取参数的起始地址的。然后返回type类型。</span></div><div class="line"><span class="comment">// 从整个表达式的意义来说没有什么好用的。</span></div><div class="line"><span class="comment">// 其实等价于(*(type*)ap)</span></div><div class="line"><span class="comment">// 但是实际上使ap指针移动一个参数大小。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// 空指令，没有什么用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_end(ap)    ((void)0)</span></div></pre></td></tr></table></figure>
<p><strong>挑战</strong>输出各种颜色。这种事情好玩，但是与操作系统核心偏得有点远。这里不去关注。</p>
<h2 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h2><p><strong>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</strong></p>
<ol>
<li>内核在哪里初始化了内核用到的栈？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 首先boot.S里面初始化了ss段描述符。</div><div class="line">  # Set up the protected-mode data segment registers</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</div><div class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</div><div class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</div><div class="line">  movw    %ax, %fs                # -&gt; FS</div><div class="line">  movw    %ax, %gs                # -&gt; GS</div><div class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</div><div class="line"></div><div class="line">  # Set up the stack pointer and call into C.</div><div class="line">  movl    $start, %esp</div><div class="line">  call bootmain</div><div class="line"></div><div class="line">// 然后再进入到kern/entry.S。</div><div class="line">// 有意思的是，这里是把栈顶设置为0。后面在递归回溯的时候，遇到放ebp ＝ 0的时候，应该停止了。</div><div class="line">// 在后面的作业里会用到这个。</div><div class="line">// </div><div class="line">        # Clear the frame pointer register (EBP)</div><div class="line">        # so that once we get into debugging C code,</div><div class="line">        # stack backtraces will be terminated properly.</div><div class="line">        movl    $0x0,%ebp                       # nuke frame pointer</div><div class="line"></div><div class="line">        # Set the stack pointer</div><div class="line">        movl    $(bootstacktop),%esp</div><div class="line"></div><div class="line">        # now to C code</div><div class="line">        call    i386_init</div><div class="line">...</div><div class="line">###################################################################</div><div class="line"># boot stack</div><div class="line">###################################################################</div><div class="line">        .p2align        PGSHIFT         # force page alignment</div><div class="line">        .globl          bootstack</div><div class="line">bootstack:</div><div class="line">        .space          KSTKSIZE</div><div class="line">        .globl          bootstacktop</div><div class="line">bootstacktop:</div></pre></td></tr></table></figure>
<p>这里可以看一下内核的内存分配图。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Virtual memory map:                                Permissions</div><div class="line"> *                                                    kernel/user</div><div class="line"> *</div><div class="line"> *    4 Gig --------&gt;  +------------------------------+</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"> *                     :              .               :</div><div class="line"> *                     :              .               :</div><div class="line"> *                     :              .               :</div><div class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *                     |   Remapped Physical Memory   | RW/--</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</div><div class="line"> *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |</div><div class="line"> *                     | - - - - - - - - - - - - - - -|                   |</div><div class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</div><div class="line"> *                     +------------------------------+                   |</div><div class="line"> *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |</div><div class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</div><div class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</div><div class="line"> *                     +------------------------------+                   |</div><div class="line"> *                     :              .               :                   |</div><div class="line"> *                     :              .               :                   |</div><div class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</div><div class="line"></div><div class="line">./inc/memlayout.h:97:#define KSTKSIZE    (8*PGSIZE)           // size of a kernel stack</div></pre></td></tr></table></figure>
<p>可以看出来。kernel就是把内核栈放到了kernel代码的后面。大小就是一个<code>KSTKSIZE</code>。</p>
<h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h2><p>为了熟悉C函数调用的转换。可以在<code>obj/kern/kernel.asm</code>中找到<code>test_backtrace</code>函数。在那里设置一个断点。<br>然后验证每次调用的时候发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Test the stack backtrace function (lab 1 only)</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">test_backtrace</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line">&#123;</div><div class="line">    cprintf(<span class="string">"entering test_backtrace %d\n"</span>, x);</div><div class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</div><div class="line">        test_backtrace(x<span class="number">-1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cprintf(<span class="string">"leaving test_backtrace %d\n"</span>, x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方进行的操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">将参数由右向左压入栈</div><div class="line">将返回地址 (eip中的内容) 入栈，在 call 指令执行</div><div class="line"></div><div class="line">函数内部执行: </div><div class="line">f0100040:       55                      push   %ebp</div><div class="line">f0100041:       89 e5                   mov    %esp,%ebp</div><div class="line">f0100043:       53                      push   %ebx</div><div class="line">f0100044:       83 ec 14                sub    $0x14,%esp</div><div class="line"></div><div class="line">将上一个函数的 ebp 入栈</div><div class="line">将 ebx 入栈，保护寄存器状态</div><div class="line">在栈上开辟一个空间存储局部变量。这里会有5个int的空间。</div></pre></td></tr></table></figure>
<p>整理过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./kern/init.c:39:    test_backtrace(5);</div><div class="line">主函数的调用  x = 5</div><div class="line"></div><div class="line">1. move <span class="variable">$0x5</span>, (%esp)       ;执行的是movl <span class="variable">$0x05</span>, %(esp); 执行完之后。此时esp = 0xf010ffe0. ebp = 0xf010fff8</div><div class="line">2. push f01000ea(retaddr)  ;这是压入test_backtrace(5);返回之后的地址。执行完之后 esp = 0xf010ffe0 - 4;</div><div class="line"></div><div class="line">3. push %ebp               ;压入0xf010fff8.  执行完之后。esp = 0xf010ffe0 - 8;</div><div class="line">   movl %esp, %ebp         ;执行完之后ebp = esp = 0xf010ffe0 - 8 = 0xf010ffd8</div><div class="line">4. push %ebx               ;不管这里%ebx是多少。总之esp = 0xf010ffd8 - 4 = 0xf010ffd4</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ;esp = 0xf010ffd4 - 0x14 = 0xf010ffc0</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">0xf010ffa0:    0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    0x00000005    0xf010ffd8    0xf0100069</div><div class="line">0xf010ffc0:    5.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>接着开始第二轮，也就是真正的递归。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">接着开始第二轮  x == 4</div><div class="line">在函数递归调用的时候，是这么调用的。</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div><div class="line"></div><div class="line"></div><div class="line">1. mov  %eax,(%esp)        ; 执行完成之后. esp = 0xf010ffc0，这里eax也就是等于x-1。也就是4</div><div class="line">2. push f0100069 (retaddr) ; 执行完成之后，esp = 0xf010ffbc</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ffb8</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ffb8</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ffb4</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ; 执行完成之后, esp = 0xf010ffa0</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">0xf010ffa0:    5.0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    4.0x00000005    3.0xf010ffd8    2.0xf0100069</div><div class="line">0xf010ffc0:    1.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>然后开始第三轮，也就是把x=3开始调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">接着开始第二轮  x == 3</div><div class="line">在函数递归调用的时候，是这么调用的。</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div><div class="line"></div><div class="line"></div><div class="line">1. mov  %eax,(%esp)        ; 执行完成之后. esp = 0xf010ffa0，这里eax也就是等于x-1。也就是3</div><div class="line">2. push f0100069 (retaddr) ; 执行完成之后，esp = 0xf010ff9c</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ff98</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ff98</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ff94</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ; 执行完成之后, esp = 0xf010ff80</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    5.0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004(ebx)    3. 0xf010ffb8    2.0xf0100069</div><div class="line">0xf010ffa0:    1.0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    4.0x00000005    3.0xf010ffd8    2.0xf0100069</div><div class="line">0xf010ffc0:    1.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>后面就不用再依次展开，可以把这个过程分为以下几个部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(gdb) x/64x $esp</div><div class="line">// x == 0的时候</div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">// x == 1</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">// x == 2</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">// x == 3</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">// x == 4</div><div class="line">0xf010ffa0:    0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    0x00000005    0xf010ffd8    0xf0100069</div><div class="line">// x = 5</div><div class="line">0xf010ffc0:    0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    0x00010094    0xf010fff8    0xf01000ea</div><div class="line"></div><div class="line">0xf010ffe0:    0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>注意，看每一个部分的时候，一定要注意：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">进入函数之后</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ffb8</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ffb8</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ffb4</div><div class="line">5. subl $0x14, %esp        ; 执行完成之后, esp = 0xf010ffa0</div><div class="line"></div><div class="line">然后递归调用的时候</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div></pre></td></tr></table></figure></p>
<p>所以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// x = 5</div><div class="line">0xf010ffc0:    0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    0x00010094    0xf010fff8    0xf01000ea</div><div class="line"></div><div class="line">0xf010ffe0:    0x00000005</div></pre></td></tr></table></figure>
<p>这里<code>0xf010ffc0:    0x00000004</code>这个4.实际上是在x = 5的时候，开始往函数里面填写参数的时候生成的。 </p>
<p>此外，也需要记住每次<code>%ebp</code>指针的变化图。</p>
<h2 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a>Exercise 11.</h2><p>通过以上的代码操作，给足了信息，已经实现一个栈回溯的程序了<code>mon_backtrace()</code>。这个函数的原型已经等着你去填相应的代码了。<br><code>kern/monitor.c</code>。但是在操作的时候，必须全部使用<code>C</code>语言。在<code>inc/x86.h</code>里面的<code>read_ebp()</code>函数会是非常有用的。<br>此外也需要在内核中添加一个命令，用来支持<code>monitor</code>命令的输出。</p>
<p>通过命令可以得到如下的输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Stack backtrace:</div><div class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</div><div class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>每一行都包含了<code>ebp, eip, args</code>。这段小代码还是比较好处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Your code here.</span></div><div class="line">  <span class="keyword">uint32_t</span> ebp = read_ebp();</div><div class="line">  <span class="meta">#<span class="meta-keyword">define</span> TO_INT(x)  *((uint32_t*)(x))</span></div><div class="line">  <span class="keyword">while</span> (ebp) &#123;</div><div class="line">    <span class="comment">// ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span></div><div class="line">    cprintf(<span class="string">"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,</div><div class="line">            TO_INT(ebp),       <span class="comment">/*ebp*/</span></div><div class="line">            TO_INT((ebp+<span class="number">4</span>)),   <span class="comment">/*eip*/</span></div><div class="line">            TO_INT((ebp+<span class="number">8</span>)),   <span class="comment">/*arg1*/</span></div><div class="line">            TO_INT((ebp+<span class="number">12</span>)),  <span class="comment">/*arg2*/</span></div><div class="line">            TO_INT((ebp+<span class="number">16</span>)),  <span class="comment">/*arg3*/</span></div><div class="line">            TO_INT((ebp+<span class="number">20</span>)),  <span class="comment">/*arg4*/</span></div><div class="line">            TO_INT((ebp+<span class="number">24</span>)));  <span class="comment">/*arg5*/</span></div><div class="line">    ebp = TO_INT(ebp);</div><div class="line">  &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是比较简单的。</p>
<p><img src="/blog/img/mit.6.828/call.stack.jpeg" alt=""></p>
<h2 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h2><p>修改<code>stack backtrace</code>函数来显示每个<code>eip, fun_name, source_file_name, line_number</code>等与<code>eip</code>相关联系的信息。<br>在<code>debuginfo_eip</code>里面，<code>__STAB_*</code>这些信息是从哪里来的呢？这里可以通过以下方式来了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">look in the file kern/kernel.ld for __STAB_*</div><div class="line">run objdump -h obj/kern/kernel</div><div class="line">run objdump -G obj/kern/kernel</div><div class="line">run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</div></pre></td></tr></table></figure>
<h3 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.stabstr : &#123;</div><div class="line">    PROVIDE(__STABSTR_BEGIN__ = .);</div><div class="line">    *(.stabstr);</div><div class="line">    PROVIDE(__STABSTR_END__ = .);</div><div class="line">    BYTE(0)        /* Force the linker to allocate space</div><div class="line">               for this section */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如通过<code>objdump -h obj/kern/kernel</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab# objdump -h obj/kern/kernel</div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         000019d7  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       0000079c  f01019e0  001019e0  000029e0  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003955  f010217c  0010217c  0000317c  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018ba  f0105ad1  00105ad1  00006ad1  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div></pre></td></tr></table></figure>
<p>这里就可以看到<code>.stabstr</code>段。</p>
<p>而<code>objdump -G obj/kern/kernel</code>可以把所有的详细信息都打印出来。<br>在链接脚本里面，明确指定了所有的字符都需要加载到固定的段里面。</p>
<p>需要在kern/monitor.c里面添加代码，完成功能如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">K&gt; backtrace</div><div class="line">Stack backtrace:</div><div class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</div><div class="line">         kern/monitor.c:143: monitor+106</div><div class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</div><div class="line">         kern/init.c:49: i386_init+59</div><div class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</div><div class="line">         kern/entry.S:70: &lt;unknown&gt;+0</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>每一行都会输出文件名以及行(根据eip得到)。但是需要注意的是这个monitor+106并不是说在monitor的106行。而是说离monitor的开始有106个bytes。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 一定要把文件名，函数名，等相应的信息另起一行进行输出。</div><div class="line">Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</div></pre></td></tr></table></figure>
<p><code>printf(&quot;%.*s&quot;, length, string)</code> 可以输出指定长度的字符串。</p>
<p>由于优化的原因，一些<code>inline</code>的函数会被编译到调用方的代码里面。所以看到的结果会少掉某些函数。这主要是<code>-O2</code>这个代码优化带来的。</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>其实主要看上面格式的说明就行了。其他扯的太多，对求解作业不一定特别有用。</p>
<p><strong>文件名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">909    SO     0      2      f0101340 5591   lib/readline.c</div></pre></td></tr></table></figure>
<p>所以在根据<code>eip</code>来查找的时候，首先找文件。以下代码来自于函数<br><code>int debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Search the entire set of stabs for the source file (type N_SO).</span></div><div class="line">lfile = <span class="number">0</span>;</div><div class="line">rfile = (stab_end - stabs) - <span class="number">1</span>;</div><div class="line">stab_binsearch(stabs, &amp;lfile, &amp;rfile, N_SO, addr);</div><div class="line"><span class="keyword">if</span> (lfile == <span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div></pre></td></tr></table></figure>
<p><strong>函数</strong></p>
<p>原函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">char *</div><div class="line">strcpy(char *dst, const char *src)</div><div class="line">&#123;</div><div class="line">  char *ret;</div><div class="line"></div><div class="line">  ret = dst;</div><div class="line">  while ((*dst++ = *src++) != &apos;\0&apos;)</div><div class="line">    /* do nothing */;</div><div class="line">  return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析之后得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1131   FUN    0      0      f0101a69 6099   strcpy:F(0,20)=*(0,2)</div><div class="line">1132   PSYM   0      0      00000008 6121   dst:p(0,20) &lt;--- 栈中的偏移</div><div class="line">1133   PSYM   0      0      0000000c 6133   src:p(0,19) &lt;--- 栈中的偏移</div><div class="line">1134   SLINE  0      33     00000000 0 // 00000000 ---&gt; 33, 这里33就是表示函数定义的行号。</div><div class="line">1135   SLINE  0      36     00000006 0 // 第一行代码相对文件的行号。</div><div class="line">1136   SLINE  0      37     0000000c 0</div><div class="line">1137   SLINE  0      37     0000000d 0</div><div class="line">1138   SLINE  0      39     0000002b 0</div><div class="line">1139   SLINE  0      40     0000002e 0</div><div class="line">1140   LSYM   0      0      fffffffc 6145   ret:(0,20)</div><div class="line">1141   LBRAC  0      0      00000000 0</div><div class="line">1142   RBRAC  0      0      00000030 0</div></pre></td></tr></table></figure>
<p>第一行是函数名。第二行是符号名，第三行SLINE开始是函数体里面的代码。<code>LYSM</code>表示函数局部变量符号。<br><code>LBRAC</code>表示函数左边的花括号。<code>RBRAC</code>表示函数右边的花括号。</p>
<p>所以当给定<code>eip</code>之后。搜索到file之后。就开始找函数名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Search within that file's stabs for the function definition</span></div><div class="line"><span class="comment">// (N_FUN).</span></div><div class="line">lfun = lfile;</div><div class="line">rfun = rfile;</div><div class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_FUN, addr);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (lfun &lt;= rfun) &#123;</div><div class="line">  <span class="comment">// stabs[lfun] points to the function name</span></div><div class="line">  <span class="comment">// in the string table, but check bounds just in case.</span></div><div class="line">  <span class="keyword">if</span> (stabs[lfun].n_strx &lt; stabstr_end - stabstr)</div><div class="line">    info-&gt;eip_fn_name = stabstr + stabs[lfun].n_strx;</div><div class="line">  info-&gt;eip_fn_addr = stabs[lfun].n_value;</div><div class="line">  addr -= info-&gt;eip_fn_addr;</div><div class="line">  <span class="comment">// Search within the function definition for the line number.</span></div><div class="line">  lline = lfun;</div><div class="line">  rline = rfun;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Couldn't find function stab!  Maybe we're in an assembly</span></div><div class="line">  <span class="comment">// file.  Search the whole file for the line number.</span></div><div class="line">  info-&gt;eip_fn_addr = addr;</div><div class="line">  lline = lfile;</div><div class="line">  rline = rfile;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Ignore stuff after the colon.</span></div><div class="line">info-&gt;eip_fn_namelen = strfind(info-&gt;eip_fn_name, <span class="string">':'</span>) - info-&gt;eip_fn_name;</div></pre></td></tr></table></figure>
<p><code>stab_binsearch</code>这个函数有意思的地方是：输入参数<code>lxxx, rxxx</code>,进去的时候，即是限制范围。也是最后的返回值。<br>此外，如果是跳到汇编代码里面的话，是无法找到函数体的定义的。在这种情况下就改变策略，只能把范围设置为整个文件。</p>
<p><strong>stabs</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Entries in the STABS table are formatted as follows.</span></div><div class="line"><span class="keyword">struct</span> Stab &#123;</div><div class="line">    <span class="keyword">uint32_t</span> n_strx;        <span class="comment">// index into string table of name</span></div><div class="line">    <span class="keyword">uint8_t</span> n_type;         <span class="comment">// type of symbol</span></div><div class="line">    <span class="keyword">uint8_t</span> n_other;        <span class="comment">// misc info (usually empty)</span></div><div class="line">    <span class="keyword">uint16_t</span> n_desc;        <span class="comment">// description field</span></div><div class="line">    <span class="keyword">uintptr_t</span> n_value;        <span class="comment">// value of symbol --&gt; 这里就是指地址。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">root@debug:~/<span class="number">6.828</span>/lab<span class="meta"># git diff</span></div><div class="line">diff --git a/kern/kdebug.c b/kern/kdebug.c</div><div class="line">index <span class="number">9547143.</span>.f85b570 <span class="number">100644</span></div><div class="line">--- a/kern/kdebug.c</div><div class="line">+++ b/kern/kdebug.c</div><div class="line">@@ <span class="number">-180</span>,<span class="number">6</span> +<span class="number">180</span>,<span class="number">25</span> @@ debuginfo_eip(<span class="keyword">uintptr_t</span> addr, <span class="keyword">struct</span> Eipdebuginfo *info)</div><div class="line">        <span class="comment">//      which one.</span></div><div class="line">        <span class="comment">// Your code here.</span></div><div class="line"></div><div class="line">+  <span class="keyword">int</span> olline = lline, orline = rline;</div><div class="line">+  stab_binsearch(stabs, &amp;olline, &amp;orline, N_SOL, (!(lline == lfile &amp;&amp; rline == rfile))*addr + info-&gt;eip_fn_addr);</div><div class="line">+  <span class="comment">// 如果没有找到N_SOL</span></div><div class="line">+  <span class="keyword">if</span> (olline &gt; orline) &#123;</div><div class="line">+    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line">+    <span class="comment">// 如果在N_SLINE也没有找到</span></div><div class="line">+    <span class="keyword">if</span> (lline &gt; rline) &#123;</div><div class="line">+       <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">+    &#125;</div><div class="line">+  &#125;</div><div class="line">+  <span class="comment">// 记录找到的行号</span></div><div class="line">+  info-&gt;eip_line = stabs[lline].n_desc;</div><div class="line">+</div><div class="line"></div><div class="line">        <span class="comment">// Search backwards from the line number for the relevant filename</span></div><div class="line">        <span class="comment">// stab.</span></div><div class="line">diff --git a/kern/monitor.c b/kern/monitor.c</div><div class="line">index e137e92..a0f188d <span class="number">100644</span></div><div class="line">--- a/kern/monitor.c</div><div class="line">+++ b/kern/monitor.c</div><div class="line">@@ <span class="number">-24</span>,<span class="number">6</span> +<span class="number">24</span>,<span class="number">7</span> @@ <span class="keyword">struct</span> Command &#123;</div><div class="line"> <span class="keyword">static</span> <span class="keyword">struct</span> Command commands[] = &#123;</div><div class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">+  &#123; <span class="string">"backtrace"</span>, <span class="string">"Display backtrace info"</span>, mon_backtrace &#125;,</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="comment">/***** Implementations of basic kernel monitor commands *****/</span></div><div class="line">@@ <span class="number">-58</span>,<span class="number">6</span> +<span class="number">59</span>,<span class="number">30</span> @@ <span class="function"><span class="keyword">int</span></span></div><div class="line"> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></div><div class="line"> &#123;</div><div class="line">        <span class="comment">// Your code here.</span></div><div class="line">+  <span class="keyword">uint32_t</span> ebp = read_ebp();</div><div class="line">+  <span class="keyword">uint32_t</span> eip = <span class="number">0</span>;</div><div class="line">+  <span class="keyword">struct</span> Eipdebuginfo info;</div><div class="line">+  <span class="meta">#<span class="meta-keyword">define</span> TO_INT(x)  *((uint32_t*)(x))</span></div><div class="line">+  <span class="keyword">while</span> (ebp) &#123;</div><div class="line">+    eip = TO_INT((ebp+<span class="number">4</span>));</div><div class="line">+    cprintf(<span class="string">"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,</div><div class="line">+            ebp,                <span class="comment">/*ebp*/</span></div><div class="line">+            eip,                <span class="comment">/*eip*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">8</span>)),    <span class="comment">/*arg1*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">12</span>)),   <span class="comment">/*arg2*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">16</span>)),   <span class="comment">/*arg3*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">20</span>)),   <span class="comment">/*arg4*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">24</span>)));  <span class="comment">/*arg5*/</span></div><div class="line">+</div><div class="line">+    <span class="keyword">if</span>(!debuginfo_eip(eip, &amp;info)) &#123;</div><div class="line">+      cprintf(<span class="string">"%s:%d: %.*s+%d\n"</span>,</div><div class="line">+              info.eip_file,</div><div class="line">+              info.eip_line,</div><div class="line">+              info.eip_fn_namelen, info.eip_fn_name,</div><div class="line">+              eip - info.eip_fn_addr);</div><div class="line">+    &#125;</div><div class="line">+    ebp = TO_INT(ebp);</div><div class="line">+  &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">diff --git a/lib/printfmt.c b/lib/printfmt.c</div><div class="line">index <span class="number">28e01</span>c9.<span class="number">.1</span>d3a5fa <span class="number">100644</span></div><div class="line">--- a/lib/printfmt.c</div><div class="line">+++ b/lib/printfmt.c</div><div class="line">@@ <span class="number">-206</span>,<span class="number">10</span> +<span class="number">206</span>,<span class="number">13</span> @@ vprintfmt(<span class="keyword">void</span> (*putch)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *putdat, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</div><div class="line">                <span class="comment">// (unsigned) octal</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">                        <span class="comment">// Replace this with your code.</span></div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       <span class="keyword">break</span>;</div><div class="line">+                       num = getint(&amp;ap, lflag);</div><div class="line">+                       <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123;</div><div class="line">+                               putch(<span class="string">'-'</span>, putdat);</div><div class="line">+                               num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</div><div class="line">+                       &#125;</div><div class="line">+                       base = <span class="number">8</span>;</div><div class="line">+                       <span class="keyword">goto</span> number;</div><div class="line"></div><div class="line">                <span class="comment">// pointer</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</div></pre></td></tr></table></figure>
<p><strong>出错记录</strong></p>
<ul>
<li>输出ebp的时候，输出成了<code>TO_INT(ebp)</code></li>
<li>N_SOL表示内联函数引进来的代码行。在处理的时候需要处理掉。</li>
<li>当没有找到函数的时候。一定要注意：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注意前面的处理：如果是能够找到相应的函数定义，那么</span></div><div class="line"><span class="comment">// addr -= info-&gt;eip_fn_addr;</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">468    FUN    0      0      f0100690 3954   mon_backtrace:F(0,1)</div><div class="line">472    SLINE  0      60     00000000 0</div><div class="line">473    SLINE  0      80     00000007 0</div><div class="line">474    SOL    0      0      f01006a3 2929   ./inc/x86.h</div><div class="line">475    SLINE  0      214    00000013 0  &lt;-- 这一行是在x86.h里面的read_ebp()</div><div class="line">476    SOL    0      0      f01006a5 3661   kern/monitor.c</div><div class="line">477    SLINE  0      82     00000015 0</div><div class="line">478    SLINE  0      84     00000017 0</div><div class="line">479    SLINE  0      85     00000051 0</div><div class="line">480    SLINE  0      82     00000053 0</div><div class="line">481    SLINE  0      88     00000057 0</div><div class="line">483    LBRAC  0      0      00000000 0      // 左花括号</div><div class="line">484    RBRAC  0      0      00000062 0      // 左花括号</div><div class="line">*/</div><div class="line"><span class="comment">// 是不是应该先找一下SOL?</span></div><div class="line"><span class="comment">/*</span></div><div class="line">if (lline == lfile &amp;&amp; rline == rfile) &#123;</div><div class="line">    // 如果没有找到函数，那么addr就没有被减过</div><div class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SOL, info-&gt;eip_fn_addr);</div><div class="line">&#125; else &#123;</div><div class="line">    // 如果找到过函数，那么addr就被减过了</div><div class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SOL, addr += info-&gt;eip_fn_addr);</div><div class="line">&#125;这段代码可以简化成如下代码</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab1" data-title="MIT 6.828 Lab1" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>