<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>MIT 6.828 JOS课程1：HW Boot xv6 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Homework: boot xv6作业链接：https://pdos.csail.mit.edu/6.828/2016/homework/xv6-boot.html
查看地址这里是为了查看进入内核的入口函数，运行命令如下：
cd /opt/xv6-publicnm kernel | grep _start">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 JOS课程1：HW Boot xv6">
<meta property="og:url" content="https://jiyou.github.io/blog/2016/09/16/mit.6.828/jos-lab1-a/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="Homework: boot xv6作业链接：https://pdos.csail.mit.edu/6.828/2016/homework/xv6-boot.html
查看地址这里是为了查看进入内核的入口函数，运行命令如下：
cd /opt/xv6-publicnm kernel | grep _start">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/gdb-start.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/lab1.a/lab1.a.boot-up.mem.jpeg.001.jpeg.001.jpeg.001.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/lab1.a/lab1.a.boot-up.mem.jpeg.001.jpeg.001.jpeg.002.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/lab1.a/call.stack.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/lab1.a/caller.start.address.jpeg">
<meta property="og:updated_time" content="2016-11-02T03:13:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 JOS课程1：HW Boot xv6">
<meta name="twitter:description" content="Homework: boot xv6作业链接：https://pdos.csail.mit.edu/6.828/2016/homework/xv6-boot.html
查看地址这里是为了查看进入内核的入口函数，运行命令如下：
cd /opt/xv6-publicnm kernel | grep _start">
<meta name="twitter:image" content="https://jiyou.github.io/blog/blog/img/gdb-start.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">最近文章</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/categories/随笔">随笔</a></li>
				        
							<li><a href="/blog/categories/xv6">xv6</a></li>
				        
							<li><a href="/blog/categories/ceph">ceph</a></li>
				        
							<li><a href="/blog/categories/OpenStack">OpenStack</a></li>
				        
							<li><a href="/blog/categories/OS">OS</a></li>
				        
							<li><a href="/blog/categories/UnixV6">UnixV6</a></li>
				        
							<li><a href="/blog/categories/libevent">libevent</a></li>
				        
							<li><a href="/blog/categories/PDP11">PDP11</a></li>
				        
							<li><a href="/blog/categories/Linux">Linux</a></li>
				        
							<li><a href="/blog/categories/Kernel">Kernel</a></li>
				        
							<li><a href="/blog/categories/mit.6.828">mit.6.828</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/Ceph/" style="font-size: 20px;">Ceph</a> <a href="/blog/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/blog/tags/Gdb/" style="font-size: 18.57px;">Gdb</a> <a href="/blog/tags/JOS/" style="font-size: 15.71px;">JOS</a> <a href="/blog/tags/Kernel/" style="font-size: 11.43px;">Kernel</a> <a href="/blog/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/blog/tags/MIT-6-828/" style="font-size: 15.71px;">MIT 6.828</a> <a href="/blog/tags/Nova/" style="font-size: 10px;">Nova</a> <a href="/blog/tags/OS/" style="font-size: 10px;">OS</a> <a href="/blog/tags/OpenStack/" style="font-size: 12.86px;">OpenStack</a> <a href="/blog/tags/Paxos/" style="font-size: 10px;">Paxos</a> <a href="/blog/tags/Qemu/" style="font-size: 17.14px;">Qemu</a> <a href="/blog/tags/Unix-V6/" style="font-size: 14.29px;">Unix V6</a> <a href="/blog/tags/Woboq/" style="font-size: 10px;">Woboq</a> <a href="/blog/tags/bluestore/" style="font-size: 10px;">bluestore</a> <a href="/blog/tags/libevent/" style="font-size: 10px;">libevent</a> <a href="/blog/tags/pdp11/" style="font-size: 12.86px;">pdp11</a> <a href="/blog/tags/xv6/" style="font-size: 10px;">xv6</a> <a href="/blog/tags/中断/" style="font-size: 10px;">中断</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">最近文章</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/categories/随笔">随笔</a></li>
		        
					<li><a href="/blog/categories/xv6">xv6</a></li>
		        
					<li><a href="/blog/categories/ceph">ceph</a></li>
		        
					<li><a href="/blog/categories/OpenStack">OpenStack</a></li>
		        
					<li><a href="/blog/categories/OS">OS</a></li>
		        
					<li><a href="/blog/categories/UnixV6">UnixV6</a></li>
		        
					<li><a href="/blog/categories/libevent">libevent</a></li>
		        
					<li><a href="/blog/categories/PDP11">PDP11</a></li>
		        
					<li><a href="/blog/categories/Linux">Linux</a></li>
		        
					<li><a href="/blog/categories/Kernel">Kernel</a></li>
		        
					<li><a href="/blog/categories/mit.6.828">mit.6.828</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-mit.6.828/jos-lab1-a" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/09/16/mit.6.828/jos-lab1-a/" class="article-date">
  	<time datetime="2016-09-15T23:28:32.000Z" itemprop="datePublished">2016-09-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MIT 6.828 JOS课程1：HW Boot xv6
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JOS/">JOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/MIT-6-828/">MIT 6.828</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/xv6/">xv6</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Homework-boot-xv6"><a href="#Homework-boot-xv6" class="headerlink" title="Homework: boot xv6"></a>Homework: boot xv6</h1><p>作业链接：<a href="https://pdos.csail.mit.edu/6.828/2016/homework/xv6-boot.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.828/2016/homework/xv6-boot.html</a></p>
<h1 id="查看地址"><a href="#查看地址" class="headerlink" title="查看地址"></a>查看地址</h1><p>这里是为了查看进入内核的入口函数，运行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /opt/xv6-public</div><div class="line">nm kernel | grep _start</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以得到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">jiyou-qt@jiyou-qt:~/writeos/xv6-public$ nm kernel | grep _start</div><div class="line">8010a48c D _binary_entryother_start</div><div class="line">8010a460 D _binary_initcode_start</div><div class="line">0010000c T _start</div></pre></td></tr></table></figure>
<p>可以看到，最后一行的起始地址为<code>kernel</code>的入口函数地址。</p>
<h1 id="Task-1-GDB入口地址"><a href="#Task-1-GDB入口地址" class="headerlink" title="Task 1. GDB入口地址"></a>Task 1. GDB入口地址</h1><p>这里需要打开两个终端，一个作为<code>gdb-server</code>，一个是作为<code>gdb-client</code>。这个比较简单，实际上是通过实例说明一下gdb的使用。不过在前面的博文中已经介绍过了。</p>
<p><strong>gdb-server</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /opt/xv6-public</div><div class="line"></div><div class="line"><span class="comment"># 下面的命令只需要选择一个来执行。</span></div><div class="line"><span class="comment"># Choice 1. 如果ubuntu有UI界面，并且处在UI界面中，运行如下命令。</span></div><div class="line">make qemu-gdb</div><div class="line"></div><div class="line"><span class="comment"># Choice 2. 如果ubuntu没有UI界面，那么运行:</span></div><div class="line">make qemu-nox-gdb</div></pre></td></tr></table></figure></p>
<p><strong>gdb-client</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> /opt/xv6-public</div><div class="line">gdb</div></pre></td></tr></table></figure></p>
<p>可以得到如下输出：</p>
<p><img src="/blog/img/gdb-start.jpeg" alt=""></p>
<h1 id="Task-2-What-is-on-the-stack"><a href="#Task-2-What-is-on-the-stack" class="headerlink" title="Task 2. What is on the stack?"></a>Task 2. What is on the stack?</h1><p>在gdb中查看寄存器可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(gdb) info reg</div><div class="line">...</div></pre></td></tr></table></figure>
<p>查看栈指针的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(gdb) x/24x <span class="variable">$esp</span></div><div class="line">...</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>作业内容：英文原文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Write a short (3-5 word) comment next to each non-zero value on the stack explaining what it is. Which part of the stack printout is actually the stack? (Hint: not all of it.)</div><div class="line"></div><div class="line">You might find it convenient to consult the files bootasm.S, bootmain.c, and bootblock.asm (which contains the output of the compiler/assembler). The reference page has pointers to x86 assembly documentation, if you are wondering about the semantics of a particular instruction. Your goal is to understand and explain the contents of the stack that you saw above, just after entering the xv6 kernel. One way to achieve this would be to observe how and where the stack gets setup during early boot and then track the changes to the stack up until the point you are interested in. Here are some questions to help you along:</div></pre></td></tr></table></figure>
<ul>
<li>Begin by restarting qemu and gdb, and set a break-point at 0x7c00, the start of the boot block (bootasm.S). Single step through the instructions (type si at the gdb prompt). Where in bootasm.S is the stack pointer initialized? (Single step until you see an instruction that moves a value into %esp, the register for the stack pointer.)</li>
<li>Single step through the call to bootmain; what is on the stack now?</li>
<li>What do the first assembly instructions of bootmain do to the stack? Look for bootmain in bootblock.asm.</li>
<li>Continue tracing via gdb (using breakpoints if necessary – see hint below) and look for the call that changes eip to 0x10000c. What does that call do to the stack? (Hint: Think about what this call is trying to accomplish in the boot sequence and try to identify this point in bootmain.c, and the corresponding instruction in the bootmain code in bootblock.asm. This might help you set suitable breakpoints to speed things up.)</li>
</ul>
<p>翻译如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">写一个简单的注释来说明一下栈中每个非0的数据表示啥意思。Stack输出的哪部分是真正表示了这个stack。</div><div class="line"></div><div class="line">可能会发现比较容易查询到文件bootasm.S, bootmain.c, bootblock.asm，这三个文件包含了编译器与汇编器的输出。参考链接(https://pdos.csail.mit.edu/6.828/2016/reference.html)里面包含了x86汇编语言的文档。如果你对某些指令有疑问，那么下面这些问题可以帮助到你：</div><div class="line"></div><div class="line">Start by setting a break-point at 0x7c00, the start of the boot block (bootasm.S).</div><div class="line"></div><div class="line">1. 在0x7c00处设置一个断点，应该可以发现这是启动的第一条指令。bootasm.S的开始执行的地方。</div><div class="line"></div><div class="line">2. 接下来，利用gdb中的si命令单步执行。找到bootasm.S中stack是在哪里初始化的？(注意：单步执行，直到你找到某条指令把某个值移动到了%esp寄存器中。%esp也就是栈指针。)</div><div class="line"></div><div class="line">3. 当代码跳转到bootmain的时候，这个时候栈里面又存放的是什么？</div><div class="line"></div><div class="line">4. 在bootmain里面的第一条汇编指令对这个stack做啥了？快去查看bootblock.asm吧，bootmain就在里面。</div><div class="line"></div><div class="line">5. 查看在bootblock.asm里面的bootmain，找到调用call。这个call会把%eip指向0x10000c。这个call对栈又做了啥？</div><div class="line"></div><div class="line">6. 提交注决：x/24x %esp的有效输出，应该就是说非0的那一部分，以及你的comment。把这个作业写到hwN.txt里面。N表示的是第几次作业。</div></pre></td></tr></table></figure>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>阅读<strong>李忠《x86汇编语言－从实模式到保护模式》</strong>第五章，会找到最好的答案。</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>问题是需要找到<code>bootasm.S</code>中在哪里把<code>stack</code>给初始化了？代码比较容易看懂。也就是在<code>bootasm.S</code>的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Set up the stack pointer and call into C.</div><div class="line">movl    $start, %esp   &lt;-- 就在这里</div><div class="line">call    bootmain</div></pre></td></tr></table></figure>
<p>但是这前后的原理详细介绍下：</p>
<h3 id="Q-2-1-刚启动的情况"><a href="#Q-2-1-刚启动的情况" class="headerlink" title="Q.2.1 刚启动的情况"></a>Q.2.1 刚启动的情况</h3><p>利用<code>gdb</code>进行调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(gdb) br * 0x7c00    <span class="comment"># &lt;-- 设置断点</span></div><div class="line">Breakpoint 1 at 0x7c00</div><div class="line">(gdb) c              <span class="comment"># &lt;-- 让程序开始执行到断点处，停下来。</span></div><div class="line">Continuing.</div><div class="line">[   0:7c00] =&gt; 0x7c00:	cli</div><div class="line"></div><div class="line">Breakpoint 1, 0x00007c00 <span class="keyword">in</span> ?? ()</div><div class="line">(gdb) si</div><div class="line">[   0:7c01] =&gt; 0x7c01:	xor    %ax,%ax</div><div class="line">0x00007c01 <span class="keyword">in</span> ?? ()</div><div class="line">(gdb) info reg</div><div class="line">eax            0xaa55	43605</div><div class="line">ecx            0x0	0</div><div class="line">edx            0x80	128</div><div class="line">ebx            0x0	0</div><div class="line">esp            0x6f2c	0x6f2c  <span class="comment"># &lt;-- 注意esp的值。</span></div><div class="line">ebp            0x0	0x0</div><div class="line">esi            0x0	0</div><div class="line">edi            0x0	0</div><div class="line">eip            0x7c01	0x7c01</div><div class="line">eflags         0x2	[ ]</div><div class="line">cs             0x0	0</div><div class="line">ss             0x0	0          <span class="comment"># &lt;-- 注意ss的值。</span></div><div class="line">ds             0x0	0</div><div class="line">es             0x0	0</div><div class="line">fs             0x0	0</div><div class="line">gs             0x0	0</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>当前还在实模式下。<code>0x6f2c</code>处在<code>0x7c00</code>之下，因此，形成的结构如下：</p>
<p><img src="/blog/img/lab1.a/lab1.a.boot-up.mem.jpeg.001.jpeg.001.jpeg.001.jpeg" alt=""></p>
<h3 id="Q-2-2-设置ss栈段寄存器"><a href="#Q-2-2-设置ss栈段寄存器" class="headerlink" title="Q.2.2 设置ss栈段寄存器"></a>Q.2.2 设置ss栈段寄存器</h3> <figure class="highlight c"><table><tr><td class="code"><pre><div class="line">mov %ax, %ss</div></pre></td></tr></table></figure>
<p> 得到的结果如下：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"> (gdb) si</div><div class="line">=&gt; 0x7c3b:	mov    <span class="variable">$0x0</span>,%ax</div><div class="line">0x00007c3b <span class="keyword">in</span> ?? ()</div><div class="line">(gdb) info reg</div><div class="line">eax            0x10	16</div><div class="line">ecx            0x0	0</div><div class="line">edx            0x80	128</div><div class="line">ebx            0x0	0</div><div class="line">esp            0x6f2c	0x6f2c</div><div class="line">ebp            0x0	0x0</div><div class="line">esi            0x0	0</div><div class="line">edi            0x0	0</div><div class="line">eip            0x7c3b	0x7c3b</div><div class="line">eflags         0x6	[ PF ]</div><div class="line">cs             0x8	8</div><div class="line">ss             0x10	16   &lt;-- 此时已经进入保护模式，这里选中第二个段描述符。</div><div class="line">ds             0x10	16</div><div class="line">es             0x10	16</div><div class="line">fs             0x0	0</div><div class="line">gs             0x0	0</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>选择第2个段描述符之后，接下来开始执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">mov    $<span class="number">0x7c00</span>,%esp  <span class="comment">// 源代码是mov $start, %esp。由于start是程序起始位置。而</span></div><div class="line">						    <span class="comment">// 程序是被加载到0x7c00处的。所以start=0x7c00。</span></div></pre></td></tr></table></figure>
<p>得到的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(gdb) info reg</div><div class="line">eax            0x0	0</div><div class="line">ecx            0x0	0</div><div class="line">edx            0x80	128</div><div class="line">ebx            0x0	0</div><div class="line">esp            0x7c00	0x7c00   <span class="comment"># &lt;-- esp指向0x7c00。</span></div><div class="line">ebp            0x0	0x0</div><div class="line">esi            0x0	0</div><div class="line">edi            0x0	0</div><div class="line">eip            0x7c48	0x7c48</div><div class="line">eflags         0x6	[ PF ]</div><div class="line">cs             0x8	8</div><div class="line">ss             0x10	16</div><div class="line">ds             0x10	16</div><div class="line">es             0x10	16</div><div class="line">fs             0x0	0</div><div class="line">gs             0x0	0</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>如果不能<code>debug</code>，其实直接阅读<code>bootblock.asm</code>也可以看出如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Set up the stack pointer and call into C.</span></div><div class="line">movl    <span class="variable">$start</span>, %esp</div><div class="line">  7c43:   bc 00 7c 00 00          mov    <span class="variable">$0x7c00</span>,%esp</div></pre></td></tr></table></figure>
<p>设置<code>%esp</code>结束之后，形成的结构如下所示：<br><img src="/blog/img/lab1.a/lab1.a.boot-up.mem.jpeg.001.jpeg.001.jpeg.002.jpeg" alt=""></p>
<h3 id="Q-2-3-必备小知识"><a href="#Q-2-3-必备小知识" class="headerlink" title="Q.2.3 必备小知识"></a>Q.2.3 必备小知识</h3><p>接下来的代码，就是准备调用<code>bootmain</code>程序了。</p>
<p><strong>摘取自bootblock.asm</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">call    bootmain</div><div class="line">  <span class="number">7</span>c48:   e8 e2 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">7</span>d2f &lt;bootmain&gt;</div></pre></td></tr></table></figure></p>
<p>这里是汇编程序调用C程序。因此，在执行<code>call bootmain</code>命令的时候，实际上是有以下动作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">更加详细信息参考**赵炯《Linux内核完全剖析－linux.0.11》版本**第三章，3.4 C与汇编的相互调用。如果无心阅读，直接看下文也没有关系。</div></pre></td></tr></table></figure>
<p>这里可以看一下调用栈的结构。</p>
<p><img src="/blog/img/lab1.a/call.stack.jpeg" alt=""></p>
<p><strong>注意</strong><br>参数1，参数2，参数3，直到参数n都是给被调用者函数使用的。但是却是放于调用者的栈帧中。</p>
<h4 id="Q-2-3-1-栈与参数的传递"><a href="#Q-2-3-1-栈与参数的传递" class="headerlink" title="Q.2.3.1 栈与参数的传递"></a>Q.2.3.1 栈与参数的传递</h4><p>对照上图，需要特别注意的是：假设把调用者称为函数A，被调用者称为函数B。也就是形成如下结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> arg1, arg2, arg3;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	B(arg1, arg2, arg3);</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用者的栈帧：int arg1, arg2, arg3, 是存放在<code>局部变量区域</code>。</li>
<li><code>B(arg1, arg2, arg3)</code>在调用时，这些参数会被压入栈中。这个时候仍然是处在函数A的栈帧中。也就是对应到图中参数1,参数2,参数3`的地方。可以看到，入栈的时候，是从函数参数的尾部开始的，也就是位于最后的参数最先入栈。</li>
<li><code>函数B</code>通过<code>ebp+8, ebp+12</code>等等来访问变量<code>arg1, arg2</code>。这个时候<code>ebp</code>里面存放的是函数Ａ的<code>ebp</code>的值。</li>
<li>函数A也是通过<code>ebp</code>来访问函数参数。所以在调用<code>函数B</code>的时候，需要把<code>ebp</code>也入栈。</li>
<li>当进入到函数B之后，帧指针<code>ebp</code>指向的地址即<code>ebp+0</code>这里存放的实际上是<code>函数Ａ</code>使用的<code>ebp</code>。所以声明为<code>指向上一个</code>。</li>
<li>通过前面的总结可以得到：<code>ebp+8</code>就取到了第<code>1</code>个传入的函数参数。<code>ebp-n</code>，就是得到当前函数的内部的局部变量。比如<code>ebp-4</code>就得到局部变量<code>x</code>。</li>
</ul>
<p><strong>调用者函数Ａ的工作</strong></p>
<ul>
<li>把函数需要的参数压入栈中。</li>
<li>把返回地址压入栈中。</li>
<li>调用函数B。</li>
</ul>
<p><strong>被调用函数Ｂ的工作</strong></p>
<p>直接上代码就可以了。如果要更加详细的说明，请阅读<code>《汇编语言程序设计》Richard Blum的书的第11章，使用函数</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">function:</div><div class="line">	pushl %ebp</div><div class="line">	movl %esp, %ebp</div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	movl %ebp, %esp</div><div class="line">	popl %ebp</div><div class="line">	ret</div></pre></td></tr></table></figure>
<h4 id="Q-2-3-3-栈与局部变量"><a href="#Q-2-3-3-栈与局部变量" class="headerlink" title="Q.2.3.3 栈与局部变量"></a>Q.2.3.3 栈与局部变量</h4><p>在<code>函数B</code>内部处理的时候，局部变量处理方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">function:</div><div class="line">	pushl %ebp</div><div class="line">	movl %esp, %ebp</div><div class="line">	</div><div class="line">	<span class="comment">// for local variable.</span></div><div class="line">	subl $<span class="number">8</span>, %esp</div></pre></td></tr></table></figure>
<p>这里就保留了8字节的局部变量空间给<code>函数Ｂ</code>。</p>
<h4 id="Q-2-3-4-栈的清理工作"><a href="#Q-2-3-4-栈的清理工作" class="headerlink" title="Q.2.3.4 栈的清理工作"></a>Q.2.3.4 栈的清理工作</h4><p>当<code>函数B</code>使用<code>ret</code>指令返回之后，调用方因为压入了各种参数到栈中，还需要由调用方来清理栈里面的参数。方法很简单，参数占了多少个字节，直接修改<code>%esp</code>指针回去就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">pushl %eax</div><div class="line">pushl %ebx</div><div class="line">pushl %ecx</div><div class="line"></div><div class="line">call func_b</div><div class="line"></div><div class="line">addl $<span class="number">12</span>, %esp <span class="comment">//这里修改esp指针的位置。</span></div></pre></td></tr></table></figure>
<h3 id="Q-2-4-call-bootmain"><a href="#Q-2-4-call-bootmain" class="headerlink" title="Q.2.4 call bootmain"></a>Q.2.4 call bootmain</h3><p>有了<code>Q.2.3小知识</code>的学习，现在应该可以搞清楚函数调用的过程了。接下来，直接看调用方：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"># Set up the <span class="built_in">stack</span> pointer and call into C.</div><div class="line">movl    $start, %esp</div><div class="line">  <span class="number">7</span>c43:   bc <span class="number">00</span> <span class="number">7</span>c <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x7c00</span>,%esp</div><div class="line">call    bootmain</div><div class="line">  <span class="number">7</span>c48:   e8 e2 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">7</span>d2f &lt;bootmain&gt;</div></pre></td></tr></table></figure>
<p>这里实际上只做了两件事：</p>
<ul>
<li>设置栈顶指针，也就是栈是从哪里开始放数据的。</li>
<li><code>call bootmain</code>，在这里会把返回地址压入栈中。</li>
</ul>
<p>这里根据<code>gdb</code>调试器来进行验证。</p>
<p><strong>栈顶指针esp</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) si</div><div class="line">=&gt; <span class="number">0x7c48</span>:	call   <span class="number">0x7d2f</span>  <span class="comment">// &lt;-- 这里指向了call bootmain，但是实际上还没有执行。刚执行完了mov $start, %esp</span></div><div class="line">                            <span class="comment">// &lt;-- 而$start的值，由于在编译的时候，Makefile里面写明了程序加载地址是从0x7c00开始。</span></div><div class="line">                            <span class="comment">// 所以$start的值就是0x7c00。</span></div><div class="line"><span class="number">0x00007c48</span> in ?? ()</div><div class="line">(gdb) info reg</div><div class="line">eax            <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">ecx            <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">edx            <span class="number">0x80</span>	<span class="number">128</span></div><div class="line">ebx            <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">esp            <span class="number">0x7c00</span>	<span class="number">0x7c00</span>  &lt;---- %esp = <span class="number">0x7c00</span></div><div class="line">ebp            <span class="number">0x0</span>	<span class="number">0x0</span></div><div class="line">esi            <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">edi            <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">eip            <span class="number">0x7c48</span>	<span class="number">0x7c48</span></div><div class="line">eflags         <span class="number">0x6</span>	[ PF ]</div><div class="line">cs             <span class="number">0x8</span>	<span class="number">8</span></div><div class="line">ss             <span class="number">0x10</span>	<span class="number">16</span></div><div class="line">ds             <span class="number">0x10</span>	<span class="number">16</span></div><div class="line">es             <span class="number">0x10</span>	<span class="number">16</span></div><div class="line">fs             <span class="number">0x0</span>	<span class="number">0</span></div><div class="line">gs             <span class="number">0x0</span>	<span class="number">0</span></div></pre></td></tr></table></figure>
<p><strong>返回地址入栈</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">//代码如下：</div><div class="line">  # Set up the stack pointer and call into C.</div><div class="line">  movl    $start, %esp</div><div class="line">    7c43:   bc 00 7c 00 00          mov    $0x7c00,%esp</div><div class="line">  call    bootmain</div><div class="line">    7c48:   e8 e2 00 00 00          call   7d2f &lt;bootmain&gt;</div><div class="line"></div><div class="line">  # If bootmain returns (it shouldn't), trigger a Bochs</div><div class="line">  # breakpoint if running under Bochs, then loop.</div><div class="line">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</div><div class="line">    7c4d:   66 b8 00 8a             mov    $0x8a00,%ax</div></pre></td></tr></table></figure>
<p><img src="/blog/img/lab1.a/caller.start.address.jpeg" alt=""></p>
<p>调试结果：（GDB调试网页太多了，给个参考：(<a href="http://www.cnblogs.com/rosesmall/archive/2012/04/12/2444431.html)）" target="_blank" rel="external">http://www.cnblogs.com/rosesmall/archive/2012/04/12/2444431.html)）</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) si</div><div class="line">=&gt; <span class="number">0x7d2f</span>:	push   %ebp &lt;-- 注意：这句话已经位于bootmain函数中，但是还没有执行。后面的结果都是刚运行</div><div class="line">							  <span class="comment">// &lt;-- call bootmain之后的结果。</span></div><div class="line"><span class="number">0x00007d2f</span> in ?? ()</div><div class="line">(gdb) info reg</div><div class="line">esp            <span class="number">0x7bfc</span>	<span class="number">0x7bfc</span></div><div class="line">ebp            <span class="number">0x0</span>	<span class="number">0x0</span></div><div class="line">ss             <span class="number">0x10</span>	<span class="number">16</span></div></pre></td></tr></table></figure>
<p>栈中的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>x $esp</div><div class="line"><span class="number">0x7bfc</span>:	<span class="number">0x00007c4d</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p><code>gdb</code>中的<code>x</code>指令表示的是：从指定的地址处，取出多长的内容，并打印出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 打印格式 x/n&#123;print_format&#125; $address</span></div><div class="line"><span class="comment">// print_format有如下选项</span></div><div class="line">x 按十六进制格式显示变量。</div><div class="line">d 按十进制格式显示变量。</div><div class="line">u 按十六进制格式显示无符号整型。</div><div class="line">o 按八进制格式显示变量。</div><div class="line">t 按二进制格式显示变量。</div><div class="line">a 按十六进制格式显示变量。</div><div class="line">c 按字符格式显示变量。</div><div class="line">f 按浮点数格式显示变量。</div></pre></td></tr></table></figure>
<p>指令的完整含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">x/&lt;n/f/u&gt; &lt;addr&gt;</div><div class="line"><span class="comment">/*</span></div><div class="line">n、f、u是可选的参数。</div><div class="line"></div><div class="line">n是一个正整数，表示需要显示的内存单元的个数，也就是说从当前地址向后显示几个内存单元的内容，一个内存单元的大小由后面的u定义。</div><div class="line"></div><div class="line">f 表示显示的格式，参见下面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。</div><div class="line"></div><div class="line">u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</div><div class="line"></div><div class="line">&lt;addr&gt;表示一个内存地址。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><strong>查看栈中内容的方法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7c00</span><span class="number">-0x4</span></div><div class="line"><span class="number">0x7bfc</span>:	<span class="number">0x00007c4d</span>    &lt;-- 已经入栈的第一个元素，里面存放了返回地址。</div><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7c00</span><span class="number">-0x8</span></div><div class="line"><span class="number">0x7bf8</span>:	<span class="number">0x00000000</span>    &lt;-- 栈中后面可用空间，内容不定，但是在这里都显示为<span class="number">0.</span></div><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7c00</span><span class="number">-0xc</span></div><div class="line"><span class="number">0x7bf4</span>:	<span class="number">0x00000000</span></div></pre></td></tr></table></figure>
<p><strong>esp与入栈</strong></p>
<ul>
<li>esp -= 4;</li>
<li>[esp] = var</li>
</ul>
<p>也就是说，先把<code>%esp</code>减4,然后再把内容放进去。</p>
<h2 id="问题3-bootmain的栈操作"><a href="#问题3-bootmain的栈操作" class="headerlink" title="问题3 bootmain的栈操作"></a>问题3 bootmain的栈操作</h2><p>原问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">What do the first assembly instructions of bootmain do to the stack? Look for bootmain in bootblock.asm.</div></pre></td></tr></table></figure>
<p>如<code>Q.2.3小知识</code>中所述，<code>bootmain</code>中就开始对<code>%ebp, %esp</code>进行处理。处理的框架就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">function:</div><div class="line">	pushl %ebp</div><div class="line">	movl %esp, %ebp</div><div class="line">	</div><div class="line">	<span class="comment">//..</span></div><div class="line">	处理局部变量！</div><div class="line">	...</div><div class="line">	</div><div class="line">	movl %ebp, %esp</div><div class="line">	popl %ebp</div><div class="line">	ret</div></pre></td></tr></table></figure>
<p>所以，<code>bootblock.asm</code>中<code>bootmain</code>中的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"># Set up the <span class="built_in">stack</span> pointer and call into C.</div><div class="line">movl    $start, %esp</div><div class="line">    <span class="number">7</span>c43:   bc <span class="number">00</span> <span class="number">7</span>c <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x7c00</span>,%esp</div><div class="line">call    bootmain</div><div class="line">    <span class="number">7</span>c48:   e8 e2 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">7</span>d2f &lt;bootmain&gt;</div><div class="line"></div><div class="line">....</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="number">7</span>d2f:   <span class="number">55</span>                      push   %ebp</div><div class="line">    <span class="number">7</span>d30:   <span class="number">89</span> e5                   mov    %esp,%ebp</div></pre></td></tr></table></figure>
<p>注意<code>call bootmain</code>指令生成的结果就是<code>call 7d2f</code>。而在<code>bootmain</code>中第一条指令的位置就是<code>7d2f</code>。并且进入函数之后，第一件事就是按照Ｃ语言的函数处理方式来压栈。<code>gdb</code>调试如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 执行 push %ebp之后的调试结果</span></div><div class="line">(gdb) info reg</div><div class="line">esp            <span class="number">0x7bf8</span>	<span class="number">0x7bf8</span></div><div class="line">ebp            <span class="number">0x0</span>	<span class="number">0x0</span></div><div class="line">......</div><div class="line">ss             <span class="number">0x10</span>	<span class="number">16</span></div><div class="line"></div><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7c00</span><span class="number">-4</span></div><div class="line"><span class="number">0x7bfc</span>:	<span class="number">0x00007c4d</span> &lt;-- 已经入栈的函数的返回地址，由汇编代码负责。</div><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7c00</span><span class="number">-8</span></div><div class="line"><span class="number">0x7bf8</span>:	<span class="number">0x00000000</span> &lt;-- bootmain C程序负责的压入的%ebp的值。</div><div class="line">(gdb)</div><div class="line"></div><div class="line">(gdb) si &lt; -- 这里执行 mov %esp,%ebp</div><div class="line"></div><div class="line">(gdb) info reg</div><div class="line">esp            <span class="number">0x7bf8</span>	<span class="number">0x7bf8</span>  &lt;-- 执行完成之后，可以看到%ebp记录了当前%esp的值。</div><div class="line">ebp            <span class="number">0x7bf8</span>	<span class="number">0x7bf8</span></div><div class="line">ss             <span class="number">0x10</span>	<span class="number">16</span></div><div class="line">(gdb)</div><div class="line"></div><div class="line">(gdb) x/<span class="number">1</span>x $ebp</div><div class="line"><span class="number">0x7bf8</span>:	<span class="number">0x00000000</span>   &lt;-- %ebp中对应地址里面存放的内容是：汇编程序里面用到的%ebp的值。</div><div class="line"></div><div class="line"><span class="number">7</span>d35:   <span class="number">83</span> ec <span class="number">1</span>c                sub    $<span class="number">0x1c</span>,%esp &lt;-- 这里就是bootmain开始处理内部的局部变量了。</div></pre></td></tr></table></figure>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>原问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Continue tracing via gdb (using breakpoints if necessary -- see hint below) </div><div class="line">and look for the call that changes eip to 0x10000c. What does that call do </div><div class="line">to the stack? (Hint: Think about what this call is trying to accomplish in </div><div class="line">the boot sequence and try to identify this point in bootmain.c, and the </div><div class="line">corresponding instruction in the bootmain code in bootblock.asm. This </div><div class="line">might help you set suitable breakpoints to speed things up.)</div></pre></td></tr></table></figure>
<p>注意：编译之后的结果显示的指令是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">=&gt; <span class="number">0x7db1</span>:	call   *<span class="number">0x10018</span></div></pre></td></tr></table></figure>
<p>但是在<code>gdb/si</code>单步执行的时候，显示的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(gdb) si</div><div class="line">=&gt; 0x10000c:	mov    %cr4,%eax</div><div class="line">0x0010000c in ?? ()</div></pre></td></tr></table></figure>
<p>也就是说的确进入到了<code>0x10000c</code>地址执行。这里是因为，<code>call</code>的时候，跳转地址是从内存<code>0x10018</code>处取出来的，因为<code>call后面的地址，前面有个*号</code>。可以利用<code>gdb</code>查看如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x10018</span></div><div class="line"><span class="number">0x10018</span>:	<span class="number">0x0010000c</span></div></pre></td></tr></table></figure>
<p>实际上<code>bootmain.c</code>主要做的事情就是读取<code>kernel</code>，并且跳转到<code>kernel</code>处开始执行。加载的时候，是把<code>kernel</code>加载到了<code>0x10000</code>内存地址处。</p>
<p>那么回到问题，就是说对栈做了些什么，实际上这里还是应该说只是把返回地址压栈了。这里查看<code>bootblock.asm</code>的代码；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">  <span class="comment">// Call the entry point from the ELF header.</span></div><div class="line">  <span class="comment">// Does not return!</span></div><div class="line">  entry = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))(elf-&gt;entry);</div><div class="line">  entry();</div><div class="line">    <span class="number">7</span>db1:   ff <span class="number">15</span> <span class="number">18</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span>       call   *<span class="number">0x10018</span></div><div class="line">&#125;</div><div class="line">    <span class="number">7</span>db7:   <span class="number">83</span> c4 <span class="number">1</span>c                add    $<span class="number">0x1c</span>,%esp</div></pre></td></tr></table></figure>
<p>可以看到返回地址是<code>7db7</code>，那么再查看一下内存里面的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>x <span class="number">0x7bcc</span></div><div class="line"><span class="number">0x7bcc</span>:	<span class="number">0x00007db7</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>后面的事情就是完全交给<code>kernel</code>了。不过感觉有点没有照着C的规范来。也就是开始并不是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">function:</div><div class="line">	pushl %ebp</div><div class="line">	movl %esp, %ebp</div><div class="line">	</div><div class="line">	<span class="comment">//..</span></div><div class="line">	处理局部变量！</div><div class="line">	...</div><div class="line">	</div><div class="line">	movl %ebp, %esp</div><div class="line">	popl %ebp</div><div class="line">	ret</div></pre></td></tr></table></figure>
<p>这里面可能的一个原因是：控制权完全给kernel之后，后面kernel会重新接管内存什么的。再接着看后面的内容吧。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/09/18/ceph/ceph-woboq/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Ceph通过WoboQ阅读源码
        
      </div>
    </a>
  
  
    <a href="/blog/2016/09/16/blog/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Mac上搭建Hexo+Github博客</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>





  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab1-a" data-title="MIT 6.828 JOS课程1：HW Boot xv6" data-url="https://jiyou.github.io/blog/blog/2016/09/16/mit.6.828/jos-lab1-a/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    

<script>
	var yiliaConfig = {
		fancybox: false,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>