<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>ceph:buffer:raw_pipe的实现分析 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="缘起首先需要理解splice系统调用的作用。
splice系统调用splice系统调用2
以及注意看《Linux高性能服务器编程》。
raw_pipe的作用raw_pipe的作用，主要是利用OS的pipe来实现一些功能。因此，成员主要是：
bool source_consumed;int pipefds[2];
这里pipefds就是用来记录两个pipe。
构造函数需要注意下面这个函数的原型是：">
<meta property="og:type" content="article">
<meta property="og:title" content="ceph:buffer:raw_pipe的实现分析">
<meta property="og:url" content="https://jiyou.github.io/blog/2016/12/22/ceph/Chap1.编程技法/10.ceph.buffer.raw_pipe/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="缘起首先需要理解splice系统调用的作用。
splice系统调用splice系统调用2
以及注意看《Linux高性能服务器编程》。
raw_pipe的作用raw_pipe的作用，主要是利用OS的pipe来实现一些功能。因此，成员主要是：
bool source_consumed;int pipefds[2];
这里pipefds就是用来记录两个pipe。
构造函数需要注意下面这个函数的原型是：">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/A2DA71DD-0E55-4F58-A7DA-5632E2BDE03E.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/ceph.buffer.raw.pipe.source_consumed.jpeg">
<meta property="og:updated_time" content="2017-07-15T01:48:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ceph:buffer:raw_pipe的实现分析">
<meta name="twitter:description" content="缘起首先需要理解splice系统调用的作用。
splice系统调用splice系统调用2
以及注意看《Linux高性能服务器编程》。
raw_pipe的作用raw_pipe的作用，主要是利用OS的pipe来实现一些功能。因此，成员主要是：
bool source_consumed;int pipefds[2];
这里pipefds就是用来记录两个pipe。
构造函数需要注意下面这个函数的原型是：">
<meta name="twitter:image" content="https://jiyou.github.io/blog/blog/img/A2DA71DD-0E55-4F58-A7DA-5632E2BDE03E.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/PDP11">PDP11</a></li>
				        
							<li><a href="/blog/tags/Linux">Linux</a></li>
				        
							<li><a href="/blog/tags/Kernel">Kernel</a></li>
				        
							<li><a href="/blog/tags/MIT-6-824">mit.6.824</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/Ceph/" style="font-size: 10px;">Ceph</a> <a href="/blog/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/blog/tags/Gdb/" style="font-size: 18.57px;">Gdb</a> <a href="/blog/tags/JOS/" style="font-size: 15.71px;">JOS</a> <a href="/blog/tags/Kernel/" style="font-size: 11.43px;">Kernel</a> <a href="/blog/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/blog/tags/MIT-6-828/" style="font-size: 15.71px;">MIT 6.828</a> <a href="/blog/tags/MapReduce/" style="font-size: 10px;">MapReduce</a> <a href="/blog/tags/Nova/" style="font-size: 10px;">Nova</a> <a href="/blog/tags/OS/" style="font-size: 10px;">OS</a> <a href="/blog/tags/OpenStack/" style="font-size: 12.86px;">OpenStack</a> <a href="/blog/tags/Paxos/" style="font-size: 10px;">Paxos</a> <a href="/blog/tags/Qemu/" style="font-size: 17.14px;">Qemu</a> <a href="/blog/tags/Unix-V6/" style="font-size: 14.29px;">Unix V6</a> <a href="/blog/tags/Woboq/" style="font-size: 10px;">Woboq</a> <a href="/blog/tags/blog/" style="font-size: 10px;">blog</a> <a href="/blog/tags/bluestore/" style="font-size: 10px;">bluestore</a> <a href="/blog/tags/ceph/" style="font-size: 20px;">ceph</a> <a href="/blog/tags/libevent/" style="font-size: 10px;">libevent</a> <a href="/blog/tags/mit-6-824/" style="font-size: 11.43px;">mit.6.824</a> <a href="/blog/tags/pdp11/" style="font-size: 12.86px;">pdp11</a> <a href="/blog/tags/xv6/" style="font-size: 10px;">xv6</a> <a href="/blog/tags/中断/" style="font-size: 10px;">中断</a> <a href="/blog/tags/分布式/" style="font-size: 11.43px;">分布式</a> <a href="/blog/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/blog/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/PDP11">PDP11</a></li>
		        
					<li><a href="/blog/tags/Linux">Linux</a></li>
		        
					<li><a href="/blog/tags/Kernel">Kernel</a></li>
		        
					<li><a href="/blog/tags/MIT-6-824">mit.6.824</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-ceph/Chap1.编程技法/10.ceph.buffer.raw_pipe" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/12/22/ceph/Chap1.编程技法/10.ceph.buffer.raw_pipe/" class="article-date">
  	<time datetime="2016-12-21T16:06:43.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ceph:buffer:raw_pipe的实现分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Gdb/">Gdb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Qemu/">Qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>首先需要理解<code>splice</code>系统调用的作用。</p>
<p><a href="http://blog.csdn.net/qq276592716/article/details/23047539" target="_blank" rel="external">splice系统调用</a><br><a href="http://blog.csdn.net/jasonliuvip/article/details/22600569" target="_blank" rel="external">splice系统调用2</a></p>
<p>以及注意看《Linux高性能服务器编程》。</p>
<h1 id="raw-pipe的作用"><a href="#raw-pipe的作用" class="headerlink" title="raw_pipe的作用"></a>raw_pipe的作用</h1><p><code>raw_pipe</code>的作用，主要是利用OS的<code>pipe</code>来实现一些功能。因此，成员主要是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">bool</span> source_consumed;</div><div class="line"><span class="keyword">int</span> pipefds[<span class="number">2</span>];</div></pre></td></tr></table></figure>
<p>这里<code>pipefds</code>就是用来记录两个<code>pipe</code>。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>需要注意下面这个函数的原型是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explicit raw_pipe(unsigned len) : raw(len), source_consumed(false) &#123;</div></pre></td></tr></table></figure>
<p>为了高亮的原因，去掉了<code>explicit</code>关键字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> raw_pipe(<span class="keyword">unsigned</span> len) : raw(len), source_consumed(<span class="literal">false</span>) &#123;</div><div class="line">    <span class="comment">// 这里去获取系统的pipe size。</span></div><div class="line">    <span class="comment">// 如果设置的长度比系统支持的最大的还要大。那么报错。</span></div><div class="line">    <span class="keyword">size_t</span> max = get_max_pipe_size();</div><div class="line">    <span class="keyword">if</span> (len &gt; max) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: requested length "</span> &lt;&lt; len</div><div class="line">              &lt;&lt; <span class="string">" &gt; max length "</span> &lt;&lt; max &lt;&lt; bendl;</div><div class="line">        <span class="keyword">throw</span> malformed_input(<span class="string">"length larger than max pipe size"</span>);</div><div class="line">    &#125;</div><div class="line">    pipefds[<span class="number">0</span>] = <span class="number">-1</span>;</div><div class="line">    pipefds[<span class="number">1</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="comment">// 这里生成管道文件。</span></div><div class="line">    <span class="keyword">if</span> (::pipe(pipefds) == <span class="number">-1</span>) &#123;</div><div class="line">        r = -errno;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error creating pipe: "</span> &lt;&lt; cpp_strerror(r) &lt;&lt; bendl;</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里设置非阻塞。</span></div><div class="line">    r = set_nonblocking(pipefds);</div><div class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error setting nonblocking flag on temp pipe: "</span></div><div class="line">              &lt;&lt; cpp_strerror(r) &lt;&lt; bendl;</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里设置管道的缓冲区大小。</span></div><div class="line">    r = set_pipe_size(pipefds, len);</div><div class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: could not set pipe size"</span> &lt;&lt; bendl;</div><div class="line">        <span class="comment">// continue, since the pipe should become large enough as needed</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    inc_total_alloc(len);</div><div class="line">    inc_history_alloc(len);</div><div class="line">    bdout &lt;&lt; <span class="string">"raw_pipe "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" alloc "</span> &lt;&lt; len &lt;&lt; <span class="string">" "</span></div><div class="line">          &lt;&lt; buffer::get_total_alloc() &lt;&lt; bendl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数就简单了许多。直接是释放内存。实际上，从<code>raw</code>基类的构造函数看来。当传入的参数只有<code>len</code>的时候，是不会生成新的内存的。但是为了安全起见，还是有如下判断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (data) <span class="built_in">free</span>(data);</div></pre></td></tr></table></figure>
<p>除此之外的代码即是关闭两个<code>pipe</code>文件。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">~raw_pipe() &#123;</div><div class="line">    <span class="keyword">if</span> (data)</div><div class="line">        <span class="built_in">free</span>(data);</div><div class="line">    close_pipe(pipefds);</div><div class="line">    dec_total_alloc(len);</div><div class="line">    bdout &lt;&lt; <span class="string">"raw_pipe "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" free "</span> &lt;&lt; (<span class="keyword">void</span> *)data &lt;&lt; <span class="string">" "</span></div><div class="line">          &lt;&lt; buffer::get_total_alloc() &lt;&lt; bendl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="zero-copy"><a href="#zero-copy" class="headerlink" title="zero copy"></a>zero copy</h1><p>由于splice系统调用的使用，就是为了避免内存的拷贝。也就是把用户缓冲区绑定到了内核缓冲区。所以可以支持<code>zero copy</code>。不过这些事情都是由操作系统来完成的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_zero_copy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="绑定源缓冲区"><a href="#绑定源缓冲区" class="headerlink" title="绑定源缓冲区"></a>绑定源缓冲区</h1><p>将<code>fd</code>绑定到<code>pipefds[1]</code>上。这里调用的是<code>safe_splice</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">    <span class="comment">// typedef long long loff_t;</span></div><div class="line">    <span class="comment">// typedef long long off64_t;</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">set_source</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">loff_t</span> *off)</span> </span>&#123;</div><div class="line">        <span class="comment">// 3 # define SPLICE_F_NONBLOCK 2</span></div><div class="line">        <span class="comment">/* Don't block on the pipe splicing</span></div><div class="line">         * (but we may still block on the fd we</div><div class="line">         * splice from/to).</div><div class="line">         */</div><div class="line">        <span class="keyword">int</span> flags = SPLICE_F_NONBLOCK;</div><div class="line">        <span class="comment">// 这里是将fd所指向的文件号，绑定到pipefds[1]里。</span></div><div class="line">        <span class="comment">// 然后off表示偏移值</span></div><div class="line">        <span class="comment">// NULL表示pipefds[1]中的偏移值。</span></div><div class="line">        <span class="keyword">ssize_t</span> r = safe_splice(fd, off, pipefds[<span class="number">1</span>], <span class="literal">NULL</span>, len, flags);</div><div class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">            bdout &lt;&lt; <span class="string">"raw_pipe: error splicing into pipe: "</span> &lt;&lt; cpp_strerror(r)</div><div class="line">                  &lt;&lt; bendl;</div><div class="line">            <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// update length with actual amount read</span></div><div class="line">        len = r;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">## safe_splice函数</div><div class="line"></div><div class="line">`safe_splice`函数处理的主要是重定向的问题。完成用户缓冲区与内核缓冲区的映射。从而可以免去内存的拷贝。</div><div class="line"></div><div class="line">```<span class="function">cpp</span></div><div class="line">ssize_t <span class="title">safe_splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out,</span></div><div class="line">                    <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (cnt &lt; len) &#123;</div><div class="line">        <span class="keyword">ssize_t</span> r = splice(fd_in, off_in, fd_out, off_out, len - cnt, flags);</div><div class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// EOF</span></div><div class="line">                <span class="keyword">return</span> cnt;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (errno == EINTR)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (errno == EAGAIN)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">return</span> -errno;</div><div class="line">        &#125;</div><div class="line">        cnt += r;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数实现得比较简单，就是一个while循环，不断地把数据拷贝到<code>fd_out</code>区域。</p>
<h1 id="绑定目地缓冲区"><a href="#绑定目地缓冲区" class="headerlink" title="绑定目地缓冲区"></a>绑定目地缓冲区</h1><p>实际上，与前面<code>set_source</code>函数并没有太大区别。只是这里使用的是<code>pipefds[0]</code>。需要注意的是，管道的两个文件描述符，完成的功能实际上是不一样的。<code>pipefds[1]</code>主要是往里面写入数据。而<code>pipefds[0]</code>主要是往里面读数据。所以<code>pipefds[1]</code>是作为源数据缓冲区，而<code>pipefds[0]</code>是做为目的缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">zero_copy_to_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">loff_t</span> *offset)</span> </span>&#123;</div><div class="line">    assert(!source_consumed);</div><div class="line">    <span class="keyword">int</span> flags = SPLICE_F_NONBLOCK;</div><div class="line">    <span class="keyword">ssize_t</span> r = safe_splice_exact(pipefds[<span class="number">0</span>], <span class="literal">NULL</span>, fd, offset, len, flags);</div><div class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error splicing from pipe to fd: "</span></div><div class="line">              &lt;&lt; cpp_strerror(r) &lt;&lt; bendl;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line">    source_consumed = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="save-splice-exact"><a href="#save-splice-exact" class="headerlink" title="save_splice_exact"></a>save_splice_exact</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> safe_splice_exact(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out,</div><div class="line">			  <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">ssize_t</span> ret = safe_splice(fd_in, off_in, fd_out, off_out, len, flags);</div><div class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">size_t</span>)ret != len)</div><div class="line">    <span class="keyword">return</span> -EDOM;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数与前面<code>safe_splice</code>没有太大的区别。只是加强了返回值的检查。</p>
<h1 id="clone-empty"><a href="#clone-empty" class="headerlink" title="clone_empty"></a>clone_empty</h1><p>对于<code>pipe-based</code>的缓冲区来说，应该是不会支持clone操作的。并且只是作为其他类型的buffers的单元测试在使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">buffer::<span class="function">raw* <span class="title">clone_empty</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// cloning doesn't make sense for pipe-based buffers,</span></div><div class="line">    <span class="comment">// and is only used by unit tests for other types of buffers</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过需要注意的是，在<code>raw</code>基类中，<code>clone</code>函数应该是需要加强一下处理吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function">raw *<span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">  raw *c = clone_empty();</div><div class="line">  <span class="built_in">memcpy</span>(c-&gt;data, data, len);</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果这里直接从<code>clone_empty</code>返回<code>NULL</code>，那么接下来执行<code>memcpy(c-&gt;data, data, len)</code>就会失败。</p>
<h1 id="获取数据区域"><a href="#获取数据区域" class="headerlink" title="获取数据区域"></a>获取数据区域</h1><p><code>get_data</code>会调用<code>copy_pipe</code>。需要注意的是，如果<code>data</code>缓冲区非空，那么直接返回<code>data</code>。如果<code>data</code>缓冲区是空的，那么复制<code>pipes</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_data</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (data)</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    <span class="keyword">return</span> copy_pipe(pipefds);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="copy-pipes"><a href="#copy-pipes" class="headerlink" title="copy pipes"></a>copy pipes</h2><p>在看这段代码之前，首先需要查看一下<code>tee</code>函数的用法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*splice()和tee()实现将文件"./1.txt"同时拷贝到文件"./2.txt"和"./3.txt"中*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"./1.txt"</span>, O_RDONLY);</div><div class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"./2.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line">    <span class="keyword">int</span> fd3 = open(<span class="string">"./3.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*用于向"./2.txt"输入数据*/</span></div><div class="line">    <span class="keyword">int</span> pipefd2[<span class="number">2</span>];</div><div class="line">    <span class="comment">/*用于向"./3.txt"输入数据*/</span></div><div class="line">    <span class="keyword">int</span> pipefd3[<span class="number">2</span>];</div><div class="line">    pipe(pipefd2);</div><div class="line">    pipe(pipefd3);</div><div class="line"></div><div class="line">    <span class="comment">/*将fd1文件的内容输入管道pipefd2中*/</span></div><div class="line">    splice(fd1, <span class="literal">NULL</span>, pipefd2[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line">    <span class="comment">/*将管道pipefd2的内容复制到管道pipefd3中，不消耗管道pipefd2上的数据，管道pipefd2上的数据可以用于后续操作*/</span></div><div class="line">    tee(pipefd2[<span class="number">0</span>], pipefd3[<span class="number">1</span>], <span class="number">10086</span>, SPLICE_F_NONBLOCK);</div><div class="line">    <span class="comment">/*将管道pipefd2的内容写入fd2文件中*/</span></div><div class="line">    splice(pipefd2[<span class="number">0</span>], <span class="literal">NULL</span>, fd2, <span class="literal">NULL</span>, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line">    <span class="comment">/*将管道pipefd3的内容写入fd3文件中*/</span></div><div class="line">    splice(pipefd3[<span class="number">0</span>], <span class="literal">NULL</span>, fd3, <span class="literal">NULL</span>, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line"></div><div class="line">    close(fd1);</div><div class="line">    close(fd2);</div><div class="line">    close(fd3);</div><div class="line">    close(pipefd2[<span class="number">0</span>]);</div><div class="line">    close(pipefd2[<span class="number">1</span>]);</div><div class="line">    close(pipefd3[<span class="number">0</span>]);</div><div class="line">    close(pipefd3[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tee和splice的简单介绍如下图。</p>
<p><img src="/blog/img/A2DA71DD-0E55-4F58-A7DA-5632E2BDE03E.jpeg" alt=""></p>
<p>理解了<code>tee</code>和<code>splice</code>的用法，那么再来看<code>copy_pipe</code>函数。传入的参数是<code>pipefds</code>实际上，由于是类成员，可以不要这个参数的。</p>
<p><img src="/blog/img/ceph.buffer.raw.pipe.source_consumed.jpeg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">copy_pipe</span><span class="params">(<span class="keyword">int</span> *fds)</span> </span>&#123;</div><div class="line">    <span class="comment">/* preserve original pipe contents by copying into a temporary</span></div><div class="line">     * pipe before reading.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> tmpfd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line">    <span class="comment">// source_consumed主要是用于是否消费pipefds[0].</span></div><div class="line">    <span class="comment">// 如果pipefds[0]被zero_copy_to_fd调用过，那么source_consumed会被设置成为true。</span></div><div class="line">    <span class="comment">// 也就是说输出源被绑定给了别外一个文件。</span></div><div class="line">    <span class="comment">// 在复制的时候，pipefds[0]输出源是不能被绑定到别的文件上面的。</span></div><div class="line">    assert(!source_consumed);</div><div class="line">    assert(fds[<span class="number">0</span>] &gt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 这里生成临时的pipe文件</span></div><div class="line">    <span class="keyword">if</span> (::pipe(tmpfd) == <span class="number">-1</span>) &#123;</div><div class="line">        r = -errno;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error creating temp pipe: "</span> &lt;&lt; cpp_strerror(r)</div><div class="line">              &lt;&lt; bendl;</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置pipe非阻塞</span></div><div class="line">    r = set_nonblocking(tmpfd);</div><div class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error setting nonblocking flag on temp pipe: "</span></div><div class="line">              &lt;&lt; cpp_strerror(r) &lt;&lt; bendl;</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置pipe size</span></div><div class="line">    r = set_pipe_size(tmpfd, len);</div><div class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error setting pipe size on temp pipe: "</span></div><div class="line">              &lt;&lt; cpp_strerror(r) &lt;&lt; bendl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里把fds[0]输出，mapping到tmpfd[1]输入上。</span></div><div class="line">    <span class="comment">// 注意这里采用的是tee函数。就是会把fds[0]mapping到tmpfd[1]文件管道里面。</span></div><div class="line">    <span class="keyword">int</span> flags = SPLICE_F_NONBLOCK;</div><div class="line">    <span class="keyword">if</span> (::tee(fds[<span class="number">0</span>], tmpfd[<span class="number">1</span>], len, flags) == <span class="number">-1</span>) &#123;</div><div class="line">        r = errno;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error tee'ing into temp pipe: "</span> &lt;&lt; cpp_strerror(r)</div><div class="line">              &lt;&lt; bendl;</div><div class="line">        close_pipe(tmpfd);</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 申请长度为len的内存区域。</span></div><div class="line">    data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</div><div class="line">    <span class="keyword">if</span> (!data) &#123;</div><div class="line">        close_pipe(tmpfd);</div><div class="line">        <span class="keyword">throw</span> bad_alloc();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 然后从tmpfd[1]那边读取长度为len的数据到data缓冲区buffer中。</span></div><div class="line">    r = safe_read(tmpfd[<span class="number">0</span>], data, len);</div><div class="line">    <span class="keyword">if</span> (r &lt; (<span class="keyword">ssize_t</span>)len) &#123;</div><div class="line">        bdout &lt;&lt; <span class="string">"raw_pipe: error reading from temp pipe:"</span> &lt;&lt; cpp_strerror(r)</div><div class="line">              &lt;&lt; bendl;</div><div class="line">        <span class="built_in">free</span>(data);</div><div class="line">        data = <span class="literal">NULL</span>;</div><div class="line">        close_pipe(tmpfd);</div><div class="line">        <span class="keyword">throw</span> error_code(r);</div><div class="line">    &#125;</div><div class="line">    close_pipe(tmpfd);</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="关于pipe的操作"><a href="#关于pipe的操作" class="headerlink" title="关于pipe的操作"></a>关于pipe的操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private:</div><div class="line">    int set_pipe_size(int *fds, long length) &#123;</div><div class="line">#ifdef CEPH_HAVE_SETPIPE_SZ</div><div class="line">        if (::fcntl(fds[1], F_SETPIPE_SZ, length) == -1) &#123;</div><div class="line">            int r = -errno;</div><div class="line">            if (r == -EPERM) &#123;</div><div class="line">                // pipe limit must have changed - EPERM means we requested</div><div class="line">                // more than the maximum size as an unprivileged user</div><div class="line">                update_max_pipe_size();</div><div class="line">                throw malformed_input(&quot;length larger than new max pipe size&quot;);</div><div class="line">            &#125;</div><div class="line">            return r;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int set_nonblocking(int *fds) &#123;</div><div class="line">        if (::fcntl(fds[0], F_SETFL, O_NONBLOCK) == -1)</div><div class="line">            return -errno;</div><div class="line">        if (::fcntl(fds[1], F_SETFL, O_NONBLOCK) == -1)</div><div class="line">            return -errno;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void close_pipe(int *fds) &#123;</div><div class="line">        if (fds[0] &gt;= 0)</div><div class="line">            VOID_TEMP_FAILURE_RETRY(::close(fds[0]));</div><div class="line">        if (fds[1] &gt;= 0)</div><div class="line">            VOID_TEMP_FAILURE_RETRY(::close(fds[1]));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool source_consumed;</div><div class="line">    int pipefds[2];</div><div class="line">&#125;;</div><div class="line">#endif // CEPH_HAVE_SPLICE</div></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/12/22/ceph/Chap1.编程技法/11.XioDispatchHook/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          ceph:buffer:raw_pipe的实现分析
        
      </div>
    </a>
  
  
    <a href="/blog/2016/12/21/ceph/Chap1.编程技法/9.ceph.buffer.raw.hack_aligned/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ceph:buffer:raw_hack_aligned实现</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/Chap1.编程技法/10.ceph.buffer.raw_pipe" data-title="ceph:buffer:raw_pipe的实现分析" data-url="https://jiyou.github.io/blog/blog/2016/12/22/ceph/Chap1.编程技法/10.ceph.buffer.raw_pipe/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>