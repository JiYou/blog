<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>1.5 store_test.cc代码阅读 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-// vim: ts=8 sw=2 smarttab/* * Ceph - scalable distributed file system * * Copyright (C) 2004-2006 Sage Weil &amp;lt;sage@newdream.net">
<meta property="og:type" content="article">
<meta property="og:title" content="1.5 store_test.cc代码阅读">
<meta property="og:url" content="https://jiyou.github.io/blog/2018/08/01/ceph/6.store_test.cc/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-// vim: ts=8 sw=2 smarttab/* * Ceph - scalable distributed file system * * Copyright (C) 2004-2006 Sage Weil &amp;lt;sage@newdream.net">
<meta property="og:updated_time" content="2018-08-06T09:04:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="1.5 store_test.cc代码阅读">
<meta name="twitter:description" content="// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-// vim: ts=8 sw=2 smarttab/* * Ceph - scalable distributed file system * * Copyright (C) 2004-2006 Sage Weil &amp;lt;sage@newdream.net">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/stl">stl</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/ceph/" style="font-size: 16.67px;">ceph</a> <a href="/blog/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/stl/" style="font-size: 20px;">stl</a> <a href="/blog/tags/算法/" style="font-size: 13.33px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JiYou">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">code</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/stl">stl</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-ceph/6.store_test.cc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/08/01/ceph/6.store_test.cc/" class="article-date">
  	<time datetime="2018-08-01T05:28:32.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      1.5 store_test.cc代码阅读
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight"><table><tr><td class="code"><pre><div class="line">// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-</div><div class="line">// vim: ts=8 sw=2 smarttab</div><div class="line">/*</div><div class="line"> * Ceph - scalable distributed file system</div><div class="line"> *</div><div class="line"> * Copyright (C) 2004-2006 Sage Weil &lt;sage@newdream.net&gt;</div><div class="line"> *</div><div class="line"> * This is free software; you can redistribute it and/or</div><div class="line"> * modify it under the terms of the GNU Lesser General Public</div><div class="line"> * License version 2.1, as published by the Free Software</div><div class="line"> * Foundation.  See file COPYING.</div><div class="line"> *</div><div class="line"> */</div><div class="line">using namespace std::placeholders;</div><div class="line"></div><div class="line">typedef boost::mt11213b gen_type;</div><div class="line"></div><div class="line">const uint64_t DEF_STORE_TEST_BLOCKDEV_SIZE = 10240000000;</div><div class="line">#define dout_context g_ceph_context</div><div class="line"></div><div class="line">#define GTEST_HAS_PARAM_TEST 1</div><div class="line">#if GTEST_HAS_PARAM_TEST</div><div class="line"></div><div class="line">// 检测两个bufferlist是否相等</div><div class="line">// 注意不是两个string是否相等</div><div class="line">// 类似于</div><div class="line">// ["a", "a", "a", "b"]</div><div class="line">// ["aa", "ab"]</div><div class="line">// 这两个bufferlist应该是相等的。</div><div class="line">static bool bl_eq(bufferlist&amp; expected, bufferlist&amp; actual)</div><div class="line">&#123;</div><div class="line">    if (expected.contents_equal(actual))</div><div class="line">        return true;</div><div class="line"></div><div class="line">    unsigned first = 0;</div><div class="line">    if(expected.length() != actual.length()) &#123;</div><div class="line">        cout &lt;&lt; "--- buffer lengths mismatch " &lt;&lt; std::hex</div><div class="line">             &lt;&lt; "expected 0x" &lt;&lt; expected.length() &lt;&lt; " != actual 0x"</div><div class="line">             &lt;&lt; actual.length() &lt;&lt; std::dec &lt;&lt; std::endl;</div><div class="line">        derr &lt;&lt; "--- buffer lengths mismatch " &lt;&lt; std::hex</div><div class="line">             &lt;&lt; "expected 0x" &lt;&lt; expected.length() &lt;&lt; " != actual 0x"</div><div class="line">             &lt;&lt; actual.length() &lt;&lt; std::dec &lt;&lt; dendl;</div><div class="line">    &#125;</div><div class="line">    auto len = std::min(expected.length(), actual.length());</div><div class="line">    while ( first&lt;len &amp;&amp; expected[first] == actual[first])</div><div class="line">        ++first;</div><div class="line">    unsigned last = len;</div><div class="line">    while (last &gt; 0 &amp;&amp; expected[last-1] == actual[last-1])</div><div class="line">        --last;</div><div class="line">    if(len &gt; 0) &#123;</div><div class="line">        cout &lt;&lt; "--- buffer mismatch between offset 0x" &lt;&lt; std::hex &lt;&lt; first</div><div class="line">             &lt;&lt; " and 0x" &lt;&lt; last &lt;&lt; ", total 0x" &lt;&lt; len &lt;&lt; std::dec</div><div class="line">             &lt;&lt; std::endl;</div><div class="line">        derr &lt;&lt; "--- buffer mismatch between offset 0x" &lt;&lt; std::hex &lt;&lt; first</div><div class="line">             &lt;&lt; " and 0x" &lt;&lt; last &lt;&lt; ", total 0x" &lt;&lt; len &lt;&lt; std::dec</div><div class="line">             &lt;&lt; dendl;</div><div class="line">        cout &lt;&lt; "--- expected:\n";</div><div class="line">        expected.hexdump(cout);</div><div class="line">        cout &lt;&lt; "--- actual:\n";</div><div class="line">        actual.hexdump(cout);</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">int queue_transaction(</div><div class="line">    T &amp;store,</div><div class="line">    ObjectStore::CollectionHandle ch,</div><div class="line">    ObjectStore::Transaction &amp;&amp;t)</div><div class="line">&#123;</div><div class="line">    if (rand() % 2) &#123;</div><div class="line">        // 这里生成一个空事务，然后把t包含进去</div><div class="line">        // 本质上是在测[]空事务，append实体事务的情况。</div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        t2.append(t);</div><div class="line">        return store-&gt;queue_transaction(ch, std::move(t2));</div><div class="line">    &#125; else &#123;</div><div class="line">        return store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">bool sorted(const vector&lt;ghobject_t&gt; &amp;in)</div><div class="line">&#123;</div><div class="line">    ghobject_t start;</div><div class="line">    for (vector&lt;ghobject_t&gt;::const_iterator i = in.begin();</div><div class="line">         i != in.end();</div><div class="line">         ++i) &#123;</div><div class="line">        if (start &gt; *i) &#123;</div><div class="line">            cout &lt;&lt; start &lt;&lt; " should follow " &lt;&lt; *i &lt;&lt; std::endl;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        start = *i;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这里设置统一测试参数const char *</div><div class="line">// 主要是为了测试各种bluestore, filestore, memstore, kvstore底层存储</div><div class="line"></div><div class="line">class StoreTest : public StoreTestFixture, public ::testing::WithParamInterface&lt;const char*&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    // 获得参数，初始化</div><div class="line">    // 这里使用gtest::GetParam()</div><div class="line">    // 这是因为StoreTestFixture的构造函数的参数就是</div><div class="line">    // char *type</div><div class="line">    // 注意看一下文章：</div><div class="line">    // https://blog.csdn.net/breaksoftware/article/details/51059583</div><div class="line">    StoreTest() : StoreTestFixture(GetParam()) &#123;&#125;</div><div class="line">    // 压缩测试</div><div class="line">    void doCompressionTest();</div><div class="line">    // 合成的，人造的测试</div><div class="line">    void doSyntheticTest(</div><div class="line">        int num_ops,</div><div class="line">        uint64_t max_obj, uint64_t max_wr, uint64_t align);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StoreTestDeferredSetup : public StoreTest</div><div class="line">&#123;</div><div class="line">    void SetUp() override</div><div class="line">    &#123;</div><div class="line">        //do nothing</div><div class="line">    &#125;</div><div class="line"></div><div class="line">protected:</div><div class="line">    void DeferredSetup()</div><div class="line">    &#123;</div><div class="line">        StoreTest::SetUp();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class StoreTestSpecificAUSize : public StoreTestDeferredSetup</div><div class="line">&#123;</div><div class="line"></div><div class="line">public:</div><div class="line">    // 这里定义在不同配置下需要运行的函数</div><div class="line">    typedef</div><div class="line">    std::function&lt;void(</div><div class="line">        uint64_t num_ops,</div><div class="line">        uint64_t max_obj,</div><div class="line">        uint64_t max_wr,</div><div class="line">        uint64_t align)&gt; MatrixTest;</div><div class="line"></div><div class="line">    void StartDeferred(size_t min_alloc_size)</div><div class="line">    &#123;</div><div class="line">        SetVal(g_conf, "bluestore_min_alloc_size", stringify(min_alloc_size).c_str());</div><div class="line">        DeferredSetup();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    // bluestore matrix testing</div><div class="line">    uint64_t max_write = 40 * 1024;</div><div class="line">    uint64_t max_size = 400 * 1024;</div><div class="line">    uint64_t alignment = 0;</div><div class="line">    uint64_t num_ops = 10000;</div><div class="line"></div><div class="line">protected:</div><div class="line">    string matrix_get(const char *k)</div><div class="line">    &#123;</div><div class="line">        if (string(k) == "max_write") &#123;</div><div class="line">            return stringify(max_write);</div><div class="line">        &#125; else if (string(k) == "max_size") &#123;</div><div class="line">            return stringify(max_size);</div><div class="line">        &#125; else if (string(k) == "alignment") &#123;</div><div class="line">            return stringify(alignment);</div><div class="line">        &#125; else if (string(k) == "num_ops") &#123;</div><div class="line">            return stringify(num_ops);</div><div class="line">        &#125; else &#123;</div><div class="line">            char *buf;</div><div class="line">            g_conf-&gt;get_val(k, &amp;buf, -1);</div><div class="line">            string v = buf;</div><div class="line">            free(buf);</div><div class="line">            return v;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void matrix_set(const char *k, const char *v)</div><div class="line">    &#123;</div><div class="line">        if (string(k) == "max_write") &#123;</div><div class="line">            max_write = atoll(v);</div><div class="line">        &#125; else if (string(k) == "max_size") &#123;</div><div class="line">            max_size = atoll(v);</div><div class="line">        &#125; else if (string(k) == "alignment") &#123;</div><div class="line">            alignment = atoll(v);</div><div class="line">        &#125; else if (string(k) == "num_ops") &#123;</div><div class="line">            num_ops = atoll(v);</div><div class="line">        &#125; else &#123;</div><div class="line">            SetVal(g_conf, k, v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 整个函数结构来看就是一个DFS</div><div class="line">    // 会尝试matrix里面的所有的配置，然后</div><div class="line">    // 运行fn函数。</div><div class="line"></div><div class="line">    // matrix是一个二维矩阵，里面的每个元素都是一个字符串</div><div class="line">    // 这里相当于是只处理第i行</div><div class="line">    void do_matrix_choose(const char *matrix[][10],</div><div class="line">                          int i, int pos, int num,</div><div class="line">                          MatrixTest fn)</div><div class="line">    &#123;</div><div class="line">        // 如果这一行非空</div><div class="line">        if (matrix[i][0]) &#123;</div><div class="line">            // count是拿到第i行有多少字符串</div><div class="line">            int count;</div><div class="line">            for (count = 0; matrix[i][count+1]; ++count) ;</div><div class="line">            // 依次处理第i行里面的每个字符串</div><div class="line">            // 这里跳掉了第i行的第1个元素</div><div class="line">            // 然后开始设置第1~count个元素</div><div class="line">            for (int j = 1; matrix[i][j]; ++j) &#123;</div><div class="line">                // matrix[i][0]表示的是key值</div><div class="line">                matrix_set(matrix[i][0], matrix[i][j]);</div><div class="line">                do_matrix_choose(matrix,</div><div class="line">                                 i + 1,</div><div class="line">                                 pos * count + j - 1,</div><div class="line">                                 num * count,</div><div class="line">                                 fn);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            cout &lt;&lt; "---------------------- " &lt;&lt; (pos + 1) &lt;&lt; " / " &lt;&lt; num</div><div class="line">                 &lt;&lt; " ----------------------" &lt;&lt; std::endl;</div><div class="line">            for (unsigned k=0; matrix[k][0]; ++k) &#123;</div><div class="line">                cout &lt;&lt; "  " &lt;&lt; matrix[k][0] &lt;&lt; " = " &lt;&lt; matrix_get(matrix[k][0])</div><div class="line">                     &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">            fn(num_ops, max_size, max_write, alignment);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void do_matrix(const char *matrix[][10],</div><div class="line">                   MatrixTest fn)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        if (strcmp(matrix[0][0], "bluestore_min_alloc_size") == 0) &#123;</div><div class="line">            int count;</div><div class="line">            for (count = 0; matrix[0][count+1]; ++count) ;</div><div class="line">            for (size_t j = 1; matrix[0][j]; ++j) &#123;</div><div class="line">                if (j &gt; 1) &#123;</div><div class="line">                    // teardown主要是负责测试垃圾回收</div><div class="line">                    TearDown();</div><div class="line">                &#125;</div><div class="line">                StartDeferred(strtoll(matrix[0][j], NULL, 10));</div><div class="line">                do_matrix_choose(matrix, 1, j - 1, count, fn);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            StartDeferred(0);</div><div class="line">            do_matrix_choose(matrix, 0, 0, 1, fn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 第一个参数是类名，第二个参数是函数名</div><div class="line">TEST_P(StoreTest, collect_metadata)</div><div class="line">&#123;</div><div class="line">    // 这里可以直接访问类的内部成员</div><div class="line">    // store成员就是StoreTest里面的store成员。</div><div class="line">    map&lt;string,string&gt; pm;</div><div class="line">    store-&gt;collect_metadata(&amp;pm);</div><div class="line">    if (GetParam() == string("filestore")) &#123;</div><div class="line">        ASSERT_NE(pm.count("filestore_backend"), 0u);</div><div class="line">        ASSERT_NE(pm.count("filestore_f_type"), 0u);</div><div class="line">        ASSERT_NE(pm.count("backend_filestore_partition_path"), 0u);</div><div class="line">        ASSERT_NE(pm.count("backend_filestore_dev_node"), 0u);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Trivial)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, TrivialRemount)</div><div class="line">&#123;</div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleRemount)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    // 各种内部object的深入介绍</div><div class="line">    // http://bean-li.github.io/ceph-object-in-bottom/</div><div class="line">    // sobject表示清加了snaphot支持的object</div><div class="line">    // hobject表示支持hashed object，就是说这个object可以和具体的PG对应起来</div><div class="line">    // ghobject表示的是支持EC的object</div><div class="line">    // 这里生成两个对象</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line"></div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line"></div><div class="line">    // 这里是去要一个新的collection.</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + write" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid2, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, IORemount)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + objects" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // overwrites</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; "overwrites" &lt;&lt; std::endl;</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int n=1; n&lt;=100; ++n) &#123;</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t("Object " + stringify(n), CEPH_NOSNAP)));</div><div class="line">            t.remove(cid, hoid);</div><div class="line">        &#125;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, UnprintableCharsName)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    string name = "funnychars_";</div><div class="line">    for (unsigned i = 0; i &lt; 256; ++i) &#123;</div><div class="line">        name.push_back(i);</div><div class="line">    &#125;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t(name, CEPH_NOSNAP)));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        cerr &lt;&lt; "create collection + object" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt; "removing" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, FiemapEmpty)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t("fiemap_object", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        t.truncate(cid, oid, 100000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, 0, 100000, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        e[0] = 100000;</div><div class="line">        EXPECT_TRUE(m == e || m.empty());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, FiemapHoles)</div><div class="line">&#123;</div><div class="line">    const uint64_t MAX_EXTENTS = 4000;</div><div class="line">    const uint64_t SKIP_STEP = 65536;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    ghobject_t oid(hobject_t(sobject_t("fiemap_object", CEPH_NOSNAP)));</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("foo");</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        for (uint64_t i = 0; i &lt; MAX_EXTENTS; i++)</div><div class="line">            t.write(cid, oid, SKIP_STEP * i, 3, bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //fiemap test from 0 to SKIP_STEP * (MAX_EXTENTS - 1) + 3</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, 0, SKIP_STEP * (MAX_EXTENTS - 1) + 3, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        ASSERT_TRUE(!m.empty());</div><div class="line">        ASSERT_GE(m[0], 3u);</div><div class="line">        auto last = m.crbegin();</div><div class="line">        if (m.size() == 1) &#123;</div><div class="line">            ASSERT_EQ(0u, last-&gt;first);</div><div class="line">        &#125; else if (m.size() == MAX_EXTENTS) &#123;</div><div class="line">            for (uint64_t i = 0; i &lt; MAX_EXTENTS; i++) &#123;</div><div class="line">                ASSERT_TRUE(m.count(SKIP_STEP * i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ASSERT_GT(last-&gt;first + last-&gt;second, SKIP_STEP * (MAX_EXTENTS - 1));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fiemap test from SKIP_STEP to SKIP_STEP * (MAX_EXTENTS - 2) + 3</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;fiemap(ch, oid, SKIP_STEP, SKIP_STEP * (MAX_EXTENTS - 2) + 3, bl);</div><div class="line">        map&lt;uint64_t,uint64_t&gt; m, e;</div><div class="line">        auto p = bl.cbegin();</div><div class="line">        decode(m, p);</div><div class="line">        cout &lt;&lt; " got " &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">        ASSERT_TRUE(!m.empty());</div><div class="line">        // kstore always returns [0, object_size] regardless of offset and length</div><div class="line">        // FIXME: if fiemap logic in kstore is refined</div><div class="line">        if (string(GetParam()) != "kstore") &#123;</div><div class="line">            ASSERT_GE(m[SKIP_STEP], 3u);</div><div class="line">            auto last = m.crbegin();</div><div class="line">            if (m.size() == 1) &#123;</div><div class="line">                ASSERT_EQ(SKIP_STEP, last-&gt;first);</div><div class="line">            &#125; else if (m.size() == MAX_EXTENTS - 2) &#123;</div><div class="line">                for (uint64_t i = 1; i &lt; MAX_EXTENTS - 1; i++) &#123;</div><div class="line">                    ASSERT_TRUE(m.count(SKIP_STEP*i));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_GT(last-&gt;first + last-&gt;second, SKIP_STEP * (MAX_EXTENTS - 1));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleMetaColTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "add collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimplePGColTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(1,2), shard_id_t::NO_SHARD));</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        t.create_collection(cid, 4);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 4);</div><div class="line">        cerr &lt;&lt; "add collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleColPreHashTest)</div><div class="line">&#123;</div><div class="line">    // Firstly we will need to revert the value making sure</div><div class="line">    // collection hint actually works</div><div class="line">    int merge_threshold = g_ceph_context-&gt;_conf-&gt;filestore_merge_threshold;</div><div class="line">    std::ostringstream oss;</div><div class="line">    if (merge_threshold &gt; 0) &#123;</div><div class="line">        oss &lt;&lt; "-" &lt;&lt; merge_threshold;</div><div class="line">        SetVal(g_conf, "filestore_merge_threshold", oss.str().c_str());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint32_t pg_num = 128;</div><div class="line"></div><div class="line">    boost::uniform_int&lt;&gt; pg_id_range(0, pg_num);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    int pg_id = pg_id_range(rng);</div><div class="line"></div><div class="line">    int objs_per_folder = abs(merge_threshold) * 16 * g_ceph_context-&gt;_conf-&gt;filestore_split_multiple;</div><div class="line">    boost::uniform_int&lt;&gt; folders_range(5, 256);</div><div class="line">    uint64_t expected_num_objs = (uint64_t)objs_per_folder * (uint64_t)folders_range(rng);</div><div class="line"></div><div class="line">    coll_t cid(spg_t(pg_t(pg_id, 15), shard_id_t::NO_SHARD));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        // Create a collection along with a hint</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 5);</div><div class="line">        cerr &lt;&lt; "create collection" &lt;&lt; std::endl;</div><div class="line">        bufferlist hint;</div><div class="line">        encode(pg_num, hint);</div><div class="line">        encode(expected_num_objs, hint);</div><div class="line">        t.collection_hint(cid, ObjectStore::Transaction::COLL_HINT_EXPECTED_NUM_OBJECTS, hint);</div><div class="line">        cerr &lt;&lt; "collection hint" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // Remove the collection</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "remove collection" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallBlockWrites)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    bufferlist b;</div><div class="line">    bufferptr bp(0x1000);</div><div class="line">    memset(bp.c_str(), 'b', 0x1000);</div><div class="line">    b.append(bp);</div><div class="line">    bufferlist c;</div><div class="line">    bufferptr cp(0x1000);</div><div class="line">    memset(cp.c_str(), 'c', 0x1000);</div><div class="line">    c.append(cp);</div><div class="line">    bufferptr zp(0x1000);</div><div class="line">    zp.zero();</div><div class="line">    bufferlist z;</div><div class="line">    z.append(zp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        exp.append(a);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x1000, 0x1000, b);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x2000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x3000, 0x1000, c);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(z);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0x2000, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 0x1000, c);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist in, exp;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x4000, in);</div><div class="line">        ASSERT_EQ(0x4000, r);</div><div class="line">        exp.append(c);</div><div class="line">        exp.append(b);</div><div class="line">        exp.append(a);</div><div class="line">        exp.append(c);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BufferCacheReadTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        t.write(cid, hoid, 10, 5, bl);</div><div class="line">        cerr &lt;&lt; "TwinWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 15, newdata);</div><div class="line">        ASSERT_EQ(r, 15);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(bl);</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //overwrite over the same extents</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append("edcba");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        t.write(cid, hoid, 10, 5, bl);</div><div class="line">        cerr &lt;&lt; "TwinWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 15, newdata);</div><div class="line">        ASSERT_EQ(r, 15);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(bl);</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //additional write to an unused region of some blob</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl2, newdata;</div><div class="line">        bl2.append("1234567890");</div><div class="line"></div><div class="line">        t.write(cid, hoid, 20, bl2.length(), bl2);</div><div class="line">        cerr &lt;&lt; "Append" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 30, newdata);</div><div class="line">        ASSERT_EQ(r, 30);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append("edcba");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append("edcba");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl2);</div><div class="line"></div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //additional write to an unused region of some blob and partial owerite over existing extents</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2, bl3, newdata;</div><div class="line">        bl.append("DCB");</div><div class="line">        bl2.append("1234567890");</div><div class="line">        bl3.append("BA");</div><div class="line"></div><div class="line">        t.write(cid, hoid, 30, bl2.length(), bl2);</div><div class="line">        t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 13, bl3.length(), bl3);</div><div class="line">        cerr &lt;&lt; "TripleWrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 40, newdata);</div><div class="line">        ASSERT_EQ(r, 40);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append("eDCBa");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append("edcBA");</div><div class="line">            expected.append_zero(5);</div><div class="line">            expected.append(bl2);</div><div class="line">            expected.append(bl2);</div><div class="line"></div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void StoreTest::doCompressionTest()</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    std::string data;</div><div class="line">    data.resize(0x10000 * 4);</div><div class="line">    for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">        data[i] = i / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData (4xAU) Write" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, data.size() , newdata);</div><div class="line"></div><div class="line">        ASSERT_EQ(r, (int)data.size());</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data);</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 711 , newdata);</div><div class="line">        ASSERT_EQ(r, 711);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0,711));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0xf00f, data.size(), newdata);</div><div class="line">        ASSERT_EQ(r, int(data.size() - 0xf00f) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0xf00f));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.stored, (unsigned)data.size());</div><div class="line">            ASSERT_LE(statfs.compressed, (unsigned)data.size());</div><div class="line">            ASSERT_EQ(statfs.compressed_original, (unsigned)data.size());</div><div class="line">            ASSERT_LE(statfs.compressed_allocated, (unsigned)data.size());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    std::string data2;</div><div class="line">    data2.resize(0x10000 * 4 - 0x9000);</div><div class="line">    for(size_t i = 0; i &lt; data2.size(); i++)</div><div class="line">        data2[i] = (i+1) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x8000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData partial overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x10000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x10000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x8000));</div><div class="line">            expected.append(data2.substr(0, 0x8000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x9000, 711 , newdata);</div><div class="line">        ASSERT_EQ(r, 711);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x1000,711));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x0, 0x40000, newdata);</div><div class="line">        ASSERT_EQ(r, int(0x40000) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x8000));</div><div class="line">            expected.append(data2.substr(0, 0x37000));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    data2.resize(0x3f000);</div><div class="line">    for(size_t i = 0; i &lt; data2.size(); i++)</div><div class="line">        data2[i] = (i+2) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData partial overwrite, two extents overlapped, single one to be removed" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x3e000 - 1, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x3e000 - 1);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0, 0x3e000 - 1));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x3e000-1, 0x2001, newdata);</div><div class="line">        ASSERT_EQ(r, 0x2001);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x3e000-1, 0x1001));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x0, 0x40000, newdata);</div><div class="line">        ASSERT_EQ(r, int(0x40000) );</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0, 0x3f000));</div><div class="line">            expected.append(data.substr(0x3f000, 0x1000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    data.resize(0x1001);</div><div class="line">    for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">        data[i] = (i+3) / 256;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0x3f000-1, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Small chunk partial overwrite, two extents overlapped, single one to be removed" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x3e000, 0x2000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x2000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data2.substr(0x3e000, 0x1000 - 1));</div><div class="line">            expected.append(data.substr(0, 0x1001));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Cleaning object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    auto settingsBookmark = BookmarkSettings();</div><div class="line">    SetVal(g_conf, "bluestore_compression_min_blob_size", "262144");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    &#123;</div><div class="line">        data.resize(0x10000*6);</div><div class="line"></div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i / 256;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "CompressibleData large blob" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, CompressionTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_algorithm", "snappy");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    doCompressionTest();</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_algorithm", "zlib");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "aggressive");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    doCompressionTest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleObjectTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append("abcde");</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, in);</div><div class="line">        ASSERT_EQ(5, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, exp;</div><div class="line">        bl.append("abcde");</div><div class="line">        exp = bl;</div><div class="line">        exp.append(bl);</div><div class="line">        t.write(cid, hoid, 5, 5, bl);</div><div class="line">        cerr &lt;&lt; "Append" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, exp;</div><div class="line">        bl.append("abcdeabcde");</div><div class="line">        exp = bl;</div><div class="line">        t.write(cid, hoid, 0, 10, bl);</div><div class="line">        cerr &lt;&lt; "Full overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 3, 5, bl);</div><div class="line">        cerr &lt;&lt; "Partial overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        exp.append("abcabcdede");</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append("fghij");</div><div class="line">            t.truncate(cid, hoid, 0);</div><div class="line">            t.write(cid, hoid, 5, 5, bl);</div><div class="line">            cerr &lt;&lt; "Truncate + hole" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append("abcde");</div><div class="line">            t.write(cid, hoid, 0, 5, bl);</div><div class="line">            cerr &lt;&lt; "Reverse fill-in" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist in, exp;</div><div class="line">        exp.append("abcdefghij");</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 10, in);</div><div class="line">        ASSERT_EQ(10, r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(exp, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234");</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "larger overwrite" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, bl.length(), in);</div><div class="line">        ASSERT_EQ((int)bl.length(), r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(bl, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234abcde01234012340123401234");</div><div class="line"></div><div class="line">        //test: offset=len=0 mean read all data</div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0, in);</div><div class="line">        ASSERT_EQ((int)bl.length(), r);</div><div class="line">        in.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(bl, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //verifying unaligned csums</div><div class="line">        std::string s1("1"), s2(0x1000, '2'), s3("00");</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append(s1);</div><div class="line">            bl.append(s2);</div><div class="line">            t.truncate(cid, hoid, 0);</div><div class="line">            t.write(cid, hoid, 0x1000-1, bl.length(), bl);</div><div class="line">            cerr &lt;&lt; "Write unaligned csum, stage 1" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist in, exp1, exp2, exp3;</div><div class="line">        exp1.append(s1);</div><div class="line">        exp2.append(s2);</div><div class="line">        exp3.append(s3);</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000-1, 1, in);</div><div class="line">        ASSERT_EQ(1, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp1, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000, 0x1000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp2, in));</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bufferlist bl;</div><div class="line">            bl.append(s3);</div><div class="line">            t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">            cerr &lt;&lt; "Write unaligned csum, stage 2" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 1, 2, in);</div><div class="line">        ASSERT_EQ(2, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp3, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000-1, 1, in);</div><div class="line">        ASSERT_EQ(1, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp1, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0x1000, 0x1000, in);</div><div class="line">        ASSERT_EQ(0x1000, r);</div><div class="line">        ASSERT_TRUE(bl_eq(exp2, in));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTestSpecificAUSize, BluestoreStatFSTest)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(65536);</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    // just a big number to disble gc</div><div class="line">    SetVal(g_conf, "bluestore_gc_enable_total_threshold", "100000");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line">    int r;</div><div class="line"></div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2 = hoid;</div><div class="line">    hoid2.hobj.snap = 1;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ(g_conf-&gt;bluestore_block_size, statfs.total);</div><div class="line">        ASSERT_TRUE(statfs.available &gt; 0u &amp;&amp; statfs.available &lt; g_conf-&gt;bluestore_block_size);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append("abcde");</div><div class="line">        t.write(cid, hoid, 0, 5, bl);</div><div class="line">        cerr &lt;&lt; "Append 5 bytes" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(5, statfs.stored);</div><div class="line">        ASSERT_EQ(0x10000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0, statfs.compressed);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x30000, 'a');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 0x10000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Append 0x30000 compressible bytes" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30005, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1, 3);</div><div class="line">        t.zero(cid, hoid, 0x20000, 9);</div><div class="line">        cerr &lt;&lt; "Punch hole at 1~3, 0x20000~9" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30005 - 3 - 9, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000 - 9, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x1000, 'b');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 1, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x10001, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite first and second(compressible) extents" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30001 - 9 + 0x1000, statfs.stored);</div><div class="line">        ASSERT_EQ(0x40000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000 - 9 - 0x1000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x10000, 'c');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        t.write(cid, hoid, 0x10000, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x20000, bl.length(), bl);</div><div class="line">        t.write(cid, hoid, 0x30000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite compressed extent with 3 uncompressible ones" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30000 + 0x1001, statfs.stored);</div><div class="line">        ASSERT_EQ(0x40000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 0, 0x40000);</div><div class="line">        cerr &lt;&lt; "Zero object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0u, statfs.allocated);</div><div class="line">        ASSERT_EQ(0u, statfs.stored);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed);</div><div class="line">        ASSERT_EQ(0u, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string s(0x10000, 'c');</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s);</div><div class="line">        bl.append(s.substr(0, 0x10000-2));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Yet another compressible write" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x40000 - 2, statfs.stored);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_LE(statfs.compressed, 0x10000);</div><div class="line">        ASSERT_EQ(0x20000, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(0x10000, statfs.compressed_allocated);</div><div class="line">        //force fsck</div><div class="line">        ch.reset();</div><div class="line">        EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">        EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        cerr &lt;&lt; "Clone compressed objecte" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct store_statfs_t statfs2;</div><div class="line">        r = store-&gt;statfs(&amp;statfs2);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_GT(statfs2.stored, statfs.stored);</div><div class="line">        ASSERT_EQ(statfs2.allocated, statfs.allocated);</div><div class="line">        ASSERT_GT(statfs2.compressed, statfs.compressed);</div><div class="line">        ASSERT_GT(statfs2.compressed_original, statfs.compressed_original);</div><div class="line">        ASSERT_EQ(statfs2.compressed_allocated, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BluestoreFragmentedBlobTest)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        exists = store-&gt;exists(ch, hoid);</div><div class="line">        ASSERT_EQ(true, exists);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(g_conf-&gt;bluestore_block_size, statfs.total);</div><div class="line">        ASSERT_EQ(0u, statfs.allocated);</div><div class="line">        ASSERT_EQ(0u, statfs.stored);</div><div class="line">        ASSERT_TRUE(statfs.available &gt; 0u &amp;&amp; statfs.available &lt; g_conf-&gt;bluestore_block_size);</div><div class="line">    &#125;</div><div class="line">    std::string data;</div><div class="line">    data.resize(0x10000 * 3);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i / 256 + 1;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        t.zero(cid, hoid, 0x10000, 0x10000);</div><div class="line">        cerr &lt;&lt; "Append 3*0x10000 bytes and punch a hole 0x10000~10000" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x20000, statfs.stored);</div><div class="line">        ASSERT_EQ(0x20000, statfs.allocated);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, data.size(), newdata);</div><div class="line">        ASSERT_EQ(r, (int)data.size());</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0, 0x10000));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(data.substr(0x20000, 0x10000));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 1, data.size()-2, newdata);</div><div class="line">        ASSERT_EQ(r, (int)data.size()-2);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(1, 0x10000-1));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(data.substr(0x20000, 0x10000 - 1));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string data2(3, 'b');</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x20000, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write 3 bytes after the hole" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x20000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x20000, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x20000-1, 21, newdata);</div><div class="line">        ASSERT_EQ(r, (int)21);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(string(0x1, 0));</div><div class="line">            expected.append(string(data2));</div><div class="line">            expected.append(data.substr(0x20003, 21-4));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        std::string data2(3, 'a');</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(data2);</div><div class="line">        t.write(cid, hoid, 0x10000+1, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write 3 bytes to the hole" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x30000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x20003, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0x10000-1, 0x10000+22, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x10000+22);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(data.substr(0x10000-1, 1));</div><div class="line">            expected.append(string(0x1, 0));</div><div class="line">            expected.append(data2);</div><div class="line">            expected.append(string(0x10000-4, 0));</div><div class="line">            expected.append(string(0x3, 'b'));</div><div class="line">            expected.append(data.substr(0x20004, 21-3));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, newdata;</div><div class="line">        bl.append(string(0x30000, 'c'));</div><div class="line">        t.write(cid, hoid, 0, 0x30000, bl);</div><div class="line">        t.zero(cid, hoid, 0, 0x10000);</div><div class="line">        t.zero(cid, hoid, 0x20000, 0x10000);</div><div class="line">        cerr &lt;&lt; "Rewrite an object and create two holes at the beginning and the end" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        int r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(0x10000, statfs.allocated);</div><div class="line">        ASSERT_EQ(0x10000, statfs.stored);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 0, 0x30000, newdata);</div><div class="line">        ASSERT_EQ(r, (int)0x30000);</div><div class="line">        &#123;</div><div class="line">            bufferlist expected;</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            expected.append(string(0x10000, 'c'));</div><div class="line">            expected.append(string(0x10000, 0));</div><div class="line">            ASSERT_TRUE(bl_eq(expected, newdata));</div><div class="line">        &#125;</div><div class="line">        newdata.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //force fsck</div><div class="line">    ch.reset();</div><div class="line">    EXPECT_EQ(store-&gt;umount(), 0);</div><div class="line">    EXPECT_EQ(store-&gt;mount(), 0);</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        struct store_statfs_t statfs;</div><div class="line">        r = store-&gt;statfs(&amp;statfs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ( 0u, statfs.allocated);</div><div class="line">        ASSERT_EQ( 0u, statfs.stored);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_original);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed);</div><div class="line">        ASSERT_EQ( 0u, statfs.compressed_allocated);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManySmallWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(4096);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;100; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*4096, 4096, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i=0; i&lt;100; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % 1024)*4096, 4096, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MultiSmallWriteSameBlock)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("short");</div><div class="line">    C_SaferCond c, d;</div><div class="line">    // touch same block in both same transaction, tls, and pipelined txns</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t, u;</div><div class="line">        t.write(cid, a, 0, 5, bl, 0);</div><div class="line">        t.write(cid, a, 5, 5, bl, 0);</div><div class="line">        t.write(cid, a, 4094, 5, bl, 0);</div><div class="line">        t.write(cid, a, 9000, 5, bl, 0);</div><div class="line">        u.write(cid, a, 10, 5, bl, 0);</div><div class="line">        u.write(cid, a, 7000, 5, bl, 0);</div><div class="line">        t.register_on_commit(&amp;c);</div><div class="line">        vector&lt;ObjectStore::Transaction&gt; v = &#123;t, u&#125;;</div><div class="line">        store-&gt;queue_transactions(ch, v);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t, u;</div><div class="line">        t.write(cid, a, 40, 5, bl, 0);</div><div class="line">        t.write(cid, a, 45, 5, bl, 0);</div><div class="line">        t.write(cid, a, 4094, 5, bl, 0);</div><div class="line">        t.write(cid, a, 6000, 5, bl, 0);</div><div class="line">        u.write(cid, a, 610, 5, bl, 0);</div><div class="line">        u.write(cid, a, 11000, 5, bl, 0);</div><div class="line">        t.register_on_commit(&amp;d);</div><div class="line">        vector&lt;ObjectStore::Transaction&gt; v = &#123;t, u&#125;;</div><div class="line">        store-&gt;queue_transactions(ch, v);</div><div class="line">    &#125;</div><div class="line">    c.wait();</div><div class="line">    d.wait();</div><div class="line">    &#123;</div><div class="line">        bufferlist bl2;</div><div class="line">        r = store-&gt;read(ch, a, 0, 16000, bl2);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallSkipFront)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, a);</div><div class="line">        t.truncate(cid, a, 3000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bufferptr bp(4096);</div><div class="line">        memset(bp.c_str(), 1, 4096);</div><div class="line">        bl.append(bp);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 4096, 4096, bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        ASSERT_EQ(8192, store-&gt;read(ch, a, 0, 8192, bl));</div><div class="line">        for (unsigned i=0; i&lt;4096; ++i)</div><div class="line">            ASSERT_EQ(0, bl[i]);</div><div class="line">        for (unsigned i=4096; i&lt;8192; ++i)</div><div class="line">            ASSERT_EQ(1, bl[i]);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AppendDeferredVsTailCache)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("fooo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    unsigned min_alloc = g_conf-&gt;bluestore_min_alloc_size;</div><div class="line">    unsigned size = min_alloc / 3;</div><div class="line">    bufferptr bpa(size);</div><div class="line">    memset(bpa.c_str(), 1, bpa.length());</div><div class="line">    bufferlist bla;</div><div class="line">    bla.append(bpa);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bla.length(), bla, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // force cached tail to clear ...</div><div class="line">    &#123;</div><div class="line">        ch.reset();</div><div class="line">        int r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bufferptr bpb(size);</div><div class="line">    memset(bpb.c_str(), 2, bpb.length());</div><div class="line">    bufferlist blb;</div><div class="line">    blb.append(bpb);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bla.length(), blb.length(), blb, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferptr bpc(size);</div><div class="line">    memset(bpc.c_str(), 3, bpc.length());</div><div class="line">    bufferlist blc;</div><div class="line">    blc.append(bpc);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bla.length() + blb.length(), blc.length(), blc, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist final;</div><div class="line">    final.append(bla);</div><div class="line">    final.append(blb);</div><div class="line">    final.append(blc);</div><div class="line">    bufferlist actual;</div><div class="line">    &#123;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, a, 0, final.length(), actual));</div><div class="line">        ASSERT_TRUE(bl_eq(final, actual));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AppendZeroTrailingSharedBlock)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("fooo", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b = a;</div><div class="line">    b.hobj.snap = 1;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    unsigned min_alloc = g_conf-&gt;bluestore_min_alloc_size;</div><div class="line">    unsigned size = min_alloc / 3;</div><div class="line">    bufferptr bpa(size);</div><div class="line">    memset(bpa.c_str(), 1, bpa.length());</div><div class="line">    bufferlist bla;</div><div class="line">    bla.append(bpa);</div><div class="line">    // make sure there is some trailing gunk in the last block</div><div class="line">    &#123;</div><div class="line">        bufferlist bt;</div><div class="line">        bt.append(bla);</div><div class="line">        bt.append("BADBADBADBAD");</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bt.length(), bt, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, a, size);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // clone</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, a, b);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // append with implicit zeroing</div><div class="line">    bufferptr bpb(size);</div><div class="line">    memset(bpb.c_str(), 2, bpb.length());</div><div class="line">    bufferlist blb;</div><div class="line">    blb.append(bpb);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, min_alloc * 3, blb.length(), blb, 0);</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist final;</div><div class="line">    final.append(bla);</div><div class="line">    bufferlist zeros;</div><div class="line">    zeros.append_zero(min_alloc * 3 - size);</div><div class="line">    final.append(zeros);</div><div class="line">    final.append(blb);</div><div class="line">    bufferlist actual;</div><div class="line">    &#123;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, a, 0, final.length(), actual));</div><div class="line">        final.hexdump(cout);</div><div class="line">        actual.hexdump(cout);</div><div class="line">        ASSERT_TRUE(bl_eq(final, actual));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SmallSequentialUnaligned)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    int len = 1000;</div><div class="line">    bufferptr bp(len);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*len, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManyBigWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t b(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(4 * 1048576);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*4*1048586, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // aligned</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % 256)*4*1048576, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // unaligned</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, b, (rand() % (256*4096))*1024, 4*1048576, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // do some zeros</div><div class="line">    for (int i=0; i&lt;10; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, b, (rand() % (256*4096))*1024, 16*1048576);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove(cid, b);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BigWriteBigZero)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(1048576);</div><div class="line">    memset(bp.c_str(), 'b', bp.length());</div><div class="line">    bl.append(bp);</div><div class="line">    bufferlist s;</div><div class="line">    bufferptr sp(4096);</div><div class="line">    memset(sp.c_str(), 's', sp.length());</div><div class="line">    s.append(sp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, a, bl.length() / 4, bl.length() / 2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, bl.length() / 2, s.length(), s);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MiscFragmentTests)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    bufferptr bp(524288);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 0, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 1048576, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist inbl;</div><div class="line">        int r = store-&gt;read(ch, a, 524288 + 131072, 1024, inbl);</div><div class="line">        ASSERT_EQ(r, 1024);</div><div class="line">        ASSERT_EQ(inbl.length(), 1024u);</div><div class="line">        ASSERT_TRUE(inbl.is_zero());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, 1048576 - 4096, 524288, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroVsObjectSize)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    struct stat stat;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist a;</div><div class="line">    a.append("stuff");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, 5, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(5, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1, 2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(5, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 3, 200);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(203, stat.st_size);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 100000, 200);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(0, store-&gt;stat(ch, hoid, &amp;stat));</div><div class="line">    ASSERT_EQ(100200, stat.st_size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroLengthWrite)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist empty;</div><div class="line">        t.write(cid, hoid, 1048576, 0, empty);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    struct stat stat;</div><div class="line">    r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ASSERT_EQ(0, stat.st_size);</div><div class="line"></div><div class="line">    bufferlist newdata;</div><div class="line">    r = store-&gt;read(ch, hoid, 0, 1048576, newdata);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ZeroLengthZero)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("foo", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.zero(cid, hoid, 1048576, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    struct stat stat;</div><div class="line">    r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">    ASSERT_EQ(0, stat.st_size);</div><div class="line"></div><div class="line">    bufferlist newdata;</div><div class="line">    r = store-&gt;read(ch, hoid, 0, 1048576, newdata);</div><div class="line">    ASSERT_EQ(0, r);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleAttrTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("attr object 1", CEPH_NOSNAP)));</div><div class="line">    bufferlist val, val2;</div><div class="line">    val.append("value");</div><div class="line">    val.append("value2");</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool empty;</div><div class="line">        int r = store-&gt;collection_empty(ch, &amp;empty);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ASSERT_TRUE(empty);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        r = store-&gt;getattr(ch, hoid, "nofoo", bp);</div><div class="line">        ASSERT_EQ(-ENOENT, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.setattr(cid, hoid, "foo", val);</div><div class="line">        t.setattr(cid, hoid, "bar", val2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bool empty;</div><div class="line">        int r = store-&gt;collection_empty(ch, &amp;empty);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        ASSERT_TRUE(!empty);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        r = store-&gt;getattr(ch, hoid, "nofoo", bp);</div><div class="line">        ASSERT_EQ(-ENODATA, r);</div><div class="line"></div><div class="line">        r = store-&gt;getattr(ch, hoid, "foo", bp);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(bp);</div><div class="line">        ASSERT_TRUE(bl_eq(val, bl));</div><div class="line"></div><div class="line">        map&lt;string,bufferptr&gt; bm;</div><div class="line">        r = store-&gt;getattrs(ch, hoid, bm);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleListTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 1), shard_id_t(1)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)),</div><div class="line">                            ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">            hoid.hobj.pool = 1;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        set&lt;ghobject_t&gt; saw;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (!next.is_max()) &#123;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(),</div><div class="line">                                           50,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_TRUE(sorted(objects));</div><div class="line">            cout &lt;&lt; " got " &lt;&lt; objects.size() &lt;&lt; " next " &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin(); p != objects.end();</div><div class="line">                 ++p) &#123;</div><div class="line">                if (saw.count(*p)) &#123;</div><div class="line">                    cout &lt;&lt; "got DUP " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                &#125; else &#123;</div><div class="line">                    //cout &lt;&lt; "got new " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">                saw.insert(*p);</div><div class="line">            &#125;</div><div class="line">            objects.clear();</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(saw.size(), all.size());</div><div class="line">        ASSERT_EQ(saw, all);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ListEndTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 1), shard_id_t(1)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)),</div><div class="line">                            ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">            hoid.hobj.pool = 1;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t end(hobject_t(sobject_t("object_100", CEPH_NOSNAP)),</div><div class="line">                       ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        end.hobj.pool = 1;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next;</div><div class="line">        int r = store-&gt;collection_list(ch, ghobject_t(), end, 500,</div><div class="line">                                       &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (auto &amp;p : objects) &#123;</div><div class="line">            ASSERT_NE(p, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Sort)</div><div class="line">&#123;</div><div class="line">    &#123;</div><div class="line">        hobject_t a(sobject_t("a", CEPH_NOSNAP));</div><div class="line">        hobject_t b = a;</div><div class="line">        ASSERT_EQ(a, b);</div><div class="line">        b.oid.name = "b";</div><div class="line">        ASSERT_NE(a, b);</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.pool = 1;</div><div class="line">        b.pool = 2;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.pool = 3;</div><div class="line">        ASSERT_TRUE(a &gt; b);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t a(hobject_t(sobject_t("a", CEPH_NOSNAP)));</div><div class="line">        ghobject_t b(hobject_t(sobject_t("b", CEPH_NOSNAP)));</div><div class="line">        a.hobj.pool = 1;</div><div class="line">        b.hobj.pool = 1;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.hobj.pool = -3;</div><div class="line">        ASSERT_TRUE(a &lt; b);</div><div class="line">        a.hobj.pool = 1;</div><div class="line">        b.hobj.pool = -3;</div><div class="line">        ASSERT_TRUE(a &gt; b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MultipoolListTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    int poolid = 4373;</div><div class="line">    coll_t cid = coll_t(spg_t(pg_t(0, poolid), shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    set&lt;ghobject_t&gt; all, saw;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (int i=0; i&lt;200; ++i) &#123;</div><div class="line">            string name("object_");</div><div class="line">            name += stringify(i);</div><div class="line">            ghobject_t hoid(hobject_t(sobject_t(name, CEPH_NOSNAP)));</div><div class="line">            if (rand() &amp; 1)</div><div class="line">                hoid.hobj.pool = -2 - poolid;</div><div class="line">            else</div><div class="line">                hoid.hobj.pool = poolid;</div><div class="line">            all.insert(hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (!next.is_max()) &#123;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 50,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            cout &lt;&lt; " got " &lt;&lt; objects.size() &lt;&lt; " next " &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin(); p != objects.end();</div><div class="line">                 ++p) &#123;</div><div class="line">                saw.insert(*p);</div><div class="line">            &#125;</div><div class="line">            objects.clear();</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(saw, all);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator p = all.begin(); p != all.end(); ++p)</div><div class="line">            t.remove(cid, *p);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleCloneTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small, large, xlarge, newdata, attr;</div><div class="line">    small.append("small");</div><div class="line">    large.append("large");</div><div class="line">    xlarge.append("xlarge");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        t.setattr(cid, hoid, "attr2", large);</div><div class="line">        t.setattr(cid, hoid, "attr3", xlarge);</div><div class="line">        t.write(cid, hoid, 0, small.length(), small);</div><div class="line">        t.write(cid, hoid, 10, small.length(), small);</div><div class="line">        cerr &lt;&lt; "Creating object and set attr " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP),</div><div class="line">                               "key", 123, -1, ""));</div><div class="line">    ghobject_t hoid3(hobject_t(sobject_t("Object 3", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        t.setattr(cid, hoid2, "attr2", small);</div><div class="line">        t.rmattr(cid, hoid2, "attr1");</div><div class="line">        t.write(cid, hoid, 10, large.length(), large);</div><div class="line">        t.setattr(cid, hoid, "attr1", large);</div><div class="line">        t.setattr(cid, hoid, "attr2", small);</div><div class="line">        cerr &lt;&lt; "Clone object and rm attr" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(large, newdata));</div><div class="line"></div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line"></div><div class="line">        newdata.clear();</div><div class="line">        r = store-&gt;read(ch, hoid2, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line"></div><div class="line">        r = store-&gt;getattr(ch, hoid2, "attr2", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(small, attr));</div><div class="line"></div><div class="line">        attr.clear();</div><div class="line">        r = store-&gt;getattr(ch, hoid2, "attr3", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(xlarge, attr));</div><div class="line"></div><div class="line">        attr.clear();</div><div class="line">        r = store-&gt;getattr(ch, hoid, "attr1", attr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(large, attr));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16384);</div><div class="line">        memset(p.c_str(), 1, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 2, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, pl.length(), a.length(), al);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16384);</div><div class="line">        memset(p.c_str(), 111, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr z(4096);</div><div class="line">        z.zero();</div><div class="line">        final.append(z);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 112, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, pl.length() + z.length(), a.length(), al);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist final;</div><div class="line">        bufferptr p(16000);</div><div class="line">        memset(p.c_str(), 5, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        final.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr z(1000);</div><div class="line">        z.zero();</div><div class="line">        final.append(z);</div><div class="line">        bufferptr a(8000);</div><div class="line">        memset(a.c_str(), 6, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        final.append(a);</div><div class="line">        t.write(cid, hoid, 17000, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(1048576);</div><div class="line">        memset(p.c_str(), 3, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(65536);</div><div class="line">        memset(a.c_str(), 4, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, a.length(), a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, al.length());</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, al.length()*2, pl.length() - al.length()*2);</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(65536);</div><div class="line">        memset(p.c_str(), 7, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 8, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, 32768, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, 32768);</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, final.length(), pl.length() - final.length());</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferptr p(65536);</div><div class="line">        memset(p.c_str(), 9, p.length());</div><div class="line">        bufferlist pl;</div><div class="line">        pl.append(p);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 0, pl.length(), pl);</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        bufferptr a(4096);</div><div class="line">        memset(a.c_str(), 10, a.length());</div><div class="line">        bufferlist al;</div><div class="line">        al.append(a);</div><div class="line">        t.write(cid, hoid, 33768, a.length(), al);</div><div class="line">        ASSERT_EQ(0, queue_transaction(store, ch, std::move(t)));</div><div class="line">        bufferlist rl;</div><div class="line">        bufferlist final;</div><div class="line">        final.substr_of(pl, 0, 33768);</div><div class="line">        final.append(al);</div><div class="line">        bufferlist end;</div><div class="line">        end.substr_of(pl, final.length(), pl.length() - final.length());</div><div class="line">        final.append(end);</div><div class="line">        ASSERT_EQ((int)final.length(),</div><div class="line">                  store-&gt;read(ch, hoid, 0, final.length(), rl));</div><div class="line">        /*cout &lt;&lt; "expected:\n";</div><div class="line">        final.hexdump(cout);</div><div class="line">        cout &lt;&lt; "got:\n";</div><div class="line">        rl.hexdump(cout);*/</div><div class="line">        ASSERT_TRUE(bl_eq(rl, final));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //Unfortunately we need a workaround for filestore since EXPECT_DEATH</div><div class="line">    // macro has potential issues when using /in multithread environments.</div><div class="line">    //It works well for all stores but filestore for now.</div><div class="line">    //A fix setting gtest_death_test_style = "threadsafe" doesn't help as well -</div><div class="line">    //  test app clone asserts on store folder presence.</div><div class="line">    //</div><div class="line">    if (string(GetParam()) != "filestore") &#123;</div><div class="line">        //verify if non-empty collection is properly handled after store reload</div><div class="line">        ch.reset();</div><div class="line">        r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Invalid rm coll" &lt;&lt; std::endl;</div><div class="line">        PrCtl unset_dumpable;</div><div class="line">        EXPECT_DEATH(queue_transaction(store, ch, std::move(t)), "");</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid3); //new record in db</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    //See comment above for "filestore" check explanation.</div><div class="line">    if (string(GetParam()) != "filestore") &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        //verify if non-empty collection is properly handled when there are some pending removes and live records in db</div><div class="line">        cerr &lt;&lt; "Invalid rm coll again" &lt;&lt; std::endl;</div><div class="line">        ch.reset();</div><div class="line">        r = store-&gt;umount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;mount();</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        PrCtl unset_dumpable;</div><div class="line">        EXPECT_DEATH(queue_transaction(store, ch, std::move(t)), "");</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove(cid, hoid3);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OmapSimple)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("omap_obj", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    map&lt;string,bufferlist&gt; km;</div><div class="line">    km["foo"] = small;</div><div class="line">    km["bar"].append("asdfjkasdkjdfsjkafskjsfdj");</div><div class="line">    bufferlist header;</div><div class="line">    header.append("this is a header");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_setkeys(cid, hoid, km);</div><div class="line">        t.omap_setheader(cid, hoid, header);</div><div class="line">        cerr &lt;&lt; "Creating object and set omap " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    // get header, keys</div><div class="line">    &#123;</div><div class="line">        bufferlist h;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        store-&gt;omap_get(ch, hoid, &amp;h, &amp;r);</div><div class="line">        ASSERT_TRUE(bl_eq(header, h));</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    // test iterator with seek_to_first</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        ObjectMap::ObjectMapIterator iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;seek_to_first(); iter-&gt;valid(); iter-&gt;next(false)) &#123;</div><div class="line">            r[iter-&gt;key()] = iter-&gt;value();</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    // test iterator with initial lower_bound</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        ObjectMap::ObjectMapIterator iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;lower_bound(string()); iter-&gt;valid(); iter-&gt;next(false)) &#123;</div><div class="line">            r[iter-&gt;key()] = iter-&gt;value();</div><div class="line">        &#125;</div><div class="line">        cout &lt;&lt; "r: " &lt;&lt; r &lt;&lt; std::endl;</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OmapCloneTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP),</div><div class="line">                              "key", 123, -1, ""));</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    map&lt;string,bufferlist&gt; km;</div><div class="line">    km["foo"] = small;</div><div class="line">    km["bar"].append("asdfjkasdkjdfsjkafskjsfdj");</div><div class="line">    bufferlist header;</div><div class="line">    header.append("this is a header");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_setkeys(cid, hoid, km);</div><div class="line">        t.omap_setheader(cid, hoid, header);</div><div class="line">        cerr &lt;&lt; "Creating object and set omap " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP),</div><div class="line">                               "key", 123, -1, ""));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, hoid, hoid2);</div><div class="line">        cerr &lt;&lt; "Clone object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        map&lt;string,bufferlist&gt; r;</div><div class="line">        bufferlist h;</div><div class="line">        store-&gt;omap_get(ch, hoid2, &amp;h, &amp;r);</div><div class="line">        ASSERT_TRUE(bl_eq(header, h));</div><div class="line">        ASSERT_EQ(r.size(), km.size());</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleCloneRangeTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    hoid.hobj.pool = -1;</div><div class="line">    bufferlist small, newdata;</div><div class="line">    small.append("small");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, hoid, 10, 5, small);</div><div class="line">        cerr &lt;&lt; "Creating object and write bl " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    hoid2.hobj.pool = -1;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone_range(cid, hoid, hoid2, 10, 5, 10);</div><div class="line">        cerr &lt;&lt; "Clone range object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        r = store-&gt;read(ch, hoid2, 10, 5, newdata);</div><div class="line">        ASSERT_EQ(r, 5);</div><div class="line">        ASSERT_TRUE(bl_eq(small, newdata));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, hoid, 1024*1024);</div><div class="line">        t.clone_range(cid, hoid, hoid2, 0, 1024*1024, 0);</div><div class="line">        cerr &lt;&lt; "Clone range object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        struct stat stat, stat2;</div><div class="line">        r = store-&gt;stat(ch, hoid, &amp;stat);</div><div class="line">        r = store-&gt;stat(ch, hoid2, &amp;stat2);</div><div class="line">        ASSERT_EQ(stat.st_size, stat2.st_size);</div><div class="line">        ASSERT_EQ(1024*1024, stat2.st_size);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTest, SimpleObjectLongnameTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaObjectaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ghobject_t generate_long_name(unsigned i)</div><div class="line">&#123;</div><div class="line">    stringstream name;</div><div class="line">    name &lt;&lt; "object id " &lt;&lt; i &lt;&lt; " ";</div><div class="line">    for (unsigned j = 0; j &lt; 500; ++j) name &lt;&lt; 'a';</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t(name.str(), CEPH_NOSNAP)));</div><div class="line">    hoid.hobj.set_hash(i % 2);</div><div class="line">    return hoid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, LongnameSplitTest)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    for (unsigned i = 0; i &lt; 320; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t hoid = generate_long_name(i);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t test_obj = generate_long_name(319);</div><div class="line">    ghobject_t test_obj_2 = test_obj;</div><div class="line">    test_obj_2.generation = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        // should cause a split</div><div class="line">        t.collection_move_rename(</div><div class="line">            cid, test_obj,</div><div class="line">            cid, test_obj_2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (unsigned i = 0; i &lt; 319; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t hoid = generate_long_name(i);</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        cerr &lt;&lt; "Removing object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, test_obj_2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ManyObjectTest)</div><div class="line">&#123;</div><div class="line">    int NUM_OBJS = 2000;</div><div class="line">    int r = 0;</div><div class="line">    coll_t cid;</div><div class="line">    string base = "";</div><div class="line">    for (int i = 0; i &lt; 100; ++i) base.append("aaaaa");</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        if (!(i % 5)) &#123;</div><div class="line">            cerr &lt;&lt; "Object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(string(buf) + base, CEPH_NOSNAP)));</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        created.insert(hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        struct stat buf;</div><div class="line">        ASSERT_TRUE(!store-&gt;stat(ch, *i, &amp;buf));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    set&lt;ghobject_t&gt; listed, listed2;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(), INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    cerr &lt;&lt; "objects.size() is " &lt;&lt; objects.size() &lt;&lt; std::endl;</div><div class="line">    for (vector&lt;ghobject_t&gt; ::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        listed.insert(*i);</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line"></div><div class="line">    ghobject_t start, next;</div><div class="line">    objects.clear();</div><div class="line">    r = store-&gt;collection_list(</div><div class="line">            ch,</div><div class="line">            ghobject_t::get_max(),</div><div class="line">            ghobject_t::get_max(),</div><div class="line">            50,</div><div class="line">            &amp;objects,</div><div class="line">            &amp;next</div><div class="line">        );</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_TRUE(objects.empty());</div><div class="line"></div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t start2, next2;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, start, ghobject_t::get_max(),</div><div class="line">                                   50,</div><div class="line">                                   &amp;objects,</div><div class="line">                                   &amp;next);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        listed.insert(objects.begin(), objects.end());</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line"></div><div class="line">        start = next;</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    if (listed2.size()) &#123;</div><div class="line">        ASSERT_EQ(listed.size(), listed2.size());</div><div class="line">    &#125;</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "cleaning up" &lt;&lt; std::endl;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class ObjectGenerator</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual ghobject_t create_object(gen_type *gen) = 0;</div><div class="line">    virtual ~ObjectGenerator() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class MixedGenerator : public ObjectGenerator</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    unsigned seq;</div><div class="line">    int64_t poolid;</div><div class="line">    explicit MixedGenerator(int64_t p) : seq(0), poolid(p) &#123;&#125;</div><div class="line">    ghobject_t create_object(gen_type *gen) override</div><div class="line">    &#123;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "OBJ_%u", seq);</div><div class="line">        string name(buf);</div><div class="line">        if (seq % 2) &#123;</div><div class="line">            for (unsigned i = 0; i &lt; 300; ++i) &#123;</div><div class="line">                name.push_back('a');</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++seq;</div><div class="line">        return ghobject_t(</div><div class="line">                   hobject_t(</div><div class="line">                       name, string(), rand() &amp; 2 ? CEPH_NOSNAP : rand(),</div><div class="line">                       (((seq / 1024) % 2) * 0xF00 ) +</div><div class="line">                       (seq &amp; 0xFF),</div><div class="line">                       poolid, ""));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SyntheticWorkloadState</div><div class="line">&#123;</div><div class="line">    struct Object &#123;</div><div class="line">        bufferlist data;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    static const unsigned max_in_flight = 16;</div><div class="line">    static const unsigned max_objects = 3000;</div><div class="line">    static const unsigned max_attr_size = 5;</div><div class="line">    static const unsigned max_attr_name_len = 100;</div><div class="line">    static const unsigned max_attr_value_len = 1024 * 64;</div><div class="line">    coll_t cid;</div><div class="line">    unsigned write_alignment;</div><div class="line">    unsigned max_object_len, max_write_len;</div><div class="line">    unsigned in_flight;</div><div class="line">    map&lt;ghobject_t, Object&gt; contents;</div><div class="line">    set&lt;ghobject_t&gt; available_objects;</div><div class="line">    set&lt;ghobject_t&gt; in_flight_objects;</div><div class="line">    ObjectGenerator *object_gen;</div><div class="line">    gen_type *rng;</div><div class="line">    ObjectStore *store;</div><div class="line">    ObjectStore::CollectionHandle ch;</div><div class="line"></div><div class="line">    Mutex lock;</div><div class="line">    Cond cond;</div><div class="line"></div><div class="line">    struct EnterExit &#123;</div><div class="line">        const char *msg;</div><div class="line">        explicit EnterExit(const char *m) : msg(m)</div><div class="line">        &#123;</div><div class="line">            //cout &lt;&lt; pthread_self() &lt;&lt; " enter " &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ~EnterExit()</div><div class="line">        &#123;</div><div class="line">            //cout &lt;&lt; pthread_self() &lt;&lt; " exit " &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnReadable : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t hoid;</div><div class="line">        C_SyntheticOnReadable(SyntheticWorkloadState *state, ghobject_t hoid)</div><div class="line">            : state(state), hoid(hoid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("onreadable finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(hoid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(hoid);</div><div class="line">            if (state-&gt;contents.count(hoid))</div><div class="line">                state-&gt;available_objects.insert(hoid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            state-&gt;cond.Signal();</div><div class="line"></div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(state-&gt;ch, hoid, 0, state-&gt;contents[hoid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[hoid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnStash : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t oid, noid;</div><div class="line"></div><div class="line">        C_SyntheticOnStash(SyntheticWorkloadState *state,</div><div class="line">                           ghobject_t oid, ghobject_t noid)</div><div class="line">            : state(state), oid(oid), noid(noid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("stash finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(oid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(oid);</div><div class="line">            if (state-&gt;contents.count(noid))</div><div class="line">                state-&gt;available_objects.insert(noid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(</div><div class="line">                    state-&gt;ch, noid, 0,</div><div class="line">                    state-&gt;contents[noid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[noid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class C_SyntheticOnClone : public Context</div><div class="line">    &#123;</div><div class="line">    public:</div><div class="line">        SyntheticWorkloadState *state;</div><div class="line">        ghobject_t oid, noid;</div><div class="line"></div><div class="line">        C_SyntheticOnClone(SyntheticWorkloadState *state,</div><div class="line">                           ghobject_t oid, ghobject_t noid)</div><div class="line">            : state(state), oid(oid), noid(noid) &#123;&#125;</div><div class="line"></div><div class="line">        void finish(int r) override</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(state-&gt;lock);</div><div class="line">            EnterExit ee("clone finish");</div><div class="line">            ASSERT_TRUE(state-&gt;in_flight_objects.count(oid));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            state-&gt;in_flight_objects.erase(oid);</div><div class="line">            if (state-&gt;contents.count(oid))</div><div class="line">                state-&gt;available_objects.insert(oid);</div><div class="line">            if (state-&gt;contents.count(noid))</div><div class="line">                state-&gt;available_objects.insert(noid);</div><div class="line">            --(state-&gt;in_flight);</div><div class="line">            bufferlist r2;</div><div class="line">            r = state-&gt;store-&gt;read(state-&gt;ch, noid, 0, state-&gt;contents[noid].data.length(), r2);</div><div class="line">            assert(bl_eq(state-&gt;contents[noid].data, r2));</div><div class="line">            state-&gt;cond.Signal();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    static void filled_byte_array(bufferlist&amp; bl, size_t size)</div><div class="line">    &#123;</div><div class="line">        static const char alphanum[] = "0123456789"</div><div class="line">                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</div><div class="line">                                       "abcdefghijklmnopqrstuvwxyz";</div><div class="line">        if (!size) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        bufferptr bp(size);</div><div class="line">        for (unsigned int i = 0; i &lt; size - 1; i++) &#123;</div><div class="line">            // severely limit entropy so we can compress...</div><div class="line">            bp[i] = alphanum[rand() % 10]; //(sizeof(alphanum) - 1)];</div><div class="line">        &#125;</div><div class="line">        bp[size - 1] = '\0';</div><div class="line"></div><div class="line">        bl.append(bp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SyntheticWorkloadState(ObjectStore *store,</div><div class="line">                           ObjectGenerator *gen,</div><div class="line">                           gen_type *rng,</div><div class="line">                           coll_t cid,</div><div class="line">                           unsigned max_size,</div><div class="line">                           unsigned max_write,</div><div class="line">                           unsigned alignment)</div><div class="line">        : cid(cid), write_alignment(alignment), max_object_len(max_size),</div><div class="line">          max_write_len(max_write), in_flight(0), object_gen(gen),</div><div class="line">          rng(rng), store(store),</div><div class="line">          lock("State lock") &#123;&#125;</div><div class="line"></div><div class="line">    int init()</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ch = store-&gt;create_new_collection(cid);</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        return queue_transaction(store, ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">    void shutdown()</div><div class="line">    &#123;</div><div class="line">        while (1) &#123;</div><div class="line">            vector&lt;ghobject_t&gt; objects;</div><div class="line">            int r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                           10, &amp;objects, 0);</div><div class="line">            assert(r &gt;= 0);</div><div class="line">            if (objects.empty())</div><div class="line">                break;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            for (vector&lt;ghobject_t&gt;::iterator p = objects.begin();</div><div class="line">                 p != objects.end(); ++p) &#123;</div><div class="line">                t.remove(cid, *p);</div><div class="line">            &#125;</div><div class="line">            queue_transaction(store, ch, std::move(t));</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        queue_transaction(store, ch, std::move(t));</div><div class="line">    &#125;</div><div class="line">    void statfs(store_statfs_t&amp; stat)</div><div class="line">    &#123;</div><div class="line">        store-&gt;statfs(&amp;stat);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ghobject_t get_uniform_random_object()</div><div class="line">    &#123;</div><div class="line">        while (in_flight &gt;= max_in_flight || available_objects.empty())</div><div class="line">            cond.Wait(lock);</div><div class="line">        boost::uniform_int&lt;&gt; choose(0, available_objects.size() - 1);</div><div class="line">        int index = choose(*rng);</div><div class="line">        set&lt;ghobject_t&gt;::iterator i = available_objects.begin();</div><div class="line">        for ( ; index &gt; 0; --index, ++i) ;</div><div class="line">        ghobject_t ret = *i;</div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void wait_for_ready()</div><div class="line">    &#123;</div><div class="line">        while (in_flight &gt;= max_in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void wait_for_done()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool can_create()</div><div class="line">    &#123;</div><div class="line">        return (available_objects.size() + in_flight_objects.size()) &lt; max_objects;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool can_unlink()</div><div class="line">    &#123;</div><div class="line">        return (available_objects.size() + in_flight_objects.size()) &gt; 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    unsigned get_random_alloc_hints()</div><div class="line">    &#123;</div><div class="line">        unsigned f = 0;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_WRITE;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SEQUENTIAL_READ;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_RANDOM_READ;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            // append_only, immutable</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 4);</div><div class="line">            f |= u(*rng) &lt;&lt; 4;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_SHORTLIVED;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_LONGLIVED;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            boost::uniform_int&lt;&gt; u(0, 3);</div><div class="line">            switch (u(*rng)) &#123;</div><div class="line">            case 1:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                f |= CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return f;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int touch()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("touch");</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line">        ghobject_t new_obj = object_gen-&gt;create_object(rng);</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, new_obj);</div><div class="line">        boost::uniform_int&lt;&gt; u(17, 22);</div><div class="line">        boost::uniform_int&lt;&gt; v(12, 17);</div><div class="line">        t.set_alloc_hint(cid, new_obj,</div><div class="line">                         1ull &lt;&lt; u(*rng),</div><div class="line">                         1ull &lt;&lt; v(*rng),</div><div class="line">                         get_random_alloc_hints());</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        if (!contents.count(new_obj))</div><div class="line">            contents[new_obj] = Object();</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int stash()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("stash");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = old_obj;</div><div class="line">        new_obj.generation++;</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.collection_move_rename(cid, old_obj, cid, new_obj);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        contents[new_obj].attrs = contents[old_obj].attrs;</div><div class="line">        contents[new_obj].data = contents[old_obj].data;</div><div class="line">        contents.erase(old_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnStash(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int clone()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("clone");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = object_gen-&gt;create_object(rng);</div><div class="line">        // make the hash match</div><div class="line">        new_obj.hobj.set_hash(old_obj.hobj.get_hash());</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone(cid, old_obj, new_obj);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        contents[new_obj].attrs = contents[old_obj].attrs;</div><div class="line">        contents[new_obj].data = contents[old_obj].data;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnClone(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int clone_range()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("clone_range");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        if (!can_create())</div><div class="line">            return -ENOSPC;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t old_obj;</div><div class="line">        int max = 20;</div><div class="line">        do &#123;</div><div class="line">            old_obj = get_uniform_random_object();</div><div class="line">        &#125; while (--max &amp;&amp; !contents[old_obj].data.length());</div><div class="line">        bufferlist &amp;srcdata = contents[old_obj].data;</div><div class="line">        if (srcdata.length() == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        available_objects.erase(old_obj);</div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t srcoff = u1(*rng);</div><div class="line">        // make src and dst offsets match, since that's what the osd does</div><div class="line">        uint64_t dstoff = srcoff; //u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            srcoff = round_up_to(srcoff, write_alignment);</div><div class="line">            dstoff = round_up_to(dstoff, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (srcoff &gt; srcdata.length() - 1) &#123;</div><div class="line">            srcoff = srcdata.length() - 1;</div><div class="line">        &#125;</div><div class="line">        if (srcoff + len &gt; srcdata.length()) &#123;</div><div class="line">            len = srcdata.length() - srcoff;</div><div class="line">        &#125;</div><div class="line">        if (0)</div><div class="line">            cout &lt;&lt; __func__ &lt;&lt; " from " &lt;&lt; srcoff &lt;&lt; "~" &lt;&lt; len</div><div class="line">                 &lt;&lt; " (size " &lt;&lt; srcdata.length() &lt;&lt; ") to "</div><div class="line">                 &lt;&lt; dstoff &lt;&lt; "~" &lt;&lt; len &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.clone_range(cid, old_obj, new_obj, srcoff, len, dstoff);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(old_obj);</div><div class="line"></div><div class="line">        bufferlist bl;</div><div class="line">        if (srcoff &lt; srcdata.length()) &#123;</div><div class="line">            if (srcoff + len &gt; srcdata.length()) &#123;</div><div class="line">                bl.substr_of(srcdata, srcoff, srcdata.length() - srcoff);</div><div class="line">            &#125; else &#123;</div><div class="line">                bl.substr_of(srcdata, srcoff, len);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist&amp; dstdata = contents[new_obj].data;</div><div class="line">        if (dstdata.length() &lt;= dstoff) &#123;</div><div class="line">            if (bl.length() &gt; 0) &#123;</div><div class="line">                dstdata.append_zero(dstoff - dstdata.length());</div><div class="line">                dstdata.append(bl);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist value;</div><div class="line">            assert(dstdata.length() &gt; dstoff);</div><div class="line">            dstdata.copy(0, dstoff, value);</div><div class="line">            value.append(bl);</div><div class="line">            if (value.length() &lt; dstdata.length())</div><div class="line">                dstdata.copy(value.length(),</div><div class="line">                             dstdata.length() - value.length(), value);</div><div class="line">            value.swap(dstdata);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnClone(this, old_obj, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    int write()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("write");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        bufferlist bl;</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            offset = round_up_to(offset, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        filled_byte_array(bl, len);</div><div class="line"></div><div class="line">        bufferlist&amp; data = contents[new_obj].data;</div><div class="line">        if (data.length() &lt;= offset) &#123;</div><div class="line">            if (len &gt; 0) &#123;</div><div class="line">                data.append_zero(offset-data.length());</div><div class="line">                data.append(bl);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist value;</div><div class="line">            assert(data.length() &gt; offset);</div><div class="line">            data.copy(0, offset, value);</div><div class="line">            value.append(bl);</div><div class="line">            if (value.length() &lt; data.length())</div><div class="line">                data.copy(value.length(),</div><div class="line">                          data.length()-value.length(), value);</div><div class="line">            value.swap(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.write(cid, new_obj, offset, len, bl);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int truncate()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("truncate");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; choose(0, max_object_len);</div><div class="line">        size_t len = choose(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.truncate(cid, obj, len);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        bufferlist&amp; data = contents[obj].data;</div><div class="line">        if (data.length() &lt;= len) &#123;</div><div class="line">            data.append_zero(len - data.length());</div><div class="line">        &#125; else &#123;</div><div class="line">            bufferlist bl;</div><div class="line">            data.copy(0, len, bl);</div><div class="line">            bl.swap(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int zero()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("zero");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t new_obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(new_obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len - max_write_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_write_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (write_alignment) &#123;</div><div class="line">            offset = round_up_to(offset, write_alignment);</div><div class="line">            len = round_up_to(len, write_alignment);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (len &gt; 0) &#123;</div><div class="line">            auto&amp; data = contents[new_obj].data;</div><div class="line">            if (data.length() &lt; offset + len) &#123;</div><div class="line">                data.append_zero(offset+len-data.length());</div><div class="line">            &#125;</div><div class="line">            bufferlist n;</div><div class="line">            n.substr_of(data, 0, offset);</div><div class="line">            n.append_zero(len);</div><div class="line">            if (data.length() &gt; offset + len)</div><div class="line">                data.copy(offset + len, data.length() - offset - len, n);</div><div class="line">            data.swap(n);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        t.zero(cid, new_obj, offset, len);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(new_obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, new_obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void read()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("read");</div><div class="line">        boost::uniform_int&lt;&gt; u1(0, max_object_len/2);</div><div class="line">        boost::uniform_int&lt;&gt; u2(0, max_object_len);</div><div class="line">        uint64_t offset = u1(*rng);</div><div class="line">        uint64_t len = u2(*rng);</div><div class="line">        if (offset &gt; len)</div><div class="line">            swap(offset, len);</div><div class="line"></div><div class="line">        ghobject_t obj;</div><div class="line">        bufferlist expected;</div><div class="line">        int r;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("read locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            obj = get_uniform_random_object();</div><div class="line">            expected = contents[obj].data;</div><div class="line">        &#125;</div><div class="line">        bufferlist bl, result;</div><div class="line">        if (0) cout &lt;&lt; " obj " &lt;&lt; obj</div><div class="line">                        &lt;&lt; " size " &lt;&lt; expected.length()</div><div class="line">                        &lt;&lt; " offset " &lt;&lt; offset</div><div class="line">                        &lt;&lt; " len " &lt;&lt; len &lt;&lt; std::endl;</div><div class="line">        r = store-&gt;read(ch, obj, offset, len, result);</div><div class="line">        if (offset &gt;= expected.length()) &#123;</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            size_t max_len = expected.length() - offset;</div><div class="line">            if (len &gt; max_len)</div><div class="line">                len = max_len;</div><div class="line">            assert(len == result.length());</div><div class="line">            ASSERT_EQ(len, result.length());</div><div class="line">            expected.copy(offset, len, bl);</div><div class="line">            ASSERT_EQ(r, (int)len);</div><div class="line">            ASSERT_TRUE(bl_eq(bl, result));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int setattrs()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("setattrs");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj = get_uniform_random_object();</div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u0(1, max_attr_size);</div><div class="line">        boost::uniform_int&lt;&gt; u1(4, max_attr_name_len);</div><div class="line">        boost::uniform_int&lt;&gt; u2(4, max_attr_value_len);</div><div class="line">        boost::uniform_int&lt;&gt; u3(0, 100);</div><div class="line">        uint64_t size = u0(*rng);</div><div class="line">        uint64_t name_len;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator it = contents[obj].attrs.begin();</div><div class="line">             it != contents[obj].attrs.end(); ++it)</div><div class="line">            keys.insert(it-&gt;first);</div><div class="line"></div><div class="line">        while (size--) &#123;</div><div class="line">            bufferlist name, value;</div><div class="line">            uint64_t get_exist = u3(*rng);</div><div class="line">            uint64_t value_len = u2(*rng);</div><div class="line">            filled_byte_array(value, value_len);</div><div class="line">            if (get_exist &lt; 50 &amp;&amp; keys.size()) &#123;</div><div class="line">                set&lt;string&gt;::iterator k = keys.begin();</div><div class="line">                attrs[*k] = value;</div><div class="line">                contents[obj].attrs[*k] = value;</div><div class="line">                keys.erase(k);</div><div class="line">            &#125; else &#123;</div><div class="line">                name_len = u1(*rng);</div><div class="line">                filled_byte_array(name, name_len);</div><div class="line">                attrs[name.c_str()] = value;</div><div class="line">                contents[obj].attrs[name.c_str()] = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        t.setattrs(cid, obj, attrs);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void getattrs()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("getattrs");</div><div class="line">        ghobject_t obj;</div><div class="line">        map&lt;string, bufferlist&gt; expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("getattrs locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            int retry = 10;</div><div class="line">            do &#123;</div><div class="line">                obj = get_uniform_random_object();</div><div class="line">                if (!--retry)</div><div class="line">                    return ;</div><div class="line">            &#125; while (contents[obj].attrs.empty());</div><div class="line">            expected = contents[obj].attrs;</div><div class="line">        &#125;</div><div class="line">        map&lt;string, bufferlist&gt; attrs;</div><div class="line">        int r = store-&gt;getattrs(ch, obj, attrs);</div><div class="line">        ASSERT_TRUE(r == 0);</div><div class="line">        ASSERT_TRUE(attrs.size() == expected.size());</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator it = expected.begin();</div><div class="line">             it != expected.end(); ++it) &#123;</div><div class="line">            ASSERT_TRUE(bl_eq(attrs[it-&gt;first], it-&gt;second));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void getattr()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("getattr");</div><div class="line">        ghobject_t obj;</div><div class="line">        int r;</div><div class="line">        int retry;</div><div class="line">        map&lt;string, bufferlist&gt; expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("getattr locked");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            wait_for_ready();</div><div class="line"></div><div class="line">            retry = 10;</div><div class="line">            do &#123;</div><div class="line">                obj = get_uniform_random_object();</div><div class="line">                if (!--retry)</div><div class="line">                    return ;</div><div class="line">            &#125; while (contents[obj].attrs.empty());</div><div class="line">            expected = contents[obj].attrs;</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; u(0, expected.size()-1);</div><div class="line">        retry = u(*rng);</div><div class="line">        map&lt;string, bufferlist&gt;::iterator it = expected.begin();</div><div class="line">        while (retry) &#123;</div><div class="line">            retry--;</div><div class="line">            ++it;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bufferlist bl;</div><div class="line">        r = store-&gt;getattr(ch, obj, it-&gt;first, bl);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(it-&gt;second, bl));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int rmattr()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("rmattr");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        wait_for_ready();</div><div class="line"></div><div class="line">        ghobject_t obj;</div><div class="line">        int retry = 10;</div><div class="line">        do &#123;</div><div class="line">            obj = get_uniform_random_object();</div><div class="line">            if (!--retry)</div><div class="line">                return 0;</div><div class="line">        &#125; while (contents[obj].attrs.empty());</div><div class="line"></div><div class="line">        boost::uniform_int&lt;&gt; u(0, contents[obj].attrs.size()-1);</div><div class="line">        retry = u(*rng);</div><div class="line">        map&lt;string, bufferlist&gt;::iterator it = contents[obj].attrs.begin();</div><div class="line">        while (retry) &#123;</div><div class="line">            retry--;</div><div class="line">            ++it;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        available_objects.erase(obj);</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.rmattr(cid, obj, it-&gt;first);</div><div class="line"></div><div class="line">        contents[obj].attrs.erase(it-&gt;first);</div><div class="line">        ++in_flight;</div><div class="line">        in_flight_objects.insert(obj);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, obj));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void fsck(bool deep)</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("fsck");</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">        ch.reset();</div><div class="line">        store-&gt;umount();</div><div class="line">        int r = store-&gt;fsck(deep);</div><div class="line">        assert(r == 0 || r == -EOPNOTSUPP);</div><div class="line">        store-&gt;mount();</div><div class="line">        ch = store-&gt;open_collection(cid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void scan()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("scan");</div><div class="line">        while (in_flight)</div><div class="line">            cond.Wait(lock);</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        set&lt;ghobject_t&gt; objects_set, objects_set2;</div><div class="line">        ghobject_t next, current;</div><div class="line">        while (1) &#123;</div><div class="line">            //cerr &lt;&lt; "scanning..." &lt;&lt; std::endl;</div><div class="line">            int r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 100,</div><div class="line">                                           &amp;objects, &amp;next);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_TRUE(sorted(objects));</div><div class="line">            objects_set.insert(objects.begin(), objects.end());</div><div class="line">            objects.clear();</div><div class="line">            if (next.is_max()) break;</div><div class="line">            current = next;</div><div class="line">        &#125;</div><div class="line">        if (objects_set.size() != available_objects.size()) &#123;</div><div class="line">            for (set&lt;ghobject_t&gt;::iterator p = objects_set.begin();</div><div class="line">                 p != objects_set.end();</div><div class="line">                 ++p)</div><div class="line">                if (available_objects.count(*p) == 0) &#123;</div><div class="line">                    cerr &lt;&lt; "+ " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">                    ceph_abort();</div><div class="line">                &#125;</div><div class="line">            for (set&lt;ghobject_t&gt;::iterator p = available_objects.begin();</div><div class="line">                 p != available_objects.end();</div><div class="line">                 ++p)</div><div class="line">                if (objects_set.count(*p) == 0)</div><div class="line">                    cerr &lt;&lt; "- " &lt;&lt; *p &lt;&lt; std::endl;</div><div class="line">            //cerr &lt;&lt; " objects_set: " &lt;&lt; objects_set &lt;&lt; std::endl;</div><div class="line">            //cerr &lt;&lt; " available_set: " &lt;&lt; available_objects &lt;&lt; std::endl;</div><div class="line">            assert(0 == "badness");</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ASSERT_EQ(objects_set.size(), available_objects.size());</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator i = objects_set.begin();</div><div class="line">             i != objects_set.end();</div><div class="line">             ++i) &#123;</div><div class="line">            ASSERT_GT(available_objects.count(*i), (unsigned)0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                       INT_MAX, &amp;objects, 0);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        objects_set2.insert(objects.begin(), objects.end());</div><div class="line">        ASSERT_EQ(objects_set2.size(), available_objects.size());</div><div class="line">        for (set&lt;ghobject_t&gt;::iterator i = objects_set2.begin();</div><div class="line">             i != objects_set2.end();</div><div class="line">             ++i) &#123;</div><div class="line">            ASSERT_GT(available_objects.count(*i), (unsigned)0);</div><div class="line">            if (available_objects.count(*i) == 0) &#123;</div><div class="line">                cerr &lt;&lt; "+ " &lt;&lt; *i &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void stat()</div><div class="line">    &#123;</div><div class="line">        EnterExit ee("stat");</div><div class="line">        ghobject_t hoid;</div><div class="line">        uint64_t expected;</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("stat lock1");</div><div class="line">            if (!can_unlink())</div><div class="line">                return ;</div><div class="line">            hoid = get_uniform_random_object();</div><div class="line">            in_flight_objects.insert(hoid);</div><div class="line">            available_objects.erase(hoid);</div><div class="line">            ++in_flight;</div><div class="line">            expected = contents[hoid].data.length();</div><div class="line">        &#125;</div><div class="line">        struct stat buf;</div><div class="line">        int r = store-&gt;stat(ch, hoid, &amp;buf);</div><div class="line">        ASSERT_EQ(0, r);</div><div class="line">        assert((uint64_t)buf.st_size == expected);</div><div class="line">        ASSERT_TRUE((uint64_t)buf.st_size == expected);</div><div class="line">        &#123;</div><div class="line">            Mutex::Locker locker(lock);</div><div class="line">            EnterExit ee("stat lock2");</div><div class="line">            --in_flight;</div><div class="line">            cond.Signal();</div><div class="line">            in_flight_objects.erase(hoid);</div><div class="line">            available_objects.insert(hoid);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int unlink()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        EnterExit ee("unlink");</div><div class="line">        if (!can_unlink())</div><div class="line">            return -ENOENT;</div><div class="line">        ghobject_t to_remove = get_uniform_random_object();</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, to_remove);</div><div class="line">        ++in_flight;</div><div class="line">        available_objects.erase(to_remove);</div><div class="line">        in_flight_objects.insert(to_remove);</div><div class="line">        contents.erase(to_remove);</div><div class="line">        t.register_on_applied(new C_SyntheticOnReadable(this, to_remove));</div><div class="line">        int status = store-&gt;queue_transaction(ch, std::move(t));</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void print_internal_state()</div><div class="line">    &#123;</div><div class="line">        Mutex::Locker locker(lock);</div><div class="line">        cerr &lt;&lt; "available_objects: " &lt;&lt; available_objects.size()</div><div class="line">             &lt;&lt; " in_flight_objects: " &lt;&lt; in_flight_objects.size()</div><div class="line">             &lt;&lt; " total objects: " &lt;&lt; in_flight_objects.size() + available_objects.size()</div><div class="line">             &lt;&lt; " in_flight " &lt;&lt; in_flight &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">void StoreTest::doSyntheticTest(</div><div class="line">    int num_ops,</div><div class="line">    uint64_t max_obj, uint64_t max_wr, uint64_t align)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(555);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(), &amp;gen, &amp;rng, cid,</div><div class="line">                                    max_obj, max_wr, align);</div><div class="line">    test_obj.init();</div><div class="line">    for (int i = 0; i &lt; num_ops/10; ++i) &#123;</div><div class="line">        if (!(i % 500)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; num_ops; ++i) &#123;</div><div class="line">        if (!(i % 1000)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; true_false(0, 999);</div><div class="line">        int val = true_false(rng);</div><div class="line">        if (val &gt; 998) &#123;</div><div class="line">            test_obj.fsck(true);</div><div class="line">        &#125; else if (val &gt; 997) &#123;</div><div class="line">            test_obj.fsck(false);</div><div class="line">        &#125; else if (val &gt; 970) &#123;</div><div class="line">            test_obj.scan();</div><div class="line">        &#125; else if (val &gt; 950) &#123;</div><div class="line">            test_obj.stat();</div><div class="line">        &#125; else if (val &gt; 850) &#123;</div><div class="line">            test_obj.zero();</div><div class="line">        &#125; else if (val &gt; 800) &#123;</div><div class="line">            test_obj.unlink();</div><div class="line">        &#125; else if (val &gt; 550) &#123;</div><div class="line">            test_obj.write();</div><div class="line">        &#125; else if (val &gt; 500) &#123;</div><div class="line">            test_obj.clone();</div><div class="line">        &#125; else if (val &gt; 450) &#123;</div><div class="line">            test_obj.clone_range();</div><div class="line">        &#125; else if (val &gt; 300) &#123;</div><div class="line">            test_obj.stash();</div><div class="line">        &#125; else if (val &gt; 100) &#123;</div><div class="line">            test_obj.read();</div><div class="line">        &#125; else &#123;</div><div class="line">            test_obj.truncate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Synthetic)</div><div class="line">&#123;</div><div class="line">    doSyntheticTest(10000, 400*1024, 40*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixSharding)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", 0 &#125;, // must be the first!</div><div class="line">        &#123; "num_ops", "50000", 0 &#125;,</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "262144", 0 &#125;,</div><div class="line">        &#123; "alignment", "4096", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_min_size", "60", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_max_size", "300", 0 &#125;,</div><div class="line">        &#123; "bluestore_extent_map_shard_target_size", "150", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, ZipperPatternSharded)</div><div class="line">&#123;</div><div class="line">    if(string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(4096);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t a(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist bl;</div><div class="line">    int len = 4096;</div><div class="line">    bufferptr bp(len);</div><div class="line">    bp.zero();</div><div class="line">    bl.append(bp);</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*2*len, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i=0; i&lt;1000; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.write(cid, a, i*2*len + 1, len, bl, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, a);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCsumAlgorithm)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "65536", 0 &#125;, // must be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "16", 0 &#125;,</div><div class="line">        &#123;</div><div class="line">            "bluestore_csum_type", "crc32c", "crc32c_16", "crc32c_8", "xxhash32",</div><div class="line">            "xxhash64", "none", 0</div><div class="line">        &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCsumVsCompression)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "16384", 0 &#125;, //to be the first!</div><div class="line">        &#123; "max_write", "131072", 0 &#125;,</div><div class="line">        &#123; "max_size", "262144", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", 0&#125;,</div><div class="line">        &#123; "bluestore_compression_algorithm", "snappy", "zlib", 0 &#125;,</div><div class="line">        &#123; "bluestore_csum_type", "crc32c", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCompression)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "1048576", 0 &#125;,</div><div class="line">        &#123; "max_size", "4194304", 0 &#125;,</div><div class="line">        &#123; "alignment", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "aggressive", "passive", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "true", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixCompressionAlgorithm)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "1048576", 0 &#125;,</div><div class="line">        &#123; "max_size", "4194304", 0 &#125;,</div><div class="line">        &#123; "alignment", "65536", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_algorithm", "zlib", "snappy", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixNoCsum)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "262144", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_csum_type", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_default_buffered_read", "true", "false", 0 &#125;,</div><div class="line">        &#123; "bluestore_default_buffered_write", "true", 0 &#125;,</div><div class="line">        &#123; "bluestore_sync_submit_transaction", "true", "false", 0 &#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, SyntheticMatrixPreferDeferred)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    const char *m[][10] = &#123;</div><div class="line">        &#123; "bluestore_min_alloc_size", "4096", "65536", 0 &#125;, // to be the first!</div><div class="line">        &#123; "max_write", "65536", 0 &#125;,</div><div class="line">        &#123; "max_size", "1048576", 0 &#125;,</div><div class="line">        &#123; "alignment", "512", 0 &#125;,</div><div class="line">        &#123; "bluestore_max_blob_size", "262144", 0 &#125;,</div><div class="line">        &#123; "bluestore_compression_mode", "force", "none", 0&#125;,</div><div class="line">        &#123; "bluestore_prefer_deferred_size", "32768", "0", 0&#125;,</div><div class="line">        &#123; 0 &#125;,</div><div class="line">    &#125;;</div><div class="line">    do_matrix(m, std::bind(&amp;StoreTest::doSyntheticTest, this, _1, _2, _3, _4));</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, AttrSynthetic)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(447);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,447),shard_id_t::NO_SHARD));</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(), &amp;gen, &amp;rng, cid, 40*1024, 4*1024, 0);</div><div class="line">    test_obj.init();</div><div class="line">    for (int i = 0; i &lt; 500; ++i) &#123;</div><div class="line">        if (!(i % 10)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">        if (!(i % 100)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        boost::uniform_int&lt;&gt; true_false(0, 99);</div><div class="line">        int val = true_false(rng);</div><div class="line">        if (val &gt; 97) &#123;</div><div class="line">            test_obj.scan();</div><div class="line">        &#125; else if (val &gt; 93) &#123;</div><div class="line">            test_obj.stat();</div><div class="line">        &#125; else if (val &gt; 75) &#123;</div><div class="line">            test_obj.rmattr();</div><div class="line">        &#125; else if (val &gt; 47) &#123;</div><div class="line">            test_obj.setattrs();</div><div class="line">        &#125; else if (val &gt; 45) &#123;</div><div class="line">            test_obj.clone();</div><div class="line">        &#125; else if (val &gt; 37) &#123;</div><div class="line">            test_obj.stash();</div><div class="line">        &#125; else if (val &gt; 30) &#123;</div><div class="line">            test_obj.getattrs();</div><div class="line">        &#125; else &#123;</div><div class="line">            test_obj.getattr();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, HashCollisionTest)</div><div class="line">&#123;</div><div class="line">    int64_t poolid = 11;</div><div class="line">    coll_t cid(spg_t(pg_t(0,poolid),shard_id_t::NO_SHARD));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    string base = "";</div><div class="line">    for (int i = 0; i &lt; 100; ++i) base.append("aaaaa");</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    for (int n = 0; n &lt; 10; ++n) &#123;</div><div class="line">        char nbuf[100];</div><div class="line">        sprintf(nbuf, "n%d", n);</div><div class="line">        for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">            char buf[100];</div><div class="line">            sprintf(buf, "%d", i);</div><div class="line">            if (!(i % 100)) &#123;</div><div class="line">                cerr &lt;&lt; "Object n" &lt;&lt; n &lt;&lt; " "&lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            ghobject_t hoid(hobject_t(string(buf) + base, string(), CEPH_NOSNAP, 0, poolid, string(nbuf)));</div><div class="line">            &#123;</div><div class="line">                ObjectStore::Transaction t;</div><div class="line">                t.touch(cid, hoid);</div><div class="line">                r = queue_transaction(store, ch, std::move(t));</div><div class="line">                ASSERT_EQ(r, 0);</div><div class="line">            &#125;</div><div class="line">            created.insert(hoid);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(), INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    set&lt;ghobject_t&gt; listed(objects.begin(), objects.end());</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; " and created.size() is " &lt;&lt; created.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t current, next;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 60,</div><div class="line">                                   &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">             i != objects.end();</div><div class="line">             ++i) &#123;</div><div class="line">            if (listed.count(*i))</div><div class="line">                cerr &lt;&lt; *i &lt;&lt; " repeated" &lt;&lt; std::endl;</div><div class="line">            listed.insert(*i);</div><div class="line">        &#125;</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ScrubTest)</div><div class="line">&#123;</div><div class="line">    int64_t poolid = 111;</div><div class="line">    coll_t cid(spg_t(pg_t(0, poolid),shard_id_t(1)));</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    string base = "aaaaa";</div><div class="line">    set&lt;ghobject_t&gt; created;</div><div class="line">    for (int i = 0; i &lt; 1000; ++i) &#123;</div><div class="line">        char buf[100];</div><div class="line">        sprintf(buf, "%d", i);</div><div class="line">        if (!(i % 5)) &#123;</div><div class="line">            cerr &lt;&lt; "Object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ghobject_t hoid(hobject_t(string(buf) + base, string(), CEPH_NOSNAP, i,</div><div class="line">                                  poolid, ""),</div><div class="line">                        ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        created.insert(hoid);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add same hobject_t but different generation</div><div class="line">    &#123;</div><div class="line">        ghobject_t hoid1(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""),</div><div class="line">                         ghobject_t::NO_GEN, shard_id_t(1));</div><div class="line">        ghobject_t hoid2(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""), (gen_t)1, shard_id_t(1));</div><div class="line">        ghobject_t hoid3(hobject_t("same-object", string(), CEPH_NOSNAP, 0, poolid, ""), (gen_t)2, shard_id_t(1));</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid1);</div><div class="line">        t.touch(cid, hoid2);</div><div class="line">        t.touch(cid, hoid3);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        created.insert(hoid1);</div><div class="line">        created.insert(hoid2);</div><div class="line">        created.insert(hoid3);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    set&lt;ghobject_t&gt; listed(objects.begin(), objects.end());</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; " and created.size() is " &lt;&lt; created.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    objects.clear();</div><div class="line">    listed.clear();</div><div class="line">    ghobject_t current, next;</div><div class="line">    while (1) &#123;</div><div class="line">        r = store-&gt;collection_list(ch, current, ghobject_t::get_max(), 60,</div><div class="line">                                   &amp;objects, &amp;next);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(sorted(objects));</div><div class="line">        for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">             i != objects.end(); ++i) &#123;</div><div class="line">            if (listed.count(*i))</div><div class="line">                cerr &lt;&lt; *i &lt;&lt; " repeated" &lt;&lt; std::endl;</div><div class="line">            listed.insert(*i);</div><div class="line">        &#125;</div><div class="line">        if (objects.size() &lt; 50) &#123;</div><div class="line">            ASSERT_TRUE(next.is_max());</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        objects.clear();</div><div class="line">        current = next.get_boundary();</div><div class="line">    &#125;</div><div class="line">    cerr &lt;&lt; "listed.size() is " &lt;&lt; listed.size() &lt;&lt; std::endl;</div><div class="line">    ASSERT_TRUE(listed.size() == created.size());</div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = listed.begin();</div><div class="line">         i != listed.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_TRUE(created.count(*i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (set&lt;ghobject_t&gt;::iterator i = created.begin();</div><div class="line">         i != created.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, *i);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">TEST_P(StoreTest, OMapTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_clear(cid, hoid);</div><div class="line">        map&lt;string, bufferlist&gt; start_set;</div><div class="line">        t.omap_setkeys(cid, hoid, start_set);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator j = attrs.begin();</div><div class="line">             j != attrs.end();</div><div class="line">             ++j) &#123;</div><div class="line">            bool correct = cur_attrs.count(j-&gt;first) &amp;&amp; string(cur_attrs[j-&gt;first].c_str()) == string(j-&gt;second.c_str());</div><div class="line">            if (!correct) &#123;</div><div class="line">                std::cout &lt;&lt; j-&gt;first &lt;&lt; " is present in cur_attrs " &lt;&lt; cur_attrs.count(j-&gt;first) &lt;&lt; " times " &lt;&lt; std::endl;</div><div class="line">                if (cur_attrs.count(j-&gt;first) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; j-&gt;second.c_str() &lt;&lt; " : " &lt;&lt; cur_attrs[j-&gt;first].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ(attrs.size(), cur_attrs.size());</div><div class="line"></div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        bl.clear();</div><div class="line">        bufferptr bp(buf, strlen(buf) + 1);</div><div class="line">        bl.append(bp);</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        attrs.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int i = 0;</div><div class="line">    while (attrs.size()) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "removal: On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        for (map&lt;string, bufferlist&gt;::iterator j = attrs.begin();</div><div class="line">             j != attrs.end();</div><div class="line">             ++j) &#123;</div><div class="line">            bool correct = cur_attrs.count(j-&gt;first) &amp;&amp; string(cur_attrs[j-&gt;first].c_str()) == string(j-&gt;second.c_str());</div><div class="line">            if (!correct) &#123;</div><div class="line">                std::cout &lt;&lt; j-&gt;first &lt;&lt; " is present in cur_attrs " &lt;&lt; cur_attrs.count(j-&gt;first) &lt;&lt; " times " &lt;&lt; std::endl;</div><div class="line">                if (cur_attrs.count(j-&gt;first) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; j-&gt;second.c_str() &lt;&lt; " : " &lt;&lt; cur_attrs[j-&gt;first].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        string to_remove = attrs.begin()-&gt;first;</div><div class="line">        set&lt;string&gt; keys_to_remove;</div><div class="line">        keys_to_remove.insert(to_remove);</div><div class="line">        t.omap_rmkeys(cid, hoid, keys_to_remove);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        attrs.erase(to_remove);</div><div class="line"></div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        bufferlist bl1;</div><div class="line">        bl1.append("omap_header");</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.omap_setheader(cid, hoid, bl1);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">        bufferlist bl2;</div><div class="line">        bl2.append("value");</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key", bl2));</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist bl3;</div><div class="line">        map&lt;string, bufferlist&gt; cur_attrs;</div><div class="line">        r = store-&gt;omap_get(ch, hoid, &amp;bl3, &amp;cur_attrs);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(cur_attrs.size(), size_t(1));</div><div class="line">        ASSERT_TRUE(bl_eq(bl1, bl3));</div><div class="line"></div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        r = store-&gt;omap_get_keys(ch, hoid, &amp;keys);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(keys.size(), size_t(1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // test omap_clear, omap_rmkey_range</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            map&lt;string,bufferlist&gt; to_set;</div><div class="line">            for (int n=0; n&lt;10; ++n) &#123;</div><div class="line">                to_set[stringify(n)].append("foo");</div><div class="line">            &#125;</div><div class="line">            bufferlist h;</div><div class="line">            h.append("header");</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.remove(cid, hoid);</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            t.omap_setheader(cid, hoid, h);</div><div class="line">            t.omap_setkeys(cid, hoid, to_set);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.omap_rmkeyrange(cid, hoid, "3", "7");</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            bufferlist hdr;</div><div class="line">            map&lt;string,bufferlist&gt; m;</div><div class="line">            store-&gt;omap_get(ch, hoid, &amp;hdr, &amp;m);</div><div class="line">            ASSERT_EQ(6u, hdr.length());</div><div class="line">            ASSERT_TRUE(m.count("2"));</div><div class="line">            ASSERT_TRUE(!m.count("3"));</div><div class="line">            ASSERT_TRUE(!m.count("6"));</div><div class="line">            ASSERT_TRUE(m.count("7"));</div><div class="line">            ASSERT_TRUE(m.count("8"));</div><div class="line">            //cout &lt;&lt; m &lt;&lt; std::endl;</div><div class="line">            ASSERT_EQ(6u, m.size());</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.omap_clear(cid, hoid);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            bufferlist hdr;</div><div class="line">            map&lt;string,bufferlist&gt; m;</div><div class="line">            store-&gt;omap_get(ch, hoid, &amp;hdr, &amp;m);</div><div class="line">            ASSERT_EQ(0u, hdr.length());</div><div class="line">            ASSERT_EQ(0u, m.size());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove(cid, hoid);</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, OMapIterator)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    int count = 0;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.omap_clear(cid, hoid);</div><div class="line">        map&lt;string, bufferlist&gt; start_set;</div><div class="line">        t.omap_setkeys(cid, hoid, start_set);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectMap::ObjectMapIterator iter;</div><div class="line">    bool correct;</div><div class="line">    //basic iteration</div><div class="line">    for (int i = 0; i &lt; 100; i++) &#123;</div><div class="line">        if (!(i%5)) &#123;</div><div class="line">            std::cout &lt;&lt; "On iteration " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        // FileStore may deadlock two active iterators over the same data</div><div class="line">        iter = ObjectMap::ObjectMapIterator();</div><div class="line"></div><div class="line">        iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">        for (iter-&gt;seek_to_first(), count=0; iter-&gt;valid(); iter-&gt;next(), count++) &#123;</div><div class="line">            string key = iter-&gt;key();</div><div class="line">            bufferlist value = iter-&gt;value();</div><div class="line">            correct = attrs.count(key) &amp;&amp; (string(value.c_str()) == string(attrs[key].c_str()));</div><div class="line">            if (!correct) &#123;</div><div class="line">                if (attrs.count(key) &gt; 0) &#123;</div><div class="line">                    std::cout &lt;&lt; "key " &lt;&lt; key &lt;&lt; "in omap , " &lt;&lt; value.c_str() &lt;&lt; " : " &lt;&lt; attrs[key].c_str() &lt;&lt; std::endl;</div><div class="line">                &#125; else</div><div class="line">                    std::cout &lt;&lt; "key " &lt;&lt; key &lt;&lt; "should not exists in omap" &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">            ASSERT_EQ(correct, true);</div><div class="line">        &#125;</div><div class="line">        ASSERT_EQ((int)attrs.size(), count);</div><div class="line"></div><div class="line">        // FileStore may deadlock an active iterator vs queue_transaction</div><div class="line">        iter = ObjectMap::ObjectMapIterator();</div><div class="line"></div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        bl.clear();</div><div class="line">        bufferptr bp(buf, strlen(buf) + 1);</div><div class="line">        bl.append(bp);</div><div class="line">        map&lt;string, bufferlist&gt; to_add;</div><div class="line">        to_add.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        attrs.insert(pair&lt;string, bufferlist&gt;("key-" + string(buf), bl));</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.omap_setkeys(cid, hoid, to_add);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    iter = store-&gt;get_omap_iterator(ch, hoid);</div><div class="line">    //lower bound</div><div class="line">    string bound_key = "key-5";</div><div class="line">    iter-&gt;lower_bound(bound_key);</div><div class="line">    correct = bound_key &lt;= iter-&gt;key();</div><div class="line">    if (!correct) &#123;</div><div class="line">        std::cout &lt;&lt; "lower bound, bound key is " &lt;&lt; bound_key &lt;&lt; " &lt; iter key is " &lt;&lt; iter-&gt;key() &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(correct, true);</div><div class="line">    //upper bound</div><div class="line">    iter-&gt;upper_bound(bound_key);</div><div class="line">    correct = iter-&gt;key() &gt; bound_key;</div><div class="line">    if (!correct) &#123;</div><div class="line">        std::cout &lt;&lt; "upper bound, bound key is " &lt;&lt; bound_key &lt;&lt; " &gt;= iter key is " &lt;&lt; iter-&gt;key() &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(correct, true);</div><div class="line"></div><div class="line">    // FileStore may deadlock an active iterator vs queue_transaction</div><div class="line">    iter = ObjectMap::ObjectMapIterator();</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, XattrTest)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("tesomap", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    bufferlist big;</div><div class="line">    for (unsigned i = 0; i &lt; 10000; ++i) &#123;</div><div class="line">        big.append('\0');</div><div class="line">    &#125;</div><div class="line">    bufferlist small;</div><div class="line">    for (unsigned i = 0; i &lt; 10; ++i) &#123;</div><div class="line">        small.append('\0');</div><div class="line">    &#125;</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferlist&gt; attrs;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        attrs["attr1"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr2", big);</div><div class="line">        attrs["attr2"] = big;</div><div class="line">        t.setattr(cid, hoid, "attr3", small);</div><div class="line">        attrs["attr3"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr1", small);</div><div class="line">        attrs["attr1"] = small;</div><div class="line">        t.setattr(cid, hoid, "attr4", big);</div><div class="line">        attrs["attr4"] = big;</div><div class="line">        t.setattr(cid, hoid, "attr3", big);</div><div class="line">        attrs["attr3"] = big;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    map&lt;string, bufferptr&gt; aset;</div><div class="line">    store-&gt;getattrs(ch, hoid, aset);</div><div class="line">    ASSERT_EQ(aset.size(), attrs.size());</div><div class="line">    for (map&lt;string, bufferptr&gt;::iterator i = aset.begin();</div><div class="line">         i != aset.end();</div><div class="line">         ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.push_back(i-&gt;second);</div><div class="line">        ASSERT_TRUE(attrs[i-&gt;first] == bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.rmattr(cid, hoid, "attr2");</div><div class="line">        attrs.erase("attr2");</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    aset.clear();</div><div class="line">    store-&gt;getattrs(ch, hoid, aset);</div><div class="line">    ASSERT_EQ(aset.size(), attrs.size());</div><div class="line">    for (map&lt;string, bufferptr&gt;::iterator i = aset.begin();</div><div class="line">         i != aset.end();</div><div class="line">         ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.push_back(i-&gt;second);</div><div class="line">        ASSERT_TRUE(attrs[i-&gt;first] == bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bufferptr bp;</div><div class="line">    r = store-&gt;getattr(ch, hoid, "attr2", bp);</div><div class="line">    ASSERT_EQ(r, -ENODATA);</div><div class="line"></div><div class="line">    r = store-&gt;getattr(ch, hoid, "attr3", bp);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    bufferlist bl2;</div><div class="line">    bl2.push_back(bp);</div><div class="line">    ASSERT_TRUE(bl2 == attrs["attr3"]);</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove(cid, hoid);</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void colsplittest(</div><div class="line">    ObjectStore *store,</div><div class="line">    unsigned num_objects,</div><div class="line">    unsigned common_suffix_size,</div><div class="line">    bool clones</div><div class="line">)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0,52),shard_id_t::NO_SHARD));</div><div class="line">    coll_t tid(spg_t(pg_t(1&lt;&lt;common_suffix_size,52),shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    auto tch = store-&gt;create_new_collection(tid);</div><div class="line">    int r = 0;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, common_suffix_size);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    bufferlist small;</div><div class="line">    small.append("small");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        for (uint32_t i = 0; i &lt; (2 - (int)clones)*num_objects; ++i) &#123;</div><div class="line">            stringstream objname;</div><div class="line">            objname &lt;&lt; "obj" &lt;&lt; i;</div><div class="line">            ghobject_t a(hobject_t(</div><div class="line">                             objname.str(),</div><div class="line">                             "",</div><div class="line">                             CEPH_NOSNAP,</div><div class="line">                             i&lt;&lt;common_suffix_size,</div><div class="line">                             52, ""));</div><div class="line">            t.write(cid, a, 0, small.length(), small,</div><div class="line">                    CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">            if (clones) &#123;</div><div class="line">                objname &lt;&lt; "-clone";</div><div class="line">                ghobject_t b(hobject_t(</div><div class="line">                                 objname.str(),</div><div class="line">                                 "",</div><div class="line">                                 CEPH_NOSNAP,</div><div class="line">                                 i&lt;&lt;common_suffix_size,</div><div class="line">                                 52, ""));</div><div class="line">                t.clone(cid, a, b);</div><div class="line">            &#125;</div><div class="line">            if (i % 100) &#123;</div><div class="line">                r = queue_transaction(store, ch, std::move(t));</div><div class="line">                ASSERT_EQ(r, 0);</div><div class="line">                t = ObjectStore::Transaction();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(tid, common_suffix_size + 1);</div><div class="line">        t.split_collection(cid, common_suffix_size+1, 1&lt;&lt;common_suffix_size, tid);</div><div class="line">        r = queue_transaction(store, tch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    tch-&gt;flush();</div><div class="line"></div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    vector&lt;ghobject_t&gt; objects;</div><div class="line">    r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_EQ(objects.size(), num_objects);</div><div class="line">    unsigned size = 0;</div><div class="line">    for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_EQ(!!(i-&gt;hobj.get_hash() &amp; (1&lt;&lt;common_suffix_size)), 0u);</div><div class="line">        t.remove(cid, *i);</div><div class="line">        if (++size &gt; 100) &#123;</div><div class="line">            size = 0;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">            // test environment may have a low open file limit</div><div class="line">            ch-&gt;flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">    objects.clear();</div><div class="line">    r = store-&gt;collection_list(tch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                               INT_MAX, &amp;objects, 0);</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    ASSERT_EQ(objects.size(), num_objects);</div><div class="line">    for (vector&lt;ghobject_t&gt;::iterator i = objects.begin();</div><div class="line">         i != objects.end();</div><div class="line">         ++i) &#123;</div><div class="line">        ASSERT_EQ(!(i-&gt;hobj.get_hash() &amp; (1&lt;&lt;common_suffix_size)), 0u);</div><div class="line">        t.remove(tid, *i);</div><div class="line">        if (++size &gt; 100) &#123;</div><div class="line">            size = 0;</div><div class="line">            r = queue_transaction(store, tch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            t = ObjectStore::Transaction();</div><div class="line"></div><div class="line">            // test environment may have a low open file limit</div><div class="line">            tch-&gt;flush();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t.remove_collection(tid);</div><div class="line">    r = queue_transaction(store, tch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, ColSplitTest1)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 10000, 11, false);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest1Clones)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 10000, 11, true);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest2)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100, 7, false);</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, ColSplitTest2Clones)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100, 7, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if 0</div><div class="line">TEST_P(StoreTest, ColSplitTest3)</div><div class="line">&#123;</div><div class="line">    colsplittest(store.get(), 100000, 25);</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">/**</div><div class="line"> * This test tests adding two different groups</div><div class="line"> * of objects, each with 1 common prefix and 1</div><div class="line"> * different prefix.  We then remove half</div><div class="line"> * in order to verify that the merging correctly</div><div class="line"> * stops at the common prefix subdir.  See bug</div><div class="line"> * #5273 */</div><div class="line">TEST_P(StoreTest, TwoHash)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    int r;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Making objects" &lt;&lt; std::endl;</div><div class="line">    for (int i = 0; i &lt; 360; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        if (i &lt; 8) &#123;</div><div class="line">            o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">            t.touch(cid, o);</div><div class="line">        &#125;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xB1);</div><div class="line">        t.touch(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Removing half" &lt;&lt; std::endl;</div><div class="line">    for (int i = 1; i &lt; 8; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        t.remove(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Checking" &lt;&lt; std::endl;</div><div class="line">    for (int i = 1; i &lt; 8; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        bool exists = store-&gt;exists(ch, o);</div><div class="line">        ASSERT_EQ(exists, false);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash(0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        bool exists = store-&gt;exists(ch, o);</div><div class="line">        ASSERT_EQ(exists, true);</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; "Cleanup" &lt;&lt; std::endl;</div><div class="line">    for (int i = 0; i &lt; 360; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        ghobject_t o;</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xA1);</div><div class="line">        o.hobj.pool = -1;</div><div class="line">        t.remove(cid, o);</div><div class="line">        o.hobj.set_hash((i &lt;&lt; 16) | 0xB1);</div><div class="line">        t.remove(cid, o);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ObjectStore::Transaction t;</div><div class="line">    t.remove_collection(cid);</div><div class="line">    r = queue_transaction(store, ch, std::move(t));</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, Rename)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 2122),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t srcoid(hobject_t("src_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    ghobject_t dstoid(hobject_t("dest_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    bufferlist a, b;</div><div class="line">    a.append("foo");</div><div class="line">    b.append("bar");</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.write(cid, srcoid, 0, a.length(), a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, srcoid));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.collection_move_rename(cid, srcoid, cid, dstoid);</div><div class="line">        t.write(cid, srcoid, 0, b.length(), b);</div><div class="line">        t.setattr(cid, srcoid, "attr", b);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, srcoid));</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, dstoid));</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;read(ch, srcoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(b, bl));</div><div class="line">        store-&gt;read(ch, dstoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(a, bl));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, dstoid);</div><div class="line">        t.collection_move_rename(cid, srcoid, cid, dstoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, dstoid));</div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, srcoid));</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        store-&gt;read(ch, dstoid, 0, 3, bl);</div><div class="line">        ASSERT_TRUE(bl_eq(b, bl));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, dstoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, MoveRename)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0, 212),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t temp_oid(hobject_t("tmp_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    ghobject_t oid(hobject_t("dest_oid", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, oid));</div><div class="line">    bufferlist data, attr;</div><div class="line">    map&lt;string, bufferlist&gt; omap;</div><div class="line">    data.append("data payload");</div><div class="line">    attr.append("attr value");</div><div class="line">    omap["omap_key"].append("omap value");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, temp_oid);</div><div class="line">        t.write(cid, temp_oid, 0, data.length(), data);</div><div class="line">        t.setattr(cid, temp_oid, "attr", attr);</div><div class="line">        t.omap_setkeys(cid, temp_oid, omap);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, temp_oid));</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.collection_move_rename(cid, temp_oid, cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    ASSERT_TRUE(store-&gt;exists(ch, oid));</div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, temp_oid));</div><div class="line">    &#123;</div><div class="line">        bufferlist newdata;</div><div class="line">        r = store-&gt;read(ch, oid, 0, 1000, newdata);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(data, newdata));</div><div class="line">        bufferlist newattr;</div><div class="line">        r = store-&gt;getattr(ch, oid, "attr", newattr);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_TRUE(bl_eq(attr, newattr));</div><div class="line">        set&lt;string&gt; keys;</div><div class="line">        keys.insert("omap_key");</div><div class="line">        map&lt;string, bufferlist&gt; newomap;</div><div class="line">        r = store-&gt;omap_get_values(ch, oid, keys, &amp;newomap);</div><div class="line">        ASSERT_GE(r, 0);</div><div class="line">        ASSERT_EQ(1u, newomap.size());</div><div class="line">        ASSERT_TRUE(newomap.count("omap_key"));</div><div class="line">        ASSERT_TRUE(bl_eq(omap["omap_key"], newomap["omap_key"]));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BigRGWObjectName)</div><div class="line">&#123;</div><div class="line">    coll_t cid(spg_t(pg_t(0,12),shard_id_t::NO_SHARD));</div><div class="line">    ghobject_t oid(</div><div class="line">        hobject_t(</div><div class="line">            "default.4106.50_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",</div><div class="line">            "",</div><div class="line">            CEPH_NOSNAP,</div><div class="line">            0x81920472,</div><div class="line">            12,</div><div class="line">            ""),</div><div class="line">        15,</div><div class="line">        shard_id_t::NO_SHARD);</div><div class="line">    ghobject_t oid2(oid);</div><div class="line">    oid2.generation = 17;</div><div class="line">    ghobject_t oidhead(oid);</div><div class="line">    oidhead.generation = ghobject_t::NO_GEN;</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, oidhead);</div><div class="line">        t.collection_move_rename(cid, oidhead, cid, oid);</div><div class="line">        t.touch(cid, oidhead);</div><div class="line">        t.collection_move_rename(cid, oidhead, cid, oid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line">        r = store-&gt;collection_list(ch, ghobject_t(), ghobject_t::get_max(),</div><div class="line">                                   INT_MAX, &amp;objects, 0);</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">        ASSERT_EQ(objects.size(), 1u);</div><div class="line">        ASSERT_EQ(objects[0], oid2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ASSERT_FALSE(store-&gt;exists(ch, oid));</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, oid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, SetAllocHint)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*4, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*4, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove_collection(cid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, TryMoveRename)</div><div class="line">&#123;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    ghobject_t hoid2(hobject_t("test_hint2", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    int r;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.try_rename(cid, hoid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.try_rename(cid, hoid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    struct stat st;</div><div class="line">    ASSERT_EQ(store-&gt;stat(ch, hoid, &amp;st), -ENOENT);</div><div class="line">    ASSERT_EQ(store-&gt;stat(ch, hoid2, &amp;st), 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTest, BluestoreOnOffCSumTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        ASSERT_FALSE(ch);</div><div class="line">    &#125;</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //write with csum enabled followed by read with csum disabled</div><div class="line">        size_t block_size = 64*1024;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //write with csum disabled followed by read with csum enabled</div><div class="line"></div><div class="line">        size_t block_size = 64*1024;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //'mixed' non-overlapping writes to the same blob</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig;</div><div class="line">        size_t block_size = 8000;</div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        orig = bl;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        t2.write(cid, hoid, block_size*2, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Append 'unprotected'" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t2));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size*2, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">        in.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size*2, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //partially blob overwrite under a different csum enablement mode</div><div class="line"></div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig, orig2;</div><div class="line">        size_t block_size0 = 0x10000;</div><div class="line">        size_t block_size = 9000;</div><div class="line">        size_t block_size2 = 5000;</div><div class="line">        bl.append(std::string(block_size0, 'a'));</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.set_alloc_hint(cid, hoid, 4*1024*1024, 1024*8, 0);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Remove then create" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t2;</div><div class="line">        bl.clear();</div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t2.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        t2.write(cid, hoid, block_size0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite with unprotected data" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t2));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        orig = bl;</div><div class="line">        orig2 = bl;</div><div class="line">        orig.append( std::string(block_size0 - block_size, 'a'));</div><div class="line"></div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size0, in);</div><div class="line">        ASSERT_EQ((int)block_size0, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid, block_size0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig2, in));</div><div class="line"></div><div class="line">        SetVal(g_conf, "bluestore_csum_type", "crc32c");</div><div class="line">        g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">        ObjectStore::Transaction t3;</div><div class="line">        bl.clear();</div><div class="line">        bl.append(std::string(block_size2, 'c'));</div><div class="line">        t3.write(cid, hoid, block_size0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Overwrite with protected data" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t3));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        in.clear();</div><div class="line">        orig = bl;</div><div class="line">        orig.append( std::string(block_size - block_size2, 'b'));</div><div class="line">        r = store-&gt;read(ch, hoid, block_size0, block_size, in);</div><div class="line">        ASSERT_EQ((int)block_size, r);</div><div class="line">        ASSERT_TRUE(bl_eq(orig, in));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">INSTANTIATE_TEST_CASE_P(</div><div class="line">    ObjectStore,</div><div class="line">    StoreTest,</div><div class="line">    ::testing::Values(</div><div class="line">        "memstore",</div><div class="line">        "filestore",</div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">        "bluestore",</div><div class="line">#endif</div><div class="line">        "kstore"));</div><div class="line"></div><div class="line">// Note: instantiate all stores to preserve store numbering order only</div><div class="line">INSTANTIATE_TEST_CASE_P(</div><div class="line">    ObjectStore,</div><div class="line">    StoreTestSpecificAUSize,</div><div class="line">    ::testing::Values(</div><div class="line">        "memstore",</div><div class="line">        "filestore",</div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">        "bluestore",</div><div class="line">#endif</div><div class="line">        "kstore"));</div><div class="line"></div><div class="line">#else</div><div class="line"></div><div class="line">// Google Test may not support value-parameterized tests with some</div><div class="line">// compilers. If we use conditional compilation to compile out all</div><div class="line">// code referring to the gtest_main library, MSVC linker will not link</div><div class="line">// that library at all and consequently complain about missing entry</div><div class="line">// point defined in that library (fatal error LNK1561: entry point</div><div class="line">// must be defined). This dummy test keeps gtest_main linked in.</div><div class="line">TEST(DummyTest, ValueParameterizedTestsAreNotSupportedOnThisPlatform) &#123;&#125;</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">void doMany4KWritesTest(boost::scoped_ptr&lt;ObjectStore&gt;&amp; store,</div><div class="line">                        unsigned max_objects,</div><div class="line">                        unsigned max_ops,</div><div class="line">                        unsigned max_object_size,</div><div class="line">                        unsigned max_write_size,</div><div class="line">                        unsigned write_alignment)</div><div class="line">&#123;</div><div class="line">    MixedGenerator gen(555);</div><div class="line">    gen_type rng(time(NULL));</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line">    store_statfs_t res_stat;</div><div class="line"></div><div class="line">    SyntheticWorkloadState test_obj(store.get(),</div><div class="line">                                    &amp;gen,</div><div class="line">                                    &amp;rng,</div><div class="line">                                    cid,</div><div class="line">                                    max_object_size,</div><div class="line">                                    max_write_size,</div><div class="line">                                    write_alignment);</div><div class="line">    test_obj.init();</div><div class="line">    for (unsigned i = 0; i &lt; max_objects; ++i) &#123;</div><div class="line">        if (!(i % 500)) cerr &lt;&lt; "seeding object " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">        test_obj.touch();</div><div class="line">    &#125;</div><div class="line">    for (unsigned i = 0; i &lt; max_ops; ++i) &#123;</div><div class="line">        if (!(i % 200)) &#123;</div><div class="line">            cerr &lt;&lt; "Op " &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">            test_obj.print_internal_state();</div><div class="line">        &#125;</div><div class="line">        test_obj.write();</div><div class="line">    &#125;</div><div class="line">    test_obj.wait_for_done();</div><div class="line">    test_obj.statfs(res_stat);</div><div class="line">    if (!(res_stat.stored &lt;= max_object_size) ||</div><div class="line">        !(res_stat.allocated &lt;= max_object_size)) &#123;</div><div class="line">        // this will provide more insight on the mismatch and</div><div class="line">        // helps to avoid any races during stats collection</div><div class="line">        test_obj.fsck(false);</div><div class="line">        // retrieving stats once again and assert if still broken</div><div class="line">        test_obj.statfs(res_stat);</div><div class="line">        ASSERT_LE(res_stat.stored, max_object_size);</div><div class="line">        ASSERT_LE(res_stat.allocated, max_object_size);</div><div class="line">    &#125;</div><div class="line">    test_obj.shutdown();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, Many4KWritesTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    StartDeferred(0x10000);</div><div class="line"></div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, Many4KWritesNoCSumTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line"></div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0 );</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, TooManyBlobsTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    StartDeferred(0x10000);</div><div class="line">    const unsigned max_object = 4*1024*1024;</div><div class="line">    doMany4KWritesTest(store, 1, 1000, max_object, 4*1024, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">void get_mempool_stats(uint64_t* total_bytes, uint64_t* total_items)</div><div class="line">&#123;</div><div class="line">    uint64_t onode_allocated = mempool::bluestore_cache_onode::allocated_bytes();</div><div class="line">    uint64_t other_allocated = mempool::bluestore_cache_other::allocated_bytes();</div><div class="line"></div><div class="line">    uint64_t onode_items = mempool::bluestore_cache_onode::allocated_items();</div><div class="line">    uint64_t other_items = mempool::bluestore_cache_other::allocated_items();</div><div class="line">    cout &lt;&lt; "onode(" &lt;&lt; onode_allocated &lt;&lt; "/" &lt;&lt; onode_items</div><div class="line">         &lt;&lt; ") other(" &lt;&lt; other_allocated &lt;&lt; "/" &lt;&lt; other_items</div><div class="line">         &lt;&lt; ")" &lt;&lt; std::endl;</div><div class="line">    *total_bytes = onode_allocated + other_allocated;</div><div class="line">    *total_items = onode_items;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, OnodeSizeTracking)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "none");</div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "none");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_hdd", "400000000");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_ssd", "400000000");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line">    size_t obj_size = 4 * 1024  * 1024;</div><div class="line">    uint64_t total_bytes, total_bytes2;</div><div class="line">    uint64_t total_onodes;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_EQ(total_onodes, 0u);</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, orig, orig2;</div><div class="line"></div><div class="line">        bl.append(std::string(obj_size, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_NE(total_bytes, 0u);</div><div class="line">    ASSERT_EQ(total_onodes, 1u);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.truncate(cid, hoid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for(size_t i = 0; i &lt; 1; ++i) &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        bl.append(std::string(block_size * (i+1), 'a'));</div><div class="line">        for( size_t j = 0; j &lt; obj_size; j+= bl.length()) &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.write(cid, hoid, j, bl.length(), bl);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        get_mempool_stats(&amp;total_bytes2, &amp;total_onodes);</div><div class="line">        ASSERT_NE(total_bytes2, 0u);</div><div class="line">        ASSERT_EQ(total_onodes, 1u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt;" mempool dump:\n";</div><div class="line">        JSONFormatter f(true);</div><div class="line">        f.open_object_section("transaction");</div><div class="line">        mempool::dump(&amp;f);</div><div class="line">        f.close_section();</div><div class="line">        f.flush(cout);</div><div class="line">        cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist bl;</div><div class="line">        for (size_t i = 0; i &lt; obj_size; i += 0x1000) &#123;</div><div class="line">            store-&gt;read(ch, hoid, i, 0x1000, bl);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    get_mempool_stats(&amp;total_bytes, &amp;total_onodes);</div><div class="line">    ASSERT_NE(total_bytes, 0u);</div><div class="line">    ASSERT_EQ(total_onodes, 1u);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        cout &lt;&lt;" mempool dump:\n";</div><div class="line">        JSONFormatter f(true);</div><div class="line">        f.open_object_section("transaction");</div><div class="line">        mempool::dump(&amp;f);</div><div class="line">        f.close_section();</div><div class="line">        f.flush(cout);</div><div class="line">        cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnOverwrite)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // overwrite at the beginning</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // append</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'c'));</div><div class="line">        t.write(cid, hoid, block_size * 2, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // append with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'd'));</div><div class="line">        t.write(cid, hoid, block_size * 5, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // overwrite at end</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'e'));</div><div class="line"></div><div class="line">        // Currently we are unable to reuse blob when overwriting in a single step</div><div class="line">        t.write(cid, hoid, block_size * 6, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fill the gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'f'));</div><div class="line"></div><div class="line">        t.write(cid, hoid, block_size * 4, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // we need to wait some time for mempool</div><div class="line">        // thread to update stats to be able to check blob/extent numbers from</div><div class="line">        // perf counters.</div><div class="line">        sleep(1);</div><div class="line"></div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 2, block_size * 2, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 2);</div><div class="line">        expected.append(string(block_size * 2, 'c'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 4, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 5, block_size, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size);</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        bl.clear();</div><div class="line">        expected.clear();</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 5, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        expected.append(string(block_size * 2, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">    &#125;</div><div class="line">    ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">    ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 1u);</div><div class="line"></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnOverwriteReverse)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 2, 'a'));</div><div class="line">        t.write(cid, hoid, block_size * 10, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // prepend existing</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'b'));</div><div class="line">        t.write(cid, hoid, block_size * 9, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 9, block_size * 2, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 2);</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 1u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // prepend existing with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'c'));</div><div class="line">        t.write(cid, hoid, block_size * 7, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 7, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'c'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'b'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 2u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // append after existing with a gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'd'));</div><div class="line">        t.write(cid, hoid, block_size * 13, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 11, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'd'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 3u);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // append twice to the next max_blob slot</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'e'));</div><div class="line">        t.write(cid, hoid, block_size * 17, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 19, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 17, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        expected.append(string(block_size, 0));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 2u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 5u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // fill gaps at the second slot</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'f'));</div><div class="line">        t.write(cid, hoid, block_size * 16, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 18, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, block_size * 16, block_size * 4, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 4);</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        expected.append(string(block_size, 'f'));</div><div class="line">        expected.append(string(block_size, 'e'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 2u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 4u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, BlobReuseOnSmallOverwrite)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 4096;</div><div class="line">    StartDeferred(block_size);</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "65536");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_hint", "", CEPH_NOSNAP, 0, -1, ""));</div><div class="line"></div><div class="line">    const PerfCounters* logger = store-&gt;get_perf_counters();</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size, 'a'));</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl, CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        t.write(cid, hoid, block_size * 2, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // write small into the gap</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(3, 'b'));</div><div class="line">        t.write(cid, hoid, block_size + 1, bl.length(), bl,</div><div class="line">                CEPH_OSD_OP_FLAG_FADVISE_WILLNEED);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // We need to issue a read to trigger cache stat update that refresh</div><div class="line">        // perf counters. additionally we need to wait some time for mempool</div><div class="line">        // thread to update stats.</div><div class="line">        sleep(1);</div><div class="line">        bufferlist bl, expected;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, block_size * 3, bl);</div><div class="line">        ASSERT_EQ(r, (int)block_size * 3);</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        expected.append(string(1, 0));</div><div class="line">        expected.append(string(3, 'b'));</div><div class="line">        expected.append(string(block_size - 4, 0));</div><div class="line">        expected.append(string(block_size, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line"></div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_blobs), 1u);</div><div class="line">        ASSERT_EQ(logger-&gt;get(l_bluestore_extents), 3u);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The test case to reproduce an issue when write happens</div><div class="line">// to a zero space between the extents sharing the same spanning blob</div><div class="line">// with unloaded shard map.</div><div class="line">// Second extent might be filled with zeros this way due to wrong result</div><div class="line">// returned by has_any_extents() call in do_write_small. The latter is caused</div><div class="line">// by incompletly loaded extent map.</div><div class="line">TEST_P(StoreTestSpecificAUSize, SmallWriteOnShardedExtents)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    size_t block_size = 0x10000;</div><div class="line">    StartDeferred(block_size);</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_csum_type", "xxhash64");</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size", "524288"); // for sure</div><div class="line"></div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid1(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        //doing some tricks to have sharded extents/spanning objects</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2;</div><div class="line"></div><div class="line">        bl.append(std::string(0x80000, 'a'));</div><div class="line">        t.write(cid, hoid1, 0, bl.length(), bl, 0);</div><div class="line">        t.zero(cid, hoid1, 0x719e0, 0x75b0 );</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">        bl2.append(std::string(0x70000, 'b'));</div><div class="line">        t.write(cid, hoid1, 0, bl2.length(), bl2, 0);</div><div class="line">        t.zero(cid, hoid1, 0, 0x50000);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    ch.reset();</div><div class="line">    store-&gt;umount();</div><div class="line">    store-&gt;mount();</div><div class="line">    ch = store-&gt;open_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // do a write to zero space in between some extents sharing the same blob</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, bl2;</div><div class="line"></div><div class="line">        bl.append(std::string(0x6520, 'c'));</div><div class="line">        t.write(cid, hoid1, 0x71c00, bl.length(), bl, 0);</div><div class="line"></div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl, expected;</div><div class="line"></div><div class="line">        r = store-&gt;read(ch, hoid1, 0x70000, 0x9c00, bl);</div><div class="line">        ASSERT_EQ(r, (int)0x9c00);</div><div class="line">        expected.append(string(0x19e0, 'a'));</div><div class="line">        expected.append(string(0x220, 0));</div><div class="line">        expected.append(string(0x6520, 'c'));</div><div class="line">        expected.append(string(0xe70, 0));</div><div class="line">        expected.append(string(0xc70, 'a'));</div><div class="line">        ASSERT_TRUE(bl_eq(expected, bl));</div><div class="line">        bl.clear();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid1);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, ExcessiveFragmentation)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify((uint64_t)2048 * 1024 * 1024).c_str());</div><div class="line"></div><div class="line">    ASSERT_EQ(g_conf-&gt;get_val&lt;uint64_t&gt;("bluefs_alloc_size"),</div><div class="line">              1024 * 1024);</div><div class="line"></div><div class="line">    size_t block_size = 0x10000;</div><div class="line">    StartDeferred(block_size);</div><div class="line"></div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid1(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // create 2x400MB objects in a way that their pextents are interleaved</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 4, 'a')); // 256KB</div><div class="line">        uint64_t offs = 0;</div><div class="line">        while(offs &lt; (uint64_t)400 * 1024 * 1024) &#123;</div><div class="line">            t.write(cid, hoid1, offs, bl.length(), bl, 0);</div><div class="line">            t.write(cid, hoid2, offs, bl.length(), bl, 0);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            offs += bl.length();</div><div class="line">            if( (offs % (100 * 1024 * 1024)) == 0) &#123;</div><div class="line">                std::cout&lt;&lt;"written " &lt;&lt; offs &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    std::cout&lt;&lt;"written 800MB"&lt;&lt;std::endl;</div><div class="line">    &#123;</div><div class="line">        // Partially overwrite objects with 100MB each leaving space</div><div class="line">        // fragmented and occuping still unfragmented space at the end</div><div class="line">        // So we'll have enough free space but it'll lack long enough (e.g. 1MB)</div><div class="line">        // contiguous pextents.</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        bl.append(std::string(block_size * 4, 'a'));</div><div class="line">        uint64_t offs = 0;</div><div class="line">        while(offs &lt; 112 * 1024 * 1024) &#123;</div><div class="line">            t.write(cid, hoid1, offs, bl.length(), bl, 0);</div><div class="line">            t.write(cid, hoid2, offs, bl.length(), bl, 0);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            // this will produce high fragmentation if original allocations</div><div class="line">            // were contiguous</div><div class="line">            offs += bl.length();</div><div class="line">            if( (offs % (10 * 1024 * 1024)) == 0) &#123;</div><div class="line">                std::cout&lt;&lt;"written " &lt;&lt; offs &lt;&lt; std::endl;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        // remove one of the object producing much free space</div><div class="line">        // and hence triggering bluefs rebalance.</div><div class="line">        // Which should fail as there is no long enough pextents.</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    auto to_sleep = 5 *</div><div class="line">                    (int)g_conf-&gt;get_val&lt;double&gt;("bluestore_bluefs_balance_interval");</div><div class="line">    std::cout&lt;&lt;"sleeping... " &lt;&lt; std::endl;</div><div class="line">    sleep(to_sleep);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        // touch another object to triggerrebalance</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.touch(cid, hoid1);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.remove(cid, hoid1);</div><div class="line">        t.remove(cid, hoid2);</div><div class="line">        t.remove_collection(cid);</div><div class="line">        cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#endif //#if defined(WITH_BLUESTORE)</div><div class="line"></div><div class="line">TEST_P(StoreTest, KVDBHistogramTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    int NUM_OBJS = 200;</div><div class="line">    int r = 0;</div><div class="line">    coll_t cid;</div><div class="line">    string base("testobj.");</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(base + string(buf), CEPH_NOSNAP)));</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    store-&gt;generate_db_histogram(f);</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, KVDBStatsTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "rocksdb_perf", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_compaction_stats", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_extended_stats","true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_memory_stats","true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    r = store-&gt;mount(); //to force rocksdb stats</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    int NUM_OBJS = 200;</div><div class="line">    coll_t cid;</div><div class="line">    string base("testobj.");</div><div class="line">    bufferlist a;</div><div class="line">    bufferptr ap(0x1000);</div><div class="line">    memset(ap.c_str(), 'a', 0x1000);</div><div class="line">    a.append(ap);</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; NUM_OBJS; ++i) &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        char buf[100];</div><div class="line">        snprintf(buf, sizeof(buf), "%d", i);</div><div class="line">        ghobject_t hoid(hobject_t(sobject_t(base + string(buf), CEPH_NOSNAP)));</div><div class="line">        t.write(cid, hoid, 0, 0x1000, a);</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    store-&gt;get_db_statistics(f);</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#if defined(WITH_BLUESTORE)</div><div class="line">TEST_P(StoreTestSpecificAUSize, garbageCollection)</div><div class="line">&#123;</div><div class="line">    int r;</div><div class="line">    coll_t cid;</div><div class="line">    int buf_len = 256 * 1024;</div><div class="line">    int overlap_offset = 64 * 1024;</div><div class="line">    int write_offset = buf_len;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">#define WRITE_AT(offset, _length) &#123;\</div><div class="line">      ObjectStore::Transaction t;\</div><div class="line">      if ((uint64_t)_length != bl.length()) &#123; \</div><div class="line">        buffer::ptr p(bl.c_str(), _length);\</div><div class="line">        bufferlist bl_tmp;\</div><div class="line">        bl_tmp.push_back(p);\</div><div class="line">        t.write(cid, hoid, offset, bl_tmp.length(), bl_tmp);\</div><div class="line">      &#125; else &#123;\</div><div class="line">        t.write(cid, hoid, offset, bl.length(), bl);\</div><div class="line">      &#125;\</div><div class="line">      r = queue_transaction(store, ch, std::move(t));\</div><div class="line">      ASSERT_EQ(r, 0);\</div><div class="line">  &#125;</div><div class="line"></div><div class="line">    StartDeferred(65536);</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_compression_max_blob_size", "524288");</div><div class="line">    SetVal(g_conf, "bluestore_compression_min_blob_size", "262144");</div><div class="line">    SetVal(g_conf, "bluestore_compression_mode", "force");</div><div class="line">    g_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    &#123;</div><div class="line">        bufferlist in;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, 5, in);</div><div class="line">        ASSERT_EQ(-ENOENT, r);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        cerr &lt;&lt; "Creating collection " &lt;&lt; cid &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::string data;</div><div class="line">    data.resize(buf_len);</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            bool exists = store-&gt;exists(ch, hoid);</div><div class="line">            ASSERT_TRUE(!exists);</div><div class="line"></div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.touch(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Creating object " &lt;&lt; hoid &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">            exists = store-&gt;exists(ch, hoid);</div><div class="line">            ASSERT_EQ(true, exists);</div><div class="line">        &#125;</div><div class="line">        bufferlist bl;</div><div class="line"></div><div class="line">        for(size_t i = 0; i &lt; data.size(); i++)</div><div class="line">            data[i] = i % 256;</div><div class="line"></div><div class="line">        bl.append(data);</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(0, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - 2 * overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0u);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x10000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset - 3 * overlap_offset, buf_len);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x20000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset + 1, overlap_offset-1);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x20000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x20000u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(write_offset + 1, overlap_offset);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x3ffffu);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(0, buf_len-1);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40001u);</div><div class="line">        &#125;</div><div class="line">        SetVal(g_conf, "bluestore_gc_enable_total_threshold", "1"); //forbid GC when saving = 0</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(1, overlap_offset-2);</div><div class="line">            WRITE_AT(overlap_offset * 2 + 1, overlap_offset-2);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x10000);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40001u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            struct store_statfs_t statfs;</div><div class="line">            WRITE_AT(overlap_offset + 1, overlap_offset-2);</div><div class="line">            int r = store-&gt;statfs(&amp;statfs);</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">            ASSERT_EQ(statfs.compressed_allocated, 0x0);</div><div class="line">            const PerfCounters* counters = store-&gt;get_perf_counters();</div><div class="line">            ASSERT_EQ(counters-&gt;get(l_bluestore_gc_merged), 0x40007u);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.remove(cid, hoid);</div><div class="line">            cerr &lt;&lt; "Cleaning" &lt;&lt; std::endl;</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, fsckOnUnalignedDevice)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify(0x280005000).c_str()); //10 Gb + 4K</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    StartDeferred(0x4000);</div><div class="line">    store-&gt;umount();</div><div class="line">    ASSERT_EQ(store-&gt;fsck(false), 0); // do fsck explicitly</div><div class="line">    store-&gt;mount();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTestSpecificAUSize, fsckOnUnalignedDevice2)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_block_size",</div><div class="line">           stringify(0x280005000).c_str()); //10 Gb + 20K</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    StartDeferred(0x1000);</div><div class="line">    store-&gt;umount();</div><div class="line">    ASSERT_EQ(store-&gt;fsck(false), 0); // do fsck explicitly</div><div class="line">    store-&gt;mount();</div><div class="line">&#125;</div><div class="line"></div><div class="line">TEST_P(StoreTest, BluestoreRepairTest)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line">    const size_t offs_base = 65536 / 2;</div><div class="line"></div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_mount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_fsck_on_umount", "false");</div><div class="line">    SetVal(g_conf, "bluestore_max_blob_size",</div><div class="line">           stringify(2 * offs_base).c_str());</div><div class="line">    SetVal(g_conf, "bluestore_extent_map_shard_max_size", "12000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    BlueStore* bstore = dynamic_cast&lt;BlueStore*&gt; (store.get());</div><div class="line"></div><div class="line">    // fill the store with some data</div><div class="line">    coll_t cid(spg_t(pg_t(0,555), shard_id_t::NO_SHARD));</div><div class="line">    auto ch = store-&gt;create_new_collection(cid);</div><div class="line"></div><div class="line">    ghobject_t hoid(hobject_t(sobject_t("Object 1", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid_dup(hobject_t(sobject_t("Object 1(dup)", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid2(hobject_t(sobject_t("Object 2", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid_cloned = hoid2;</div><div class="line">    hoid_cloned.hobj.snap = 1;</div><div class="line">    ghobject_t hoid3(hobject_t(sobject_t("Object 3", CEPH_NOSNAP)));</div><div class="line">    ghobject_t hoid3_cloned = hoid3;</div><div class="line">    hoid3_cloned.hobj.snap = 1;</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("1234512345");</div><div class="line">    int r;</div><div class="line">    const size_t repeats = 16;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;create_new_collection(cid);</div><div class="line">        cerr &lt;&lt; "create collection + write" &lt;&lt; std::endl;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        for( auto i = 0ul; i &lt; repeats; ++i ) &#123;</div><div class="line">            t.write(cid, hoid, i * offs_base, bl.length(), bl);</div><div class="line">            t.write(cid, hoid_dup, i * offs_base, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        for( auto i = 0ul; i &lt; repeats; ++i ) &#123;</div><div class="line">            t.write(cid, hoid2, i * offs_base, bl.length(), bl);</div><div class="line">        &#125;</div><div class="line">        t.clone(cid, hoid2, hoid_cloned);</div><div class="line"></div><div class="line">        r = queue_transaction(store, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bstore-&gt;umount();</div><div class="line">    //////////// leaked pextent fix ////////////</div><div class="line">    cerr &lt;&lt; "fix leaked pextents" &lt;&lt; std::endl;</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_leaked(0x30000);</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 1);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    //////////// false free fix ////////////</div><div class="line">    cerr &lt;&lt; "fix false free pextents" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_false_free(cid, hoid);</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 2);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    //////////// verify invalid statfs ///////////</div><div class="line">    cerr &lt;&lt; "fix invalid statfs" &lt;&lt; std::endl;</div><div class="line">    store_statfs_t statfs0, statfs;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    ASSERT_EQ(bstore-&gt;statfs(&amp;statfs0), 0);</div><div class="line">    statfs = statfs0;</div><div class="line">    statfs.allocated += 0x10000;</div><div class="line">    statfs.stored += 0x10000;</div><div class="line">    ASSERT_FALSE(statfs0 == statfs);</div><div class="line">    bstore-&gt;inject_statfs(statfs);</div><div class="line">    bstore-&gt;umount();</div><div class="line"></div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 1);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;mount(), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;statfs(&amp;statfs), 0);</div><div class="line">    // adjust free space to success in comparison</div><div class="line">    statfs0.available = statfs.available;</div><div class="line">    ASSERT_EQ(statfs0, statfs);</div><div class="line"></div><div class="line">    ///////// undecodable shared blob key / stray shared blob records ///////</div><div class="line">    cerr &lt;&lt; "undecodable shared blob key" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undec1",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undecodable key 2",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;inject_broken_shared_blob_key("undecodable key 3",</div><div class="line">                                          bufferlist());</div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 3);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line"></div><div class="line">    cerr &lt;&lt; "misreferencing" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, 0);</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, (offs_base * repeats) / 2);</div><div class="line">    bstore-&gt;inject_misreference(cid, hoid, cid, hoid_dup, offs_base * (repeats -1) );</div><div class="line"></div><div class="line">    bstore-&gt;umount();</div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(false), 6);</div><div class="line">    ASSERT_EQ(bstore-&gt;repair(false), 0);</div><div class="line"></div><div class="line">    ASSERT_EQ(bstore-&gt;fsck(true), 0);</div><div class="line"></div><div class="line">    // reproducing issues #21040 &amp; 20983</div><div class="line">    SetVal(g_conf, "bluestore_debug_inject_bug21040", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    bstore-&gt;mount();</div><div class="line"></div><div class="line">    cerr &lt;&lt; "repro bug #21040" &lt;&lt; std::endl;</div><div class="line">    &#123;</div><div class="line">        auto ch = store-&gt;open_collection(cid);</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            bl.append("0123456789012345");</div><div class="line">            t.write(cid, hoid3, offs_base, bl.length(), bl);</div><div class="line">            bl.clear();</div><div class="line">            bl.append('!');</div><div class="line">            t.write(cid, hoid3, 0, bl.length(), bl);</div><div class="line"></div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            ObjectStore::Transaction t;</div><div class="line">            t.clone(cid, hoid3, hoid3_cloned);</div><div class="line">            r = queue_transaction(store, ch, std::move(t));</div><div class="line">            ASSERT_EQ(r, 0);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bstore-&gt;umount();</div><div class="line">        ASSERT_EQ(bstore-&gt;fsck(false), 3);</div><div class="line">        ASSERT_LE(bstore-&gt;repair(false), 0);</div><div class="line">        ASSERT_EQ(bstore-&gt;fsck(false), 0);</div><div class="line">        SetVal(g_conf, "bluestore_debug_inject_bug21040", "true");</div><div class="line">        g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    cerr &lt;&lt; "Completing" &lt;&lt; std::endl;</div><div class="line">    bstore-&gt;mount();</div><div class="line">&#125;</div><div class="line">TEST_P(StoreTest, BluestoreStatistics)</div><div class="line">&#123;</div><div class="line">    if (string(GetParam()) != "bluestore")</div><div class="line">        return;</div><div class="line"></div><div class="line">    SetVal(g_conf, "rocksdb_perf", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_compaction_stats", "true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_extended_stats","true");</div><div class="line">    SetVal(g_conf, "rocksdb_collect_memory_stats","true");</div><div class="line"></div><div class="line">    // disable cache</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_ssd", "0");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size_hdd", "0");</div><div class="line">    SetVal(g_conf, "bluestore_cache_size", "0");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    int r = store-&gt;umount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line">    r = store-&gt;mount();</div><div class="line">    ASSERT_EQ(r, 0);</div><div class="line"></div><div class="line">    BlueStore* bstore = NULL;</div><div class="line">    EXPECT_NO_THROW(bstore = dynamic_cast&lt;BlueStore*&gt; (store.get()));</div><div class="line"></div><div class="line">    coll_t cid;</div><div class="line">    ghobject_t hoid(hobject_t("test_db_statistics", "", CEPH_NOSNAP, 0, 0, ""));</div><div class="line">    auto ch = bstore-&gt;create_new_collection(cid);</div><div class="line">    bufferlist bl;</div><div class="line">    bl.append("0123456789abcdefghi");</div><div class="line">    &#123;</div><div class="line">        ObjectStore::Transaction t;</div><div class="line">        t.create_collection(cid, 0);</div><div class="line">        t.touch(cid, hoid);</div><div class="line">        t.write(cid, hoid, 0, bl.length(), bl);</div><div class="line">        cerr &lt;&lt; "Write object" &lt;&lt; std::endl;</div><div class="line">        r = queue_transaction(bstore, ch, std::move(t));</div><div class="line">        ASSERT_EQ(r, 0);</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        bufferlist readback;</div><div class="line">        r = store-&gt;read(ch, hoid, 0, bl.length(), readback);</div><div class="line">        ASSERT_EQ(r, bl.length());</div><div class="line">        ASSERT_TRUE(bl_eq(bl, readback));</div><div class="line">    &#125;</div><div class="line">    Formatter *f = Formatter::create("store_test", "json-pretty", "json-pretty");</div><div class="line">    EXPECT_NO_THROW(store-&gt;get_db_statistics(f));</div><div class="line">    f-&gt;flush(cout);</div><div class="line">    cout &lt;&lt; std::endl;</div><div class="line">&#125;</div><div class="line">#endif  // WITH_BLUESTORE</div><div class="line"></div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    vector&lt;const char*&gt; args;</div><div class="line">    argv_to_vec(argc, (const char **)argv, args);</div><div class="line"></div><div class="line">    auto cct = global_init(NULL, args, CEPH_ENTITY_TYPE_CLIENT,</div><div class="line">                           CODE_ENVIRONMENT_UTILITY,</div><div class="line">                           CINIT_FLAG_NO_DEFAULT_CONFIG_FILE);</div><div class="line">    common_init_finish(g_ceph_context);</div><div class="line"></div><div class="line">    // make sure we can adjust any config settings</div><div class="line">    g_ceph_context-&gt;_conf-&gt;_clear_safe_to_start_threads();</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("osd_journal_size", "400");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_index_retry_probability", "0.5");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_op_thread_timeout", "1000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_op_thread_suicide_timeout", "10000");</div><div class="line">    //g_ceph_context-&gt;_conf-&gt;set_val_or_die("filestore_fiemap", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_mkfs", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_mount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_fsck_on_umount", "false");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_misc", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_small_allocations", "4");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_freelist", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_clone_cow", "true");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_max_alloc_size", "196608");</div><div class="line"></div><div class="line">    // set small cache sizes so we see trimming during Synthetic tests</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_cache_size_hdd", "4000000");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_cache_size_ssd", "4000000");</div><div class="line"></div><div class="line">    // very short *_max prealloc so that we fall back to async submits</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_blobid_prealloc", "10");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_nid_prealloc", "10");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_debug_randomize_serial_transaction",</div><div class="line">                                          "10");</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bdev_debug_aio", "true");</div><div class="line"></div><div class="line">    // specify device size</div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die("bluestore_block_size",</div><div class="line">                                          stringify(DEF_STORE_TEST_BLOCKDEV_SIZE));</div><div class="line"></div><div class="line">    g_ceph_context-&gt;_conf-&gt;set_val_or_die(</div><div class="line">        "enable_experimental_unrecoverable_data_corrupting_features", "*");</div><div class="line">    g_ceph_context-&gt;_conf-&gt;apply_changes(NULL);</div><div class="line"></div><div class="line">    ::testing::InitGoogleTest(&amp;argc, argv);</div><div class="line">    return RUN_ALL_TESTS();</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> * Local Variables:</div><div class="line"> * compile-command: "cd ../.. ; make ceph_test_objectstore &amp;&amp;</div><div class="line"> *    ./ceph_test_objectstore \</div><div class="line"> *        --gtest_filter=*.collect_metadata* --log-to-stderr=true --debug-filestore=20</div><div class="line"> *  "</div><div class="line"> * End:</div><div class="line"> */</div></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2018/07/31/stl/2.模板简介/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">1.2 模板元编程</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/6.store_test.cc" data-title="1.5 store_test.cc代码阅读" data-url="https://jiyou.github.io/blog/blog/2018/08/01/ceph/6.store_test.cc/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>