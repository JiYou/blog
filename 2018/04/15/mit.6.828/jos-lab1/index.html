<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>MIT 6.828 Lab1 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原地址：
lab1开坑。无视我的渣渣翻译。
简介实验主要是分为三个部分。

第一部分主要是需要熟悉x86的汇编语言，QEMU x86模拟器，以及PC上电之后的启动流程。
第二部分是验证6.828内核的boot loader，这里部分需要看的代码主要是位于boot目录。
第三部分主要是开始实施JOS操作系统。也就是MIT 6.828的内核部分。

软件的设置首先我的环境是沿用了Linux-2.6.2">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Lab1">
<meta property="og:url" content="https://jiyou.github.io/blog/2018/04/15/mit.6.828/jos-lab1/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="原地址：
lab1开坑。无视我的渣渣翻译。
简介实验主要是分为三个部分。

第一部分主要是需要熟悉x86的汇编语言，QEMU x86模拟器，以及PC上电之后的启动流程。
第二部分是验证6.828内核的boot loader，这里部分需要看的代码主要是位于boot目录。
第三部分主要是开始实施JOS操作系统。也就是MIT 6.828的内核部分。

软件的设置首先我的环境是沿用了Linux-2.6.2">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/mit.6.828/call.stack.jpeg">
<meta property="og:updated_time" content="2018-04-19T14:36:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Lab1">
<meta name="twitter:description" content="原地址：
lab1开坑。无视我的渣渣翻译。
简介实验主要是分为三个部分。

第一部分主要是需要熟悉x86的汇编语言，QEMU x86模拟器，以及PC上电之后的启动流程。
第二部分是验证6.828内核的boot loader，这里部分需要看的代码主要是位于boot目录。
第三部分主要是开始实施JOS操作系统。也就是MIT 6.828的内核部分。

软件的设置首先我的环境是沿用了Linux-2.6.2">
<meta name="twitter:image" content="https://jiyou.github.io/blog/blog/img/mit.6.828/call.stack.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/算法/" style="font-size: 10px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-mit.6.828/jos-lab1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/15/mit.6.828/jos-lab1/" class="article-date">
  	<time datetime="2018-04-14T21:28:32.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MIT 6.828 Lab1
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原地址：</p>
<p><a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab1/" target="_blank" rel="external">lab1</a><br>开坑。无视我的渣渣翻译。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验主要是分为三个部分。</p>
<ul>
<li>第一部分主要是需要熟悉x86的汇编语言，QEMU x86模拟器，以及PC上电之后的启动流程。</li>
<li>第二部分是验证6.828内核的boot loader，这里部分需要看的代码主要是位于boot目录。</li>
<li>第三部分主要是开始实施JOS操作系统。也就是MIT 6.828的内核部分。</li>
</ul>
<h2 id="软件的设置"><a href="#软件的设置" class="headerlink" title="软件的设置"></a>软件的设置</h2><p>首先我的环境是沿用了Linux-2.6.26内核调试环境搭建 里面的环境。<br>这里原来的网页讲了很多MIT学校里面上机环境。这部分没有必要去搞。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">mkdir ~/6.828</div><div class="line"><span class="built_in">cd</span> ~/6.828</div><div class="line">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2017/jos.git lab</div><div class="line"><span class="built_in">cd</span> lab</div></pre></td></tr></table></figure>
<h1 id="第一部分-PC-Bootstrap"><a href="#第一部分-PC-Bootstrap" class="headerlink" title="第一部分: PC Bootstrap"></a>第一部分: PC Bootstrap</h1><p>这个练习的作用完全是为了让你熟悉一下x86的汇编语言。以及PC启动的流程。并且可以熟练地使用QEMU/QEMU和GDB来调试了。在这里的实验里面你并不需要写任何的代码。但是需要有足够的理解来回答相应的问题。</p>
<p>Getting Started with x86 assembly<br>如果你对x86平台的汇编语言如果不是特别熟悉的话，可以使用这本书快速熟悉起来。 PC Assembly Language Book 这本书是一个不错的开始。因为里面包含了很多经典的和新的材料。</p>
<p>注意：这本书用的汇编语法是采用的NASM。但是在后面做实验的过程却是需要使用GAS语法。也就是AT &amp; T的语法。 Brennan’s Guide to Inline Assembly。</p>
<p>介绍了一些关于内联汇编需要注意的地方。关于内联汇编，可以看下面两本书</p>
<ul>
<li>Linux内核完全剖析 赵炯</li>
<li>Linux内核情景分析</li>
</ul>
<p>这两本书里面都讲到了C语言里面会用到的内联汇编。实际上，除此之外，也可以看一下xv6的代码。然后注意一下里面inline assemble的写法。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1."></a>Exercise 1.</h2><p>这里主要是为了熟悉硬件&amp;汇编的。所以并不做过多的介绍。只是把资源记在这里面。</p>
<ul>
<li>the 6.828 reference page 提供了各种关于汇编的资料。</li>
<li>推荐阅读 in Brennan’s Guide to Inline Assembly. 内联汇编语法。</li>
<li>短一点的关于80386硬件特性 80386 Programmer’s Reference Manual</li>
<li>X86详细的架构信息 IA-32 Intel Architecture Software Developer’s Manuals<br>太长了。后面有时间再去翻这些本来是用来查的工具书。</li>
</ul>
<p><strong>Simulating the x86</strong></p>
<p>在作业里面并没有使用真实的PC，而是使用的是QEMU的模拟器。通过这个模拟器，可以很方便地与GDB一起合作，打断点什么的。Linux-2.6.26内核调试环境搭建  这里面已经上手玩过一次了。</p>
<p>在6.828里面，主要还是继续使用QEMU。一个现代的模拟器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># cd lab</span></div><div class="line"><span class="comment"># make</span></div><div class="line">+ as kern/entry.S</div><div class="line">+ cc kern/entrypgdir.c</div><div class="line">+ cc kern/init.c</div><div class="line">+ cc kern/console.c</div><div class="line">+ cc kern/monitor.c</div><div class="line">+ cc kern/printf.c</div><div class="line">+ cc kern/kdebug.c</div><div class="line">+ cc lib/printfmt.c</div><div class="line">+ cc lib/readline.c</div><div class="line">+ cc lib/string.c</div><div class="line">+ ld obj/kern/kernel</div><div class="line">+ as boot/boot.S</div><div class="line">+ cc -Os boot/main.c</div><div class="line">+ ld boot/boot</div><div class="line">boot block is 380 bytes (max 510)</div><div class="line">+ mk obj/kern/kernel.img</div></pre></td></tr></table></figure>
<p><strong>注意</strong> (由于我的实验环境采用的是32位的系统，不会存在这个问题。)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">(If you get errors like <span class="string">"undefined reference to `__udivdi3'"</span>, you probably don<span class="string">'t have the 32-bit gcc multilib. If you'</span>re running Debian or Ubuntu, try installing the gcc-multilib package.)</div></pre></td></tr></table></figure>
<p>当make执行完成之后，运行结果就会生成obj/kern/kernel.img磁盘文件。利用这个虚拟的磁盘来启动一个PC。<br>仅管这里提供两种方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">make qemu</div></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">make qemu-nox</div></pre></td></tr></table></figure>
<p>尽量还是使用<code>make qemu-nox</code>，因为这种方式，在没有桌面环境的情况下也是可以正常工作的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># make qemu-nox</div><div class="line">Booting from Hard Disk...</div><div class="line">6828 decimal is XXX octal!</div><div class="line">entering test_backtrace 5</div><div class="line">entering test_backtrace 4</div><div class="line">entering test_backtrace 3</div><div class="line">entering test_backtrace 2</div><div class="line">entering test_backtrace 1</div><div class="line">entering test_backtrace 0</div><div class="line">leaving test_backtrace 0</div><div class="line">leaving test_backtrace 1</div><div class="line">leaving test_backtrace 2</div><div class="line">leaving test_backtrace 3</div><div class="line">leaving test_backtrace 4</div><div class="line">leaving test_backtrace 5</div><div class="line">Welcome to the JOS kernel monitor!</div><div class="line">Type &apos;help&apos; for a list of commands.</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>如果想要退出Qemu，那么只需要执行： <code>Ctrl+a x</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">There are only two commands you can give to the kernel monitor, <span class="built_in">help</span> and kerninfo.</div><div class="line">K&gt; <span class="built_in">help</span></div><div class="line"><span class="built_in">help</span> - display this list of commands</div><div class="line">kerninfo - display information about the kernel</div><div class="line">K&gt; kerninfo</div><div class="line">Special kernel symbols:</div><div class="line">  entry  f010000c (virt)  0010000c (phys)</div><div class="line">  etext  f0101a75 (virt)  00101a75 (phys)</div><div class="line">  edata  f0112300 (virt)  00112300 (phys)</div><div class="line">  end    f0112960 (virt)  00112960 (phys)</div><div class="line">Kernel executable memory footprint: 75KB</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>仅管看起来很简单。但是实际上这里面生成的<code>obj/kern/kernel.img</code>文件是可以放到真实的物理硬件上来执行的。</p>
<p><strong>批注</strong>：上面的内容其实动手的部分不多。大部分还是要求去熟悉汇编。怎么讲呢？最好的还是用到的时候再学吧。</p>
<h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>接下来会介绍PC的启动。一个PC的物理地址空间可以分成以下组成。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">We will now dive into a bit more detail about how a PC starts up. A PC<span class="string">'s physical address space is hard-wired to have the following general layout:</span></div><div class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class="line">|      32-bit      |</div><div class="line">|  memory mapped   |</div><div class="line">|     devices      |</div><div class="line">|                  |</div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line"></div><div class="line">/\/\/\/\/\/\/\/\/\/\</div><div class="line">|                  |</div><div class="line">|      Unused      |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- depends on amount of RAM</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">| Extended Memory  |</div><div class="line">|                  |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00100000 (1MB)</div><div class="line">|     BIOS ROM     |   64KB</div><div class="line">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class="line">|  16-bit devices, |</div><div class="line">|  expansion ROMs  |</div><div class="line">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class="line">|   VGA Display    |    128KB</div><div class="line">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class="line">|                  |</div><div class="line">|    Low Memory    |</div><div class="line">|                  |</div><div class="line">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure></p>
<p>为了兼容性的考虑。PC在一开始是16位的。但是地址线却有20位。也就是能够寻址1MB的地址空间。其中640KB为低端内存。<br>这段内容非常重要，所以需要好好注意。Lab2内存分配的时候会用到这个。<br>除去低端的640KB。那么1MB还留下 <code>1024KB - 640KB = 384KB</code>。这<code>384KB</code>的范围就是<br><code>0x000A0000 ~ 0x000FFFFF</code>。</p>
<p>其中BIOS占掉了顶端的<code>64KB</code>的内存。尽管后来内存从1MB前进到了16MB，后来又进展到了4GB。但是PC的内存布局还是没有改变。主要是为了兼容性考虑。因此，32位的CPU在这里还是会有个洞。<code>0x000A0000 〜 0x00100000</code>。</p>
<p>原本低端内存可以连续的1MB，变成了两段</p>
<ul>
<li>0~640KB，</li>
<li>然后1MB〜更高的内存。</li>
</ul>
<p>即</p>
<ul>
<li>“conventional memory” (the first 640KB) </li>
<li>“extended memory” 1MB以上</li>
</ul>
<p>最新的x86架构可以支持4GB以上的物理内存了。所以RAM也可以扩展到0xFFFFFFFF以上的地址。在这种情况下BIOS需要设置第二个洞。也就是在32位地址的顶端。但是JOS目前来说，只是支持256MB的物理内存。所以这里设计时只考虑到了具有32位地址的地址空间的情况。</p>
<h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>接下来的操作里面，你会用到QEMU的debug功能来深入了解IA-32计算机的启动流程。<br>需要做以下事情：<br>打开两个termainal</p>
<p>一个窗口运行<code>make qemu-nox-gdb</code><br>另外一个窗口运行<code>make gdb</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># make gdb</span></div><div class="line">GNU gdb (GDB) 6.8-debian</div><div class="line">Copyright (C) 2008 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"i486-linux-gnu"</span>.</div><div class="line">+ target remote localhost:26000</div><div class="line">The target architecture is assumed to be i8086</div><div class="line">[f000:fff0] 0xffff0:    ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></div><div class="line">0x0000fff0 <span class="keyword">in</span> ?? ()</div><div class="line">+ symbol-file obj/kern/kernel</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>这里能够通过gdb一下子就连接上来，这是因为提供了一个<code>.gdbinit</code>文件，能够自动地attach到想要调试的程序上来。当然前提是已经把这个debug的程序运行起来的情况。<br>第一条要执行的指令就是<code>ljmp</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[f000:fff0] 0xffff0:    ljmp   <span class="variable">$0xf000</span>,<span class="variable">$0xe05b</span></div></pre></td></tr></table></figure>
<p>从这个要执行的指令可以看出来。</p>
<p>IBM PC开始执行的物理位置是<code>0x000ffff0</code>。这个是位于1MB里面的很高的地址。也就是ROM BIOS最顶上<code>64KB</code>的顶部。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[f000:fff0]可以看出来，此时CS = 0xf000 and IP = 0xfff0.</div></pre></td></tr></table></figure>
<p>如果执行完这条指令之后 <code>CS = 0xf000 and IP = 0xe05b</code>.<br>为什么QEMU一开始执行的时候是这样的？这是因为8088的芯片就是这样的。<br>在IBM最原始的PC就是这么使用的。总之一句话，当PC上电之后。CS:IP两个寄存器就强制被设置为这个值。<code>CS = 0xf000 and IP = 0xfff0</code>。</p>
<p>注意16位的寻址模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">: physical address = 16 * segment + offset. </div><div class="line">16 * 0xf000 + 0xfff0   <span class="comment"># in hex multiplication by 16 is</span></div><div class="line">   = 0xf0000 + 0xfff0     <span class="comment"># easy--just append a 0.</span></div><div class="line">   = 0xffff0</div></pre></td></tr></table></figure>
<p>1MB尾巴上的地址就是<code>0xffff0 + 16bytes</code>。除了放个ljmp之外，你也不要指望16bytes能做啥了。</p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2."></a>Exercise 2.</h2><p>用gdb的si指令来单步执行。看一下在启动的时候都做了些什么。可能需要查看的资料是<code>Phil Storrs I/O Ports Description</code> in <code>6.828 reference materials page</code>.</p>
<p>不需要非常详细，只需要大概了解一下就可以了。</p>
<ul>
<li>当BIOS在运行的时候。会在内存的超始地址处建立一个各种设备的16位的中断向量表，并且初始化各种设备。利用这个中断向量表，就可以成功输出”Start SeaBIOS”这种信息。</li>
<li>当各种初始化的硬件设备工作做完之后。BIOS就开始找启动设备，最终会在硬盘的起始sector里面找0x55, 0xaa这标志位的扇区。如果有，就加载到0x7c00处开始运行。也就是(31KB)的位置。</li>
</ul>
<h1 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h1><p>软盘和磁盘一般都是被切分为512 byte区域，也就是扇区。一个扇区是一个块设备的最小传输单位。每次读写都是必须是扇区的整数倍。<br>如果这个软盘或者磁盘是可启动的。那么第一个扇区被叫做可启动扇区。这里也存放的就是可启动的代码。当BIOS找到这个扇区的时候，就把这512 byte读到0x7c00至0x7cff。然后用一个跳转指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ljmp 0x07c0:0000</div></pre></td></tr></table></figure>
<p>对于CD-ROM的支持，需要看 “El Torito” Bootable CD-ROM Format Specification.<br>对于6.828来说，由于完全是使用硬盘来启动的。所以在硬盘的开始必须是boot loader，并且这个boot loader必须是512 bytes大小。<br>这个boot loader主要是由两个文件构成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">boot/boot.S</div><div class="line">boot/main.c</div></pre></td></tr></table></figure>
<p>这里需要好好地读一下这个文件。然后知道这两个文件做了些啥。<br>boot loader把模式切到了32位保护模式。因为只有在这种模式下软件才可以访问1MB+以上的内存空间。保护模式在<code>1.2.7</code> and <code>1.2.8</code> of <code>PC Assembly Language</code> 进行了介绍。 <code>Intel architecture manuals</code>也对这个有详细介绍。</p>
<p>在16位模式下只需要考虑段地址。<br>其次，需要注意的是<code>boot loader</code>读了kernel。从硬盘到内存。在操作的时候走的是PC的寄存器操作。如果想要了解更多，可以读一下<code>&quot;IDE hard drive controller&quot;</code> in  <code>the 6.828 reference page</code>.的这一部分。</p>
<p>当你理解了<code>boot loader</code>的源码之后。接下来可以看一下<code>obj/boot/boot.asm</code>。b *0x7c00<code>就可以把断点设置在</code>0x7c00`。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">b *0x7c00 <span class="comment"># 设置断点在0x7c00</span></div><div class="line">si 表示单步执行</div><div class="line">si 2 表示接着执行两条指令</div><div class="line">c 表示不再单步执行。直接开始运行了</div></pre></td></tr></table></figure>
<p>查看内存中的指令，有时候可能需要查看内存操作的结果。这个时候需要用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">x/i 调试命令</div><div class="line">x/Ni 基中N是指令的数目; 会把指定内存里面的指令翻译成汇编。</div></pre></td></tr></table></figure>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h2><p>特别需要注意看一下<code>lab tools guide</code>。里面介绍了很多<code>GDB</code>命令的<code>section</code>。这些命令对于开发操作系统特别有帮助。<br>在<code>0x7c00</code>这里设置一个断点。这个位置是启动扇区被加载到的内存位置。持续执行，一直跑到那个断点那里（按一下c就可以一直跑到断点那里了 ）。大概看一下<code>boot/boot.S</code>里面的代码。并且注意看一下<code>obj/boot/boot.asm</code>来跟踪当前所处的位置。</p>
<p>也可以用<code>x/i</code>命令来查看内存里面的汇编指令。并且与原本的<code>boot loader</code> 里面的代码进行比较。</p>
<p>接下来就可以通过<code>bootmain函数</code>进入到<code>boot/main.c</code>里面。然后开始执行<code>readsect函数</code>。注意<code>readsect</code>里面的汇编指令。一路跟踪<code>readsect函数</code>的执行，然后回到<code>bootmain函数</code>。</p>
<p>一直到读完余下的磁盘上的内核扇区。找出当循环结之后，会跳到哪里去执行？（肯定是跳到内核的第一条指令那里开始执行了）需要在那里设置一个断点。</p>
<p>接下来就需要回答如下问题：<br><strong>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">Q: 在哪里CPU开始进入到<span class="number">32</span>位模式。</div><div class="line">   哪条指令是带来了<span class="number">16</span>位到<span class="number">32</span>位的切换。</div><div class="line">A: </div><div class="line">movl    %eax, %cr0</div></pre></td></tr></table></figure>
<p>这条指令把cr0寄存器的最后一位，即PE位打开。也就是开启了保护模式。<br>CPU也就从这里开始进入到了32位模式。</p>
<p>只不过必须要清空一下流水线。这是规定。<br>所以接下来需要进入到32位的时候。<br>就需要用一个长跳转来进入到32位的代码那里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Jump to next instruction, but in 32-bit code segment.</div><div class="line"># Switches processor into 32-bit mode.</div><div class="line">ljmp    $PROT_MODE_CSEG, $protcseg</div></pre></td></tr></table></figure>
<p>需要注意的是，在长跳转的时候，<br>这个段描述符已经指向了代码段<code>$PROT_MODE_CSEG</code>。</p>
<p>也就是<code>lgdt</code>已经是设置好的。</p>
<p><strong>What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Q: boot loader执行的最后一条指令是什么？kernel执行的第一条指令是什么？</div><div class="line">A:</div><div class="line"></div><div class="line">这个最简单的办法是打开obj/boot/boot.asm。找到bootmain函数的最后一条指令就可以了。</div><div class="line"></div><div class="line">        // call the entry point from the ELF header</div><div class="line">        // note: does not <span class="built_in">return</span>!</div><div class="line">        ((void (*)(void)) (ELFHDR-&gt;e_entry))();</div><div class="line">    7d61:       ff 15 18 00 01 00       call   *0x10018</div></pre></td></tr></table></figure>
<p>就是main.c中这个代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>
<p>Where is the first instruction of the kernel?<br>内核的第一条指令位于kern/entry.S里面的第一条指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">movw    $0x1234,0x472                   # warm boot</div></pre></td></tr></table></figure>
<p>也可以通过命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump <span class="_">-f</span> kernel</div><div class="line">kernel:     file format elf32-i386</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div></pre></td></tr></table></figure>
<p><strong>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Q: boot loader在加载kernel的时候，是如何决定有多少个扇区需要读取的？</div><div class="line">   这部分信息是如何确定？</div><div class="line"></div><div class="line">A: 详细的信息会涉及到较多的ELF头文件格式。</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bootmain</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">        <span class="comment">// 这里把ELF文件的头读到内存里面。</span></div><div class="line">        readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="comment">// is this a valid ELF?</span></div><div class="line">        <span class="comment">// 检查一下ELF头文件的magic是不是与指定的ELF的格式相等。</span></div><div class="line">        <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</div><div class="line">                <span class="keyword">goto</span> bad;</div><div class="line"></div><div class="line">        <span class="comment">// load each program segment (ignores ph flags)</span></div><div class="line">        <span class="comment">// ELF header里面指明了第一个program section header的位置。</span></div><div class="line">        <span class="comment">// 也指明了最后一个位置在哪里</span></div><div class="line">        <span class="comment">// [ph, end_of_program_header)</span></div><div class="line">        <span class="comment">// 这里面表明了每个程序段的大小以及位置。</span></div><div class="line">        ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">        eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">        <span class="keyword">for</span> (; ph &lt; eph; ph++)</div><div class="line">                <span class="comment">// p_pa是需要被加载的地址。</span></div><div class="line">                <span class="comment">// p_memsz指的是需要的物理内存的大小</span></div><div class="line">                <span class="comment">// p_offset指的是在逻辑上相对于整个文件头的偏移量。</span></div><div class="line">                <span class="comment">// 虽然这里p_memsz表示的时候需要占用的内存的大小。</span></div><div class="line">                <span class="comment">// 实际上也是磁盘上需要读取的数据量的大小。</span></div><div class="line">                readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line"></div><div class="line">        <span class="comment">// 当把内存加载到内存里面之后。开始从这里开始执行第一条指令。</span></div><div class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</div><div class="line"></div><div class="line">bad:</div><div class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</div><div class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">                <span class="comment">/* do nothing */</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// pa表示的是内存地址开始放磁盘内容的地方。</span></div><div class="line"><span class="comment">// count表示需要读的内容的长度。</span></div><div class="line"><span class="comment">// offset表示相对程序文件头的偏移量。这个传进来的参数还没有考虑到</span></div><div class="line"><span class="comment">// kernel在磁盘便移量。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">uint32_t</span> end_pa;</div><div class="line">        <span class="comment">// pa是开始放内容的内存起始地址</span></div><div class="line">        <span class="comment">// end_pa是指末尾地址</span></div><div class="line">        end_pa = pa + count;</div><div class="line">        <span class="comment">// 操作的时候，起始地址取一个512byte对齐的边界</span></div><div class="line">        <span class="comment">// 比如，如果起始地址addr =256, 那么内存开始放的地址就是addr = 0</span></div><div class="line">        pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 注意，这里把offset修正过了。由于第一个扇区放的是</span></div><div class="line">        <span class="comment">// boot loader。所以内存实际上是从第2个扇区开始放的。</span></div><div class="line">        <span class="comment">// 如果代码要更加友好一点。应该改成。</span></div><div class="line">        <span class="comment">// kernel_start_sector = 1;</span></div><div class="line">        <span class="comment">// offset = (offset / SECTSIZE) + kernel_start_sector;</span></div><div class="line">        <span class="comment">// 这样代码就比较容易理解了。</span></div><div class="line">        offset = (offset / SECTSIZE) + <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 本来这里可以用不着一个扇区一个扇区读的。</span></div><div class="line">        <span class="comment">// 可以读得快一点的。linux kernel里面就是利用较</span></div><div class="line">        <span class="comment">// 复杂的代码来加速了这个读取过程。</span></div><div class="line">        <span class="keyword">while</span> (pa &lt; end_pa) &#123;</div><div class="line">                <span class="comment">// 这里把磁盘扇区，注意，这个时候offset表示的是哪个扇区</span></div><div class="line">                <span class="comment">// 把这个扇区的内容读到内存地址pa处。</span></div><div class="line">                readsect((<span class="keyword">uint8_t</span>*) pa, offset);</div><div class="line">                <span class="comment">// 读完之后，移动内存地址以及扇区。</span></div><div class="line">                pa += SECTSIZE;</div><div class="line">                offset++;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然作业里面有个问题没有被问到。但是实际上是值得自己思考的。那就是。如果自己在写代码的时候，写的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</div><div class="line"><span class="keyword">int</span> *p = a;</div></pre></td></tr></table></figure>
<p>编译链接之后，a和p都会有个地址。这个地址应该就是程序员看到的虚拟地址空间的地址。平时自己写C程序可以不用关心这个虚拟地址与物理地址的对应。因为操作系统会利用分页技术把这个虚拟地址与真实的物理地址做好相应的对应。<br>但是现在在写的是操作系统。什么都是需要自己来进行操作的。所以考虑的一点是。<br>如果在编译的时候，这个地址被设定为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">p = 0x00ffffa;</div></pre></td></tr></table></figure>
<p>但是整个kernel加载的虚拟地址是<code>0xF0100000</code>。</p>
<p>这个时候就需要认真想一想了。是不是加载到虚拟地址0xF0200000也可以？物理地址的设定是什么？</p>
<p>思路如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kernel在编译的时候，采用的虚拟地址是0xF0100000。</div><div class="line">这是是在链接定义文件</div><div class="line">kern/kernel.ld指定的链接的起始地址。</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab<span class="comment"># cat kern/kernel.ld</span></div><div class="line">    /* Link the kernel at this address: <span class="string">"."</span> means the current address */</div><div class="line">    . = 0xF0100000;</div><div class="line"></div><div class="line">    /* AT(...) gives the load address of this section, <span class="built_in">which</span> tells</div><div class="line">       the boot loader <span class="built_in">where</span> to load the kernel <span class="keyword">in</span> physical memory */</div><div class="line">    .text : AT(0x100000) &#123;</div><div class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>kernel在加载到的物理地址是<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#define ELFHDR          ((struct Elf *) 0x10000)</div></pre></td></tr></table></figure></p>
<p>这两者之间的映射关系与用户的用应程序没有什么实质上的差异。也是通过页表来实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kern/entrypgdir.c</div></pre></td></tr></table></figure>
<p>完成了内核页表的设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">__</span>attribute__((<span class="number">__</span>aligned__(PGSIZE)))</div><div class="line"><span class="keyword">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</div><div class="line">        <span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB) </span></div><div class="line">        [<span class="number">0</span>]</div><div class="line">                = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</div><div class="line">        <span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></div><div class="line">        [KERNBASE&gt;&gt;PDXSHIFT]</div><div class="line">                = ((<span class="keyword">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里把物理起始地址4MB以及0xF0000000这里的4MB都映射到物理地址的<code>[0, 4MB)</code></p>
<h1 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h1><p>接下来就可以仔细地看一下C语言里面的内容。这里主要是看<code>boot loader</code>里面的C语言。即<code>boot/main.c</code>。</p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h2><p>这里需要对C语言的指针非常熟悉。最好的C语言的引用书籍就是<code>《The C Programming Language》</code>。<br>除非你对C语言已经非常熟悉。那么不要错过这些内容。<br>在开始读<code>boot/main.c</code>的时候。<br>需要对ELF二进制格式有一定的了解。这是因为经过编译链接之后，生成的<code>obj/kern/kernel</code>内核映像是一个ELF格式的。 <code>&quot;Executable and Linkable Format&quot;</code>。</p>
<p>关于ELF有如下完整的信息。 <code>the ELF specification on our reference page</code>, 但是实际上你是没有必要仔细从头到尾地看这个文档。里面有很多复杂的部分是关于动态链接库的支持的。</p>
<p>对于6.828这门课来说，只需要解的是ELF执行格式里面有个头，里面包含了各种每个程序段的加载信息。通过这些加载信息可以把整个程序正确地加载到内存里面。boot loader并不会去修正里面指针的指向。只是把磁盘上的kernel映像加开到内存里面，然后开始执行之。</p>
<p>ELF程序文是由一个固定长度的ELF头开始的。紧接着的是一个动态可变的程序头list。每个程序头，指明了每个程序段需要被加载的位置，长度，相对于整个程序的偏移量。</p>
<p><strong>注意：相对的是整个程序头的偏移量，而不是相对于磁盘头的偏移量</strong></p>
<p>由于在编译完成之后，才会把kernel写入磁盘的某个扇区。在编译的时候是无法知道会被写入到哪个扇区的。所以编译的时候只能说把相对的位置写入到ELF里面。<br>这些各种程序头比较常见的有以下几个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">.text: The program<span class="string">'s executable instructions.</span></div><div class="line">.rodata: Read-only data, such as ASCII string constants produced by the C compiler. (We will not bother setting up the hardware to prohibit writing, however.)</div><div class="line">.data: The data section holds the program's initialized data, such as global variables declared with initializers like int x = 5;.</div></pre></td></tr></table></figure>
<p>当链接器在计算内存部局的时候，也会保留足够的空间给各种未初始化的全局变量（初始化为0）。一般而言这个空间被称之为.bss段。<br>由于全部都是被设置为0.所以也就没有必要记录这些内容在ELF里面。所以ELF文件里面只需要记住.bss在内存里面的起始位置，以及大小。然后加载方需要确保这些.bss在内存里面正确的设置。以及初始化为0。<br>可以通过如下命令来查看<code>obj/kern/kernel</code>里面的<code>names, sizes</code>, 以及各种链接地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -h obj/kern/kernel</div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         00001917  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       00000714  f0101920  00101920  00002920  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003889  f0102034  00102034  00003034  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div></pre></td></tr></table></figure>
<p>真正要了解这个文件，需要查看链接设定文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kern/kernel.ld</div></pre></td></tr></table></figure>
<p>通过这个文件可以知道程序被加载的虚拟地址(VMA)，物理地址(LMA)分别是如何指定的。也可以通过File off查看相对文件的偏移量。这个File off偏移量是如何指定的？这个非常有意思。刚好在boot/main.c里面就是一开始就读了了8个扇区，也就是<code>0x1000 bytes</code>。</p>
<h3 id="ELF文件格式简图"><a href="#ELF文件格式简图" class="headerlink" title="ELF文件格式简图"></a>ELF文件格式简图</h3><p>kernel在编译和链接的时候，其虚拟地址与物理地址是不一样的。在加载的时候，也就相应地需要设置好页表。</p>
<p>但是考虑一下<code>boot loader</code>。在加载的时候，肯定是没有什么页表等着给你用的。<code>BIOS</code>可不会给你设置页表。所以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -h obj/boot/boot.out</div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  <span class="comment"># 注意这里的VMA与LMA是完全一致的。这是由于被加载进BIOS的时候，没有页表与段表可用。</span></div><div class="line">  <span class="comment"># size = 380 bytes.</span></div><div class="line">  <span class="comment"># 这里面就包含了boot loader所需要的所有信息。</span></div><div class="line">  0 .text         0000017c  00007c00  00007c00  00000074  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, CODE</div><div class="line"></div><div class="line">  <span class="comment"># size = 176这个段实际上是没有什么用的？</span></div><div class="line">  1 .eh_frame     000000b0  00007d7c  00007d7c  000001f0  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  <span class="comment"># 接下来的三个段，里面都是用于DEBUG的。所以真实用的时候，不会被用到。</span></div><div class="line">  2 .stab         000007b0  00000000  00000000  000002a0  2**2</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  3 .stabstr      00000846  00000000  00000000  00000a50  2**0</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  4 .comment      0000002b  00000000  00000000  00001296  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line"></div><div class="line">$ objdump -x obj/boot/boot.out</div><div class="line">obj/boot/boot.out:     file format elf32-i386</div><div class="line">obj/boot/boot.out</div><div class="line">architecture: i386, flags 0x00000012:</div><div class="line">EXEC_P, HAS_SYMS</div><div class="line">start address 0x00007c00</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00000074 vaddr 0x00007c00 paddr 0x00007c00 align 2**2</div><div class="line">         filesz 0x0000022c memsz 0x0000022c flags rwx</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         0000017c  00007c00  00007c00  00000074  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, CODE</div><div class="line">  1 .eh_frame     000000b0  00007d7c  00007d7c  000001f0  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         000007b0  00000000  00000000  000002a0  2**2</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  3 .stabstr      00000846  00000000  00000000  00000a50  2**0</div><div class="line">                  CONTENTS, READONLY, DEBUGGING</div><div class="line">  4 .comment      0000002b  00000000  00000000  00001296  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line">SYMBOL TABLE:</div><div class="line">00007c00 l    d  .text    00000000 .text</div><div class="line">00007d7c l    d  .eh_frame    00000000 .eh_frame</div><div class="line">00000000 l    d  .stab    00000000 .stab</div><div class="line">00000000 l    d  .stabstr    00000000 .stabstr</div><div class="line">00000000 l    d  .comment    00000000 .comment</div><div class="line">00000000 l    df *ABS*    00000000 obj/boot/boot.o</div><div class="line">00000008 l       *ABS*    00000000 PROT_MODE_CSEG</div><div class="line">00000010 l       *ABS*    00000000 PROT_MODE_DSEG</div><div class="line">00000001 l       *ABS*    00000000 CR0_PE_ON</div><div class="line">00007c0a l       .text    00000000 seta20.1</div><div class="line">00007c14 l       .text    00000000 seta20.2</div><div class="line">00007c64 l       .text    00000000 gdtdesc</div><div class="line">00007c32 l       .text    00000000 protcseg</div><div class="line">00007c4a l       .text    00000000 spin</div><div class="line">00007c4c l       .text    00000000 gdt</div><div class="line">00000000 l    df *ABS*    00000000 main.c</div><div class="line">00000000 l    df *ABS*    00000000</div><div class="line">00007c6a g     F .text    00000012 waitdisk</div><div class="line">00007d0a g     F .text    00000072 bootmain</div><div class="line">00007<span class="built_in">cd</span>1 g     F .text    00000039 readseg</div><div class="line">00007e2c g       .eh_frame    00000000 __bss_start</div><div class="line">00007c7c g     F .text    00000055 readsect</div><div class="line">00007e2c g       .eh_frame    00000000 _edata</div><div class="line">00007e2c g       .eh_frame    00000000 _end</div><div class="line">00007c00 g       .text    00000000 start</div></pre></td></tr></table></figure>
<p>为什么说只有text段是被使用到的呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">boot/Makefrag</div><div class="line"></div><div class="line">$(OBJDIR)/boot/boot: $(BOOT_OBJS)</div><div class="line">    @<span class="built_in">echo</span> + ld boot/boot</div><div class="line">    $(V)$(LD) $(LDFLAGS) -N <span class="_">-e</span> start -Ttext 0x7C00 -o <span class="variable">$@</span>.out $^ </div><div class="line">    $(V)$(OBJDUMP) -S <span class="variable">$@</span>.out &gt;<span class="variable">$@</span>.asm</div><div class="line">    $(V)$(OBJCOPY) -S -O binary -j .text <span class="variable">$@</span>.out <span class="variable">$@</span> <span class="comment"># 380 bytes</span></div><div class="line">    $(V)perl boot/sign.pl $(OBJDIR)/boot/boot</div></pre></td></tr></table></figure>
<p>boot loader自己是没有利用ELF格式的。需要用boot sector固定的格式。不过加载的时候，却是采用了ELF格式来加载内核。<br>如果要详细看一下kernel各个段的加载情况，可以通过如下命令：<br>需要注意program header与sections的区别。program header是给加载程序方用的。<br>section是给写程序的人以及与编译器看的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -x obj/kern/kernel</div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line">obj/kern/kernel</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</div><div class="line">         filesz 0x0000716c memsz 0x0000716c flags r-x</div><div class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</div><div class="line">         filesz 0x0000a300 memsz 0x0000a944 flags rw-</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         00001917  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       00000714  f0101920  00101920  00002920  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003889  f0102034  00102034  00003034  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018af  f01058bd  001058bd  000068bd  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div><div class="line">SYMBOL TABLE:</div><div class="line">f0100000 l    d  .text    00000000 .text</div><div class="line">f0101920 l    d  .rodata    00000000 .rodata</div><div class="line">f0102034 l    d  .stab    00000000 .stab</div><div class="line">f01058bd l    d  .stabstr    00000000 .stabstr</div><div class="line">f0108000 l    d  .data    00000000 .data</div><div class="line">f0112300 l    d  .bss    00000000 .bss</div><div class="line">00000000 l    d  .comment    00000000 .comment</div><div class="line">00000000 l    df *ABS*    00000000 obj/kern/entry.o</div><div class="line">f010002f l       .text    00000000 relocated</div><div class="line">f010003e l       .text    00000000 spin</div><div class="line">00000000 l    df *ABS*    00000000 entrypgdir.c</div><div class="line">00000000 l    df *ABS*    00000000 init.c</div><div class="line">00000000 l    df *ABS*    00000000 console.c</div><div class="line">f01001a0 l     F .text    0000001c serial_proc_data</div><div class="line">f01001bc l     F .text    00000044 cons_intr</div><div class="line">f0112320 l     O .bss    00000208 cons</div><div class="line">f0100200 l     F .text    00000117 kbd_proc_data</div><div class="line">f0112300 l     O .bss    00000004 shift.1330</div><div class="line">f0101b00 l     O .rodata    00000100 shiftcode</div><div class="line">f0101a00 l     O .rodata    00000100 togglecode</div><div class="line">f01019e0 l     O .rodata    00000010 charcode</div><div class="line">f0100317 l     F .text    000001e0 cons_putc</div><div class="line">f0112528 l     O .bss    00000002 crt_pos</div><div class="line">f011252c l     O .bss    00000004 crt_buf</div><div class="line">f0112530 l     O .bss    00000004 addr_6845</div><div class="line">f0112534 l     O .bss    00000001 serial_exists</div><div class="line">f0112200 l     O .data    00000100 normalmap</div><div class="line">f0112100 l     O .data    00000100 shiftmap</div><div class="line">f0112000 l     O .data    00000100 ctlmap</div><div class="line">00000000 l    df *ABS*    00000000 monitor.c</div><div class="line">f0101de4 l     O .rodata    00000018 commands</div><div class="line">00000000 l    df *ABS*    00000000 printf.c</div><div class="line">f01008eb l     F .text    00000013 putch</div><div class="line">00000000 l    df *ABS*    00000000 kdebug.c</div><div class="line">f010094b l     F .text    000000dd stab_binsearch</div><div class="line">00000000 l    df *ABS*    00000000 printfmt.c</div><div class="line">f0100c10 l     F .text    000000ef printnum</div><div class="line">f0100cff l     F .text    0000001d sprintputch</div><div class="line">f0102008 l     O .rodata    0000001c error_string</div><div class="line">00000000 l    df *ABS*    00000000 readline.c</div><div class="line">f0112540 l     O .bss    00000400 buf</div><div class="line">00000000 l    df *ABS*    00000000 string.c</div><div class="line">00000000 l    df *ABS*    00000000</div><div class="line">f010000c g       .text    00000000 entry</div><div class="line">f0101337 g     F .text    00000020 strcpy</div><div class="line">f0100513 g     F .text    00000012 kbd_intr</div><div class="line">f010079f g     F .text    0000000a mon_backtrace</div><div class="line">f01000f8 g     F .text    0000005f _panic</div><div class="line">f010009d g     F .text    0000005b i386_init</div><div class="line">f01014d4 g     F .text    00000068 memmove</div><div class="line">f0101208 g     F .text    00000028 snprintf</div><div class="line">f0100d44 g     F .text    0000046c vprintfmt</div><div class="line">f0100525 g     F .text    0000004a cons_getc</div><div class="line">f0100931 g     F .text    0000001a cprintf</div><div class="line">f010153c g     F .text    00000021 memcpy</div><div class="line">f0101230 g     F .text    000000ca readline</div><div class="line">f0111000 g     O .data    00001000 entry_pgtable</div><div class="line">f0100040 g     F .text    0000005d test_backtrace</div><div class="line">f01011b0 g     F .text    00000058 vsnprintf</div><div class="line">f0112300 g       .data    00000000 edata</div><div class="line">f010056f g     F .text    000000f2 cons_init</div><div class="line">f01058bc g       .stab    00000000 __STAB_END__</div><div class="line">f01058bd g       .stabstr    00000000 __STABSTR_BEGIN__</div><div class="line">f01017c0 g     F .text    00000157 .hidden __umoddi3</div><div class="line">f01004f7 g     F .text    0000001c serial_intr</div><div class="line">f0101690 g     F .text    00000124 .hidden __udivdi3</div><div class="line">f0100682 g     F .text    0000000a iscons</div><div class="line">f01015b3 g     F .text    000000d3 strtol</div><div class="line">f0101318 g     F .text    0000001f strnlen</div><div class="line">f0101357 g     F .text    0000002b strcat</div><div class="line">f0112940 g     O .bss    00000004 panicstr</div><div class="line">f0112944 g       .bss    00000000 end</div><div class="line">f0100157 g     F .text    00000045 _warn</div><div class="line">f010146b g     F .text    0000001c strfind</div><div class="line">f0101917 g       .text    00000000 etext</div><div class="line">0010000c g       .text    00000000 _start</div><div class="line">f01013af g     F .text    0000003d strlcpy</div><div class="line">f0101412 g     F .text    00000038 strncmp</div><div class="line">f0101382 g     F .text    0000002d strncpy</div><div class="line">f010155d g     F .text    00000039 memcmp</div><div class="line">f0100661 g     F .text    00000010 cputchar</div><div class="line">f0101487 g     F .text    0000004d memset</div><div class="line">f0100671 g     F .text    00000011 getchar</div><div class="line">f0100d1c g     F .text    00000028 printfmt</div><div class="line">f010716b g       .stabstr    00000000 __STABSTR_END__</div><div class="line">f01013ec g     F .text    00000026 strcmp</div><div class="line">f0100a28 g     F .text    000001d9 debuginfo_eip</div><div class="line">f01008fe g     F .text    00000033 vcprintf</div><div class="line">f0110000 g       .data    00000000 bootstacktop</div><div class="line">f0110000 g     O .data    00001000 entry_pgdir</div><div class="line">f0108000 g       .data    00000000 bootstack</div><div class="line">f0102034 g       .stab    00000000 __STAB_BEGIN__</div><div class="line">f0101300 g     F .text    00000018 strlen</div><div class="line">f010144a g     F .text    00000021 strchr</div><div class="line">f01006d5 g     F .text    000000ca mon_kerninfo</div><div class="line">f01007a9 g     F .text    00000142 monitor</div><div class="line">f0101596 g     F .text    0000001d memfind</div><div class="line">f0100690 g     F .text    00000045 mon_help</div></pre></td></tr></table></figure>
<p>因此，这里可以看出来。program headers 就是写在ELF头里面给加载程序用的。但是这里主要关注：</p>
<ul>
<li>vaddr  加载后程序内部引用的各种虚拟地址基地址</li>
<li>paddr  加载到的物理基地址</li>
<li>memsz  这个程序段的大小</li>
<li>filesz 这个程序段所在位置起始位置。注意，这里是相对于文件头而言。 ！！</li>
</ul>
<p>这么四个变量。使用-x 输出太长了。虽然里面有些信息lab2会用到。不过对于lab1而言。只需要如下命令就可以理解了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ objdump -p obj/kern/kernel</div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Program Header:</div><div class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</div><div class="line">         filesz 0x0000716c memsz 0x0000716c flags r-x</div><div class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</div><div class="line">         filesz 0x0000a300 memsz 0x0000a944 flags rw-</div><div class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</div><div class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</div></pre></td></tr></table></figure>
<h2 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5."></a>Exercise 5.</h2><p>这里比较有意的是试一下修改boot/Makefrag文件中的-Ttext里面的起始地址。如果修改了起始地址。<br>如此一来。后面程序加载的地址就发生了变化。但是需要注意的是：如果指令里面都是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mov ax, bx</div><div class="line">mov cx, ax</div><div class="line">mov dx, ax</div></pre></td></tr></table></figure>
<p>这样的操作是不会出错的。随便改了加载地址，也可以随意进行加载。都可以work。<br>但是这样的操作就会出问题了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">   jmp jump_addr</div><div class="line"></div><div class="line">addr_tag:</div><div class="line">    .db varname 0</div><div class="line"></div><div class="line">jump_addr:</div></pre></td></tr></table></figure>
<p>任何引用到<code>addr_tag</code>和<code>jump_addr</code>这两个地址的地方都会出错。所以一旦不对应之后。运行必然出错。<br>需要注意的是kernel的地址与<code>boot loader</code>则是不一样的。</p>
<h2 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6."></a>Exercise 6.</h2><p>接下来需要利用GDB的x命令查看内存中的指令。 GDB manual 有各种详细的细节。<br>但是现在而言，只需要知道x/Nx addr命令就是为了查看从ADDR开始的N字的指令。需要注意的是：字长并不是完全统一的。在GNU汇编里面。一个字长是两个byte。比如xorw指令里面的w表示产的是两个byte。<br>重置机器。当刚进入boot loader的时候，检查在内存0x00100000开头的8个字。然后再当需要跳转到内核开始执行的时候，看一下里面的指令。为什么会不一样呢？<br>这个应该很简单了。在boot loader刚进来的时候， kernel还没有被加载到内存里面。<br>当需要跳转到内核的时候，kernel image已经被加载到了0x00100000地址处。</p>
<p><strong>What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># The Multiboot header</div><div class="line">.align 4</div><div class="line">.long MULTIBOOT_HEADER_MAGIC</div><div class="line">.long MULTIBOOT_HEADER_FLAGS</div><div class="line">.long CHECKSUM</div><div class="line"></div><div class="line"># &apos;_start&apos; specifies the ELF entry point.  Since we haven&apos;t set up</div><div class="line"># virtual memory when the bootloader enters this code, we need the</div><div class="line"># bootloader to jump to the *physical* address of the entry point.</div><div class="line">.globl          _start</div><div class="line">_start = RELOC(entry)</div><div class="line"></div><div class="line">.globl entry</div><div class="line">entry:</div><div class="line">        movw    $0x1234,0x472                   # warm boot</div><div class="line">kernel的开头就是entry.S。</div><div class="line">(gdb) x/8x 0x100000</div><div class="line">0x100000:    0x1badb002    0x00000000    0xe4524ffe    0x7205c766</div><div class="line">0x100010:    0x34000004    0x0000b812    0x220f0011    0xc0200fd8</div></pre></td></tr></table></figure>
<p>开头的三个值刚好是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_HEADER_MAGIC (0x1BADB002)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIBOOT_HEADER_FLAGS (0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS))</span></div></pre></td></tr></table></figure>
<h2 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h2><p><strong>1. Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</strong></p>
<p>Ｑ：用Qemu和GDB跳到JOS的内核里面。并且暂停在movl %eax, %cr0这条指令这里。验证内存两个地址：0x00100000 and at 0xf0100000。接下来用s指令一条一条地执行。然后再验证一下这个两个内存地址的内容。确保你理解整个发生的过程。</p>
<p>首先需要明白：程序地址与寻址地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 程序代码地址</div><div class="line">2. 支持的寻址地址</div></pre></td></tr></table></figure>
<p>如果支持的寻址地址不支持汇编里面的地址（比如页表没有建立起来）。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mov %eax, *$0xf0100000</div></pre></td></tr></table></figure>
<p>这个时候必须要知道0xf0100000真正的物理地址是什么。程序代码里直接成相应的物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    RELOC(x) ((x) - KERNBASE)</span></div></pre></td></tr></table></figure>
<p>示例1： kernel的入口地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># &apos;_start&apos; specifies the ELF entry point.  Since we haven&apos;t set up</div><div class="line"># virtual memory when the bootloader enters this code, we need the</div><div class="line"># bootloader to jump to the *physical* address of the entry point.</div><div class="line">.globl        _start</div><div class="line">_start = RELOC(entry)</div><div class="line"></div><div class="line">.globl entry</div><div class="line">entry:</div></pre></td></tr></table></figure>
<p>kernel在编译的时候是并不知道会被加载到哪里的。通过链接的时候kern/kernel.ld链接脚本可以指令被加载到的物理地址。但是程序的入口地址仍然需要告知ELF。<br>ELF执行的格式是<code>_start</code>是入口。如果不加任何处理，那么<code>_start</code>就是一个虚拟地址。这个值会反应在ELF header-&gt;e_entry值上面。(看boot/main.c)里面的跳转到内核的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// call the entry point from the ELF header</div><div class="line"> // note: does not return!</div><div class="line"> ((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>
<p>这里面<code>e_entry</code>就指向<code>_start</code>值。由于从<code>boot loader</code>跳转到的内核的时候，还在物理地址与虚拟地址完全重合的情况。并且也没有开启分页。所以这个时候必须在kern/entry.S里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.globl        _start</div><div class="line">_start = RELOC(entry)</div></pre></td></tr></table></figure>
<p>把<code>_start</code>地址改造成物理地址。这会儿，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab<span class="comment"># objdump -f obj/kern/kernel</span></div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line">architecture: i386, flags 0x00000112:</div><div class="line">EXEC_P, HAS_SYMS, D_PAGED</div><div class="line">start address 0x0010000c</div></pre></td></tr></table></figure>
<p>这个时候<code>start address</code>就是一个物理地址。</p>
<p><strong>原问题的正解</strong></p>
<p>首先对<code>entry.S</code>代码加以注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">       # Load the physical address of entry_pgdir into cr3.  entry_pgdir</div><div class="line">        # is defined in entrypgdir.c.</div><div class="line"></div><div class="line">这里把页表加载到cr3寄存器。注意加载的时候，这里是直接用的物理地址。</div><div class="line">页表还没有打开，当然是不能用到虚拟地址了。</div><div class="line"></div><div class="line">        movl    $(RELOC(entry_pgdir)), %eax</div><div class="line">f0100015:       b8 00 00 11 00          mov    $0x110000,%eax</div><div class="line">        movl    %eax, %cr3</div><div class="line">f010001a:       0f 22 d8                mov    %eax,%cr3</div><div class="line"></div><div class="line"># 开启分页模式</div><div class="line">        # Turn on paging.</div><div class="line">        movl    %cr0, %eax</div><div class="line">f010001d:       0f 20 c0                mov    %cr0,%eax</div><div class="line">        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</div><div class="line">f0100020:       0d 01 00 01 80          or     $0x80010001,%eax</div><div class="line">        movl    %eax, %cr0</div><div class="line">f0100025:       0f 22 c0                mov    %eax,%cr0</div></pre></td></tr></table></figure>
<p>所以原问题中在开启分页前去看<code>0xf0100000</code>地址时。肯定为0。因为在当前地址空间里面，这部分虚拟地址是没有内容的。页表也还没有。只能是假装去访问物理地址。<br>分页后去查看地址时。<code>0xf0100000</code>与<code>0x00100000</code>内容就完全一样了。这是因为把<code>[0, 4MB)</code>映射到了<code>[0xf0000000, 0xf0000000 + 4MB)</code>的地方了。<br>开启分页后的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">       # Now paging is enabled, but we&apos;re still running at a low EIP</div><div class="line">        # (why is this okay?).  Jump up above KERNBASE before entering</div><div class="line">        # C code.</div><div class="line">        mov     $relocated, %eax</div><div class="line">        jmp     *%eax</div><div class="line">relocated:</div></pre></td></tr></table></figure>
<p>当开启分页之后，立马会进行相应的跳转。这里主要是因为后面会开始执行C语言的函数了。必须设置好相应的CS:IP, esp, ebp, ss等寄存器。如果还是在物理地址空间运行。但是C语言是以为自己在虚拟地址空间运行的。</p>
<ul>
<li><ol>
<li>CPU跑在物理地址空间上，而不是虚拟地址空间上。（尽管CS:IP会被翻译到真正的地址。）</li>
</ol>
</li>
<li><ol>
<li>C语言认为是自己是跑在虚拟地址空间。</li>
</ol>
</li>
</ul>
<p>通过jmp，可以使得两者正常化。CPU在取指，寻址的时候，就会在有页映射的地址空间里面了。环境设置好，就可以开始跳转到C语言里面了。</p>
<p><strong>2. What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace into it, and see if you were right.</strong></p>
<p>这个问题其实也比较扯的。主要意思是说，如果把movl %eax, %cr0删除掉会发生什么样的情况。<br>删除掉之后，只要后面有涉及到寻址的地方，就会立马出错。假设把这一行注释掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    # movl    %eax, %cr0</div><div class="line"></div><div class="line">    # Now paging is enabled, but we&apos;re still running at a low EIP</div><div class="line">    # (why is this okay?).  Jump up above KERNBASE before entering</div><div class="line">    # C code.</div><div class="line">    mov    $relocated, %eax</div><div class="line">    jmp    *%eax</div><div class="line">relocated:</div><div class="line"></div><div class="line">    # Clear the frame pointer register (EBP)</div><div class="line">    # so that once we get into debugging C code,</div><div class="line">    # stack backtraces will be terminated properly.</div><div class="line">    movl    $0x0,%ebp            # nuke frame pointer</div><div class="line"></div><div class="line">    # Set the stack pointer</div><div class="line">    movl    $(bootstacktop),%esp</div></pre></td></tr></table></figure>
<p>那么在<code>movl $(bootstacktop), %esp</code>这里就立马出错了。</p>
<p>因为把<code>$bootstacktop</code>当成物理地址了。但是实际上，哪有那么大的物理地址空间。所以肯定会报错了。(万一真给了qemu那么大的物理地址空间，那边物理地址也没有内容，跳到C语言之后就会出错。)</p>
<h2 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h2><p><strong>We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</strong></p>
<p>这里的意思是说，去修改程序，使得程序能够正确地输出%o。这里还是比较简单的，只需要参考一下%d的输出代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">root@debug:~/<span class="number">6.828</span>/lab<span class="meta"># git diff</span></div><div class="line">diff --git a/lib/printfmt.c b/lib/printfmt.c</div><div class="line">index <span class="number">28e01</span>c9.<span class="number">.1</span>d3a5fa <span class="number">100644</span></div><div class="line">--- a/lib/printfmt.c</div><div class="line">+++ b/lib/printfmt.c</div><div class="line">@@ <span class="number">-206</span>,<span class="number">10</span> +<span class="number">206</span>,<span class="number">13</span> @@ vprintfmt(<span class="keyword">void</span> (*putch)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *putdat, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</div><div class="line">                <span class="comment">// (unsigned) octal</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">                        <span class="comment">// Replace this with your code.</span></div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       <span class="keyword">break</span>;</div><div class="line">+                       num = getint(&amp;ap, lflag);</div><div class="line">+                       <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123;</div><div class="line">+                               putch(<span class="string">'-'</span>, putdat);</div><div class="line">+                               num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</div><div class="line">+                       &#125;</div><div class="line">+                       base = <span class="number">8</span>;</div><div class="line">+                       <span class="keyword">goto</span> number;</div><div class="line"></div><div class="line">                <span class="comment">// pointer</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</div></pre></td></tr></table></figure>
<p>然后运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ make</div><div class="line">$ make qemu-nox</div><div class="line">6828 decimal is 15254 octal!</div></pre></td></tr></table></figure>
<p>就会看到相应的输出了。</p>
<p><strong>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</strong></p>
<p>console.c与printf.c里面有什么样的接口？<br>console.c里面暴露了哪个端口给printf.c使用？<br>答：<br>这里分析过程如下：<br>printf.c里面的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar</div></pre></td></tr></table></figure>
<p>然后cputchar的声明是在<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">./inc/stdio.h:<span class="number">11</span>:<span class="function"><span class="keyword">void</span>    <span class="title">cputchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数的定义是在console.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cputchar</span><span class="params">(<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">        cons_putc(c);</div><div class="line">&#125;</div><div class="line"><span class="comment">// output a character to the console</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">cons_putc</span><span class="params">(<span class="keyword">int</span> c)</span></div><div class="line">&#123;</div><div class="line">        serial_putc(c);</div><div class="line">        lpt_putc(c);</div><div class="line">        cga_putc(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下主要就是看<code>cga_putc</code>。也就是显示到屏幕上的函数。首先看一下<code>cga_init</code>。这个函数的功能就是选定特定的屏幕。比如<code>vga, cga</code>等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">uint16_t</span> *cp;</div><div class="line">        <span class="keyword">uint16_t</span> was;</div><div class="line">        <span class="keyword">unsigned</span> pos;</div><div class="line"></div><div class="line">        cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + CGA_BUF);</div><div class="line">        was = *cp;</div><div class="line">        *cp = (<span class="keyword">uint16_t</span>) <span class="number">0xA55A</span>;</div><div class="line">        <span class="keyword">if</span> (*cp != <span class="number">0xA55A</span>) &#123;</div><div class="line">                cp = (<span class="keyword">uint16_t</span>*) (KERNBASE + MONO_BUF);</div><div class="line">                addr_6845 = MONO_BASE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                *cp = was;</div><div class="line">                addr_6845 = CGA_BASE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Extract cursor location */</span></div><div class="line">        outb(addr_6845, <span class="number">14</span>);</div><div class="line">        pos = inb(addr_6845 + <span class="number">1</span>) &lt;&lt; <span class="number">8</span>;</div><div class="line">        outb(addr_6845, <span class="number">15</span>);</div><div class="line">        pos |= inb(addr_6845 + <span class="number">1</span>);</div><div class="line"></div><div class="line">        crt_buf = (<span class="keyword">uint16_t</span>*) cp;</div><div class="line">        crt_pos = pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，显示操作的时候，启动的时候，都是使用提<code>CGA</code>。也就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">./kern/console.h:<span class="number">14</span>:<span class="meta">#<span class="meta-keyword">define</span> CGA_BUF        0xB8000</span></div></pre></td></tr></table></figure>
<p>初始化的时候，需要设定光标的位置。设置完成之后。就可以利用<code>cga_putc</code>来CGA屏幕上显示字符了。这里可以看出来，除了各个字符的设定之外。还随时移动的光标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="comment">// if no attribute given, then use black on white</span></div><div class="line">        <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))</div><div class="line">                c |= <span class="number">0x0700</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>:</div><div class="line">                <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</div><div class="line">                        crt_pos--;</div><div class="line">                        crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">' '</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</div><div class="line">                crt_pos += CRT_COLS;</div><div class="line">                <span class="comment">/* fallthru */</span></div><div class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</div><div class="line">                crt_pos -= (crt_pos % CRT_COLS);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                cons_putc(<span class="string">' '</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">                crt_buf[crt_pos++] = c;         <span class="comment">/* write the character */</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// What is the purpose of this?</span></div><div class="line">        <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">                <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">                memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">                <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">                        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line">                crt_pos -= CRT_COLS;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* move that little blinky thing */</span></div><div class="line">        outb(addr_6845, <span class="number">14</span>);</div><div class="line">        outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</div><div class="line">        outb(addr_6845, <span class="number">15</span>);</div><div class="line">        outb(addr_6845 + <span class="number">1</span>, crt_pos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Explain the following from <code>console.c</code>:</strong></p>
<p>这段代码的作用就是在当写满一个屏幕的时候，把整个字符串往上滚动一行。<br><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一页写满，滚动一行。</span></div><div class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 把从第1~n行的内容复制到0~(n-1)行，第n行未变化</span></div><div class="line">    <span class="comment">// 通过这一行代码完成了整个屏幕向上移动一行的操作。</span></div><div class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</div><div class="line">    <span class="comment">// 把最后一行清空</span></div><div class="line">    <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</div><div class="line">        crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 清空了最后一行，同步crt_pos</span></div><div class="line">    crt_pos -= CRT_COLS;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</strong></p>
<p>单步执行以下代码。然后回答以下问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</div><div class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</div></pre></td></tr></table></figure>
<ul>
<li>In the call to cprintf(), to what does fmt point? To what does ap point?</li>
<li>List (in order of execution) each call to <code>cons_putc, va_arg</code>, and vcprintf. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what ap points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
<p>单步执行其实没有太多的必要。仔细读一下<code>cprintf</code>函数代码实现就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">putch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span></div><div class="line">&#123;</div><div class="line">        cputchar(ch);</div><div class="line">        *cnt++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line"></div><div class="line">        vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></div><div class="line">&#123;</div><div class="line">        va_list ap;</div><div class="line">        <span class="keyword">int</span> cnt;</div><div class="line"></div><div class="line">        va_start(ap, fmt);</div><div class="line">        cnt = vcprintf(fmt, ap);</div><div class="line">        va_end(ap);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面<code>va_list</code>的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="number">__b</span>uiltin_va_list va_list;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap, last) __builtin_va_start(ap, last)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap, type) __builtin_va_arg(ap, type)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap) __builtin_va_end(ap)</span></div></pre></td></tr></table></figure>
<p>结果发现这几个宏都是由<code>GCC</code>来提供了。嗯。这样实际上是不太容易能够分析清楚的。<br>最好还是看<code>mit 6.828 2007</code>版本的代码。</p>
<p>在读下面的代码的时候，一定要注意栈的方向是从高地址往低地址前进。并且压栈的时候，<br>如果是一个char，也是压入一个long。所以需要注意字长。也就是所以单位是以long对齐的。<br>比如压入了5个char。也是需要用到2个long。在32位机器上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 指针定义为char *可以指向任意一个内存地址。</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</div><div class="line"></div><div class="line"><span class="comment">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    __va_size(type) \</span></div><div class="line">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))</div><div class="line"></div><div class="line"><span class="comment">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line"><span class="comment">// va_arg就是用来取参数的起始地址的。然后返回type类型。</span></div><div class="line"><span class="comment">// 从整个表达式的意义来说没有什么好用的。</span></div><div class="line"><span class="comment">// 其实等价于(*(type*)ap)</span></div><div class="line"><span class="comment">// 但是实际上使ap指针移动一个参数大小。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// 空指令，没有什么用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_end(ap)    ((void)0)</span></div></pre></td></tr></table></figure>
<p>所以这里回到原来的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</div><div class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</div></pre></td></tr></table></figure>
<p><code>fmt</code>就是指向那个<code>const char *</code>的字符串。当调用的时候，栈中的结构是如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     X           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;-----------+&amp;fmt</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">va_start(fmt, ap) 作用如下</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line">展开就是</div><div class="line">ap = (<span class="keyword">char</span> *)(&amp;fmt) + align_long(fmt);</div><div class="line"></div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     X           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;--------------+ap</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>接下来简单一点，看一下调用到<code>%c</code>输出的时候，代码是怎么走的</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">void</div><div class="line">vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    while (1) &#123;</div><div class="line">        // 如果只是一般的字符串，直接输出。</div><div class="line">        while ((ch = *(unsigned char *) fmt++) != '%') &#123;</div><div class="line">            if (ch == '\0')</div><div class="line">                return;</div><div class="line">            putch(ch, putdat);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果发现是%c</div><div class="line">    reswitch:</div><div class="line">        // 先把%号跳掉，取出'c'</div><div class="line">        switch (ch = *(unsigned char *) fmt++) &#123;</div><div class="line">        // .. </div><div class="line">        case 'c':</div><div class="line">            putch(va_arg(ap, int), putdat);</div><div class="line">            break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候通过<code>%c</code>就知道应该从栈中取出一个参数char类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">va_arg(ap, <span class="keyword">int</span>) 展开后就是</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// putat用来统计输出的字符的个数。在这里可以不用去管</span></div><div class="line"><span class="keyword">char</span> temp = *(<span class="keyword">char</span>*)ap;</div><div class="line">putch(temp, putdat); <span class="comment">// 输出到console上。</span></div><div class="line"></div><div class="line">ap += align_long(<span class="keyword">char</span>);</div><div class="line"></div><div class="line">执行完成之后。</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Z           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     Y           |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+ &lt;------+ap</div><div class="line">|                 |</div><div class="line">|     X           |   这个x会被%d提出来进行输出。</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div><div class="line">|                 |</div><div class="line">|     fmt         |</div><div class="line">|                 |</div><div class="line">|                 |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>从这里也可以总结出来。ap的作用实际上就是利用fmt里面的<code>%</code>依次把后面的类型提出来。<br>然后去栈中找到参数。一个一个输出。</p>
<p><strong>问题4</strong>运行如下代码会输出什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">unsigned int i = 0x00646c72;</div><div class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</div></pre></td></tr></table></figure>
<p>输出是什么？解释一下?</p>
<p>首先<code>%x</code>是输出16进制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">57616</span> = <span class="number">0xE110</span>。</div><div class="line"></div><div class="line">i = <span class="number">0x00646c72</span></div><div class="line">那么如果把i占用的<span class="number">4b</span>yte转换成为<span class="keyword">char</span>[<span class="number">4</span>]数组。结果就是：</div><div class="line"></div><div class="line"><span class="keyword">char</span> str[<span class="number">4</span>] = &#123;<span class="number">0x72</span>, <span class="number">0x6c</span>, <span class="number">0x64</span>, <span class="number">0x00</span>&#125;; <span class="comment">// = &#123;'r', 'l', 'd', 0&#125;</span></div><div class="line">所以输出就是</div><div class="line"></div><div class="line">Hell0 World</div></pre></td></tr></table></figure>
<p><strong>问题5</strong></p>
<p>y后面会输出啥？这种栈越界操作，其实是无法判定的。因为不知道越界这个内存里面以前放的内容是什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cprintf(<span class="string">"x=%d y=%d"</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>GCC里面输出的时候，入栈的顺序是从函数调用方的右往左入栈。所以，最后一个参数最先入栈。第一个栈入最后入栈。<br>如果入栈顺序反过来会怎么样？</p>
<p>其实也还是可以拿到参数的。只不过需要把宏的加减法改一下就可以了。把这里的加法改成减法，减法改成加法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 指针定义为char *可以指向任意一个内存地址。</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</div><div class="line"></div><div class="line"><span class="comment">// 类型大小，注意这里是与CPU位数对齐 ＝ sizeof(long)的作用。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    __va_size(type) \</span></div><div class="line">    (((sizeof(type) + sizeof(long) - 1) / sizeof(long)) * sizeof(long))</div><div class="line"></div><div class="line"><span class="comment">// 这里个宏并不是取得参数的起始地址。而是说参数将从什么地址开始放。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_start(ap, last) \</span></div><div class="line">    ((ap) = (va_list)&amp;(last) + __va_size(last))</div><div class="line"></div><div class="line"><span class="comment">// va_arg就是用来取参数的起始地址的。然后返回type类型。</span></div><div class="line"><span class="comment">// 从整个表达式的意义来说没有什么好用的。</span></div><div class="line"><span class="comment">// 其实等价于(*(type*)ap)</span></div><div class="line"><span class="comment">// 但是实际上使ap指针移动一个参数大小。</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_arg(ap, type) \</span></div><div class="line">    (*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))</div><div class="line"></div><div class="line"><span class="comment">// 空指令，没有什么用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>    va_end(ap)    ((void)0)</span></div></pre></td></tr></table></figure>
<p><strong>挑战</strong>输出各种颜色。这种事情好玩，但是与操作系统核心偏得有点远。这里不去关注。</p>
<h2 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a>Exercise 9.</h2><p><strong>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</strong></p>
<ol>
<li>内核在哪里初始化了内核用到的栈？</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 首先boot.S里面初始化了ss段描述符。</div><div class="line">  # Set up the protected-mode data segment registers</div><div class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</div><div class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</div><div class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</div><div class="line">  movw    %ax, %fs                # -&gt; FS</div><div class="line">  movw    %ax, %gs                # -&gt; GS</div><div class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</div><div class="line"></div><div class="line">  # Set up the stack pointer and call into C.</div><div class="line">  movl    $start, %esp</div><div class="line">  call bootmain</div><div class="line"></div><div class="line">// 然后再进入到kern/entry.S。</div><div class="line">// 有意思的是，这里是把栈顶设置为0。后面在递归回溯的时候，遇到放ebp ＝ 0的时候，应该停止了。</div><div class="line">// 在后面的作业里会用到这个。</div><div class="line">// </div><div class="line">        # Clear the frame pointer register (EBP)</div><div class="line">        # so that once we get into debugging C code,</div><div class="line">        # stack backtraces will be terminated properly.</div><div class="line">        movl    $0x0,%ebp                       # nuke frame pointer</div><div class="line"></div><div class="line">        # Set the stack pointer</div><div class="line">        movl    $(bootstacktop),%esp</div><div class="line"></div><div class="line">        # now to C code</div><div class="line">        call    i386_init</div><div class="line">...</div><div class="line">###################################################################</div><div class="line"># boot stack</div><div class="line">###################################################################</div><div class="line">        .p2align        PGSHIFT         # force page alignment</div><div class="line">        .globl          bootstack</div><div class="line">bootstack:</div><div class="line">        .space          KSTKSIZE</div><div class="line">        .globl          bootstacktop</div><div class="line">bootstacktop:</div></pre></td></tr></table></figure>
<p>这里可以看一下内核的内存分配图。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Virtual memory map:                                Permissions</div><div class="line"> *                                                    kernel/user</div><div class="line"> *</div><div class="line"> *    4 Gig --------&gt;  +------------------------------+</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"> *                     :              .               :</div><div class="line"> *                     :              .               :</div><div class="line"> *                     :              .               :</div><div class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *                     |   Remapped Physical Memory   | RW/--</div><div class="line"> *                     |                              | RW/--</div><div class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</div><div class="line"> *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |</div><div class="line"> *                     | - - - - - - - - - - - - - - -|                   |</div><div class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</div><div class="line"> *                     +------------------------------+                   |</div><div class="line"> *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |</div><div class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</div><div class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</div><div class="line"> *                     +------------------------------+                   |</div><div class="line"> *                     :              .               :                   |</div><div class="line"> *                     :              .               :                   |</div><div class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</div><div class="line"></div><div class="line">./inc/memlayout.h:97:#define KSTKSIZE    (8*PGSIZE)           // size of a kernel stack</div></pre></td></tr></table></figure>
<p>可以看出来。kernel就是把内核栈放到了kernel代码的后面。大小就是一个<code>KSTKSIZE</code>。</p>
<h2 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h2><p>为了熟悉C函数调用的转换。可以在<code>obj/kern/kernel.asm</code>中找到<code>test_backtrace</code>函数。在那里设置一个断点。<br>然后验证每次调用的时候发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Test the stack backtrace function (lab 1 only)</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">test_backtrace</span><span class="params">(<span class="keyword">int</span> x)</span></div><div class="line">&#123;</div><div class="line">    cprintf(<span class="string">"entering test_backtrace %d\n"</span>, x);</div><div class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</div><div class="line">        test_backtrace(x<span class="number">-1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cprintf(<span class="string">"leaving test_backtrace %d\n"</span>, x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用方进行的操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">将参数由右向左压入栈</div><div class="line">将返回地址 (eip中的内容) 入栈，在 call 指令执行</div><div class="line"></div><div class="line">函数内部执行: </div><div class="line">f0100040:       55                      push   %ebp</div><div class="line">f0100041:       89 e5                   mov    %esp,%ebp</div><div class="line">f0100043:       53                      push   %ebx</div><div class="line">f0100044:       83 ec 14                sub    $0x14,%esp</div><div class="line"></div><div class="line">将上一个函数的 ebp 入栈</div><div class="line">将 ebx 入栈，保护寄存器状态</div><div class="line">在栈上开辟一个空间存储局部变量。这里会有5个int的空间。</div></pre></td></tr></table></figure>
<p>整理过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./kern/init.c:39:    test_backtrace(5);</div><div class="line">主函数的调用  x = 5</div><div class="line"></div><div class="line">1. move <span class="variable">$0x5</span>, (%esp)       ;执行的是movl <span class="variable">$0x05</span>, %(esp); 执行完之后。此时esp = 0xf010ffe0. ebp = 0xf010fff8</div><div class="line">2. push f01000ea(retaddr)  ;这是压入test_backtrace(5);返回之后的地址。执行完之后 esp = 0xf010ffe0 - 4;</div><div class="line"></div><div class="line">3. push %ebp               ;压入0xf010fff8.  执行完之后。esp = 0xf010ffe0 - 8;</div><div class="line">   movl %esp, %ebp         ;执行完之后ebp = esp = 0xf010ffe0 - 8 = 0xf010ffd8</div><div class="line">4. push %ebx               ;不管这里%ebx是多少。总之esp = 0xf010ffd8 - 4 = 0xf010ffd4</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ;esp = 0xf010ffd4 - 0x14 = 0xf010ffc0</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">0xf010ffa0:    0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    0x00000005    0xf010ffd8    0xf0100069</div><div class="line">0xf010ffc0:    5.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>接着开始第二轮，也就是真正的递归。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">接着开始第二轮  x == 4</div><div class="line">在函数递归调用的时候，是这么调用的。</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div><div class="line"></div><div class="line"></div><div class="line">1. mov  %eax,(%esp)        ; 执行完成之后. esp = 0xf010ffc0，这里eax也就是等于x-1。也就是4</div><div class="line">2. push f0100069 (retaddr) ; 执行完成之后，esp = 0xf010ffbc</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ffb8</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ffb8</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ffb4</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ; 执行完成之后, esp = 0xf010ffa0</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">0xf010ffa0:    5.0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    4.0x00000005    3.0xf010ffd8    2.0xf0100069</div><div class="line">0xf010ffc0:    1.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>然后开始第三轮，也就是把x=3开始调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">接着开始第二轮  x == 3</div><div class="line">在函数递归调用的时候，是这么调用的。</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div><div class="line"></div><div class="line"></div><div class="line">1. mov  %eax,(%esp)        ; 执行完成之后. esp = 0xf010ffa0，这里eax也就是等于x-1。也就是3</div><div class="line">2. push f0100069 (retaddr) ; 执行完成之后，esp = 0xf010ff9c</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ff98</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ff98</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ff94</div><div class="line">5. subl <span class="variable">$0x14</span>, %esp        ; 执行完成之后, esp = 0xf010ff80</div><div class="line"></div><div class="line">(gdb) x/64x <span class="variable">$esp</span></div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">0xf010ff80:    5.0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004(ebx)    3. 0xf010ffb8    2.0xf0100069</div><div class="line">0xf010ffa0:    1.0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    4.0x00000005    3.0xf010ffd8    2.0xf0100069</div><div class="line">0xf010ffc0:    1.esp_0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    4.0x00010094    3.0xf010fff8    2.0xf01000ea (返回地址)</div><div class="line">0xf010ffe0:    1.0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>后面就不用再依次展开，可以把这个过程分为以下几个部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(gdb) x/64x $esp</div><div class="line">// x == 0的时候</div><div class="line">0xf010ff20:    0xf01019a0    0x00000000    0xf010ff58    0x00000000</div><div class="line">0xf010ff30:    0xf01008eb    0x00000001    0xf010ff58    0xf0100069</div><div class="line">// x == 1</div><div class="line">0xf010ff40:    0x00000000    0x00000001    0xf010ff78    0x00000000</div><div class="line">0xf010ff50:    0xf01008eb    0x00000002    0xf010ff78    0xf0100069</div><div class="line">// x == 2</div><div class="line">0xf010ff60:    0x00000001    0x00000002    0xf010ff98    0x00000000</div><div class="line">0xf010ff70:    0xf01008eb    0x00000003    0xf010ff98    0xf0100069</div><div class="line">// x == 3</div><div class="line">0xf010ff80:    0x00000002    0x00000003    0xf010ffb8    0x00000000</div><div class="line">0xf010ff90:    0xf01008eb    0x00000004    0xf010ffb8    0xf0100069</div><div class="line">// x == 4</div><div class="line">0xf010ffa0:    0x00000003    0x00000004    0x00000000    0x00000000</div><div class="line">0xf010ffb0:    0x00000000    0x00000005    0xf010ffd8    0xf0100069</div><div class="line">// x = 5</div><div class="line">0xf010ffc0:    0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    0x00010094    0xf010fff8    0xf01000ea</div><div class="line"></div><div class="line">0xf010ffe0:    0x00000005    0x00001aac    0x00000644    0x00000000</div><div class="line">0xf010fff0:    0x00000000    0x00000000    0x00000000    0xf010003e</div></pre></td></tr></table></figure>
<p>注意，看每一个部分的时候，一定要注意：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">进入函数之后</div><div class="line">3. push 0xf010ffd8 (%ebp)  ; 执行完成之后，esp = 0xf010ffb8</div><div class="line">   movl %esp, %ebp         ; 执行完成之后, esp = ebp = 0xf010ffb8</div><div class="line">4. push %ebx               ; 执行完成之后, esp = 0xf010ffb4</div><div class="line">5. subl $0x14, %esp        ; 执行完成之后, esp = 0xf010ffa0</div><div class="line"></div><div class="line">然后递归调用的时候</div><div class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</div><div class="line">f0100061:       89 04 24                mov    %eax,(%esp)</div><div class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</div></pre></td></tr></table></figure></p>
<p>所以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// x = 5</div><div class="line">0xf010ffc0:    0x00000004    0x00000005    0x00000000    0x00010094</div><div class="line">0xf010ffd0:    0x00010094    0x00010094    0xf010fff8    0xf01000ea</div><div class="line"></div><div class="line">0xf010ffe0:    0x00000005</div></pre></td></tr></table></figure>
<p>这里<code>0xf010ffc0:    0x00000004</code>这个4.实际上是在x = 5的时候，开始往函数里面填写参数的时候生成的。 </p>
<p>此外，也需要记住每次<code>%ebp</code>指针的变化图。</p>
<h2 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a>Exercise 11.</h2><p>通过以上的代码操作，给足了信息，已经实现一个栈回溯的程序了<code>mon_backtrace()</code>。这个函数的原型已经等着你去填相应的代码了。<br><code>kern/monitor.c</code>。但是在操作的时候，必须全部使用<code>C</code>语言。在<code>inc/x86.h</code>里面的<code>read_ebp()</code>函数会是非常有用的。<br>此外也需要在内核中添加一个命令，用来支持<code>monitor</code>命令的输出。</p>
<p>通过命令可以得到如下的输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Stack backtrace:</div><div class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</div><div class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>每一行都包含了<code>ebp, eip, args</code>。这段小代码还是比较好处理的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Your code here.</span></div><div class="line">  <span class="keyword">uint32_t</span> ebp = read_ebp();</div><div class="line">  <span class="meta">#<span class="meta-keyword">define</span> TO_INT(x)  *((uint32_t*)(x))</span></div><div class="line">  <span class="keyword">while</span> (ebp) &#123;</div><div class="line">    <span class="comment">// ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span></div><div class="line">    cprintf(<span class="string">"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,</div><div class="line">            TO_INT(ebp),       <span class="comment">/*ebp*/</span></div><div class="line">            TO_INT((ebp+<span class="number">4</span>)),   <span class="comment">/*eip*/</span></div><div class="line">            TO_INT((ebp+<span class="number">8</span>)),   <span class="comment">/*arg1*/</span></div><div class="line">            TO_INT((ebp+<span class="number">12</span>)),  <span class="comment">/*arg2*/</span></div><div class="line">            TO_INT((ebp+<span class="number">16</span>)),  <span class="comment">/*arg3*/</span></div><div class="line">            TO_INT((ebp+<span class="number">20</span>)),  <span class="comment">/*arg4*/</span></div><div class="line">            TO_INT((ebp+<span class="number">24</span>)));  <span class="comment">/*arg5*/</span></div><div class="line">    ebp = TO_INT(ebp);</div><div class="line">  &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码还是比较简单的。</p>
<p><img src="/blog/img/mit.6.828/call.stack.jpeg" alt=""></p>
<h2 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h2><p>修改<code>stack backtrace</code>函数来显示每个<code>eip, fun_name, source_file_name, line_number</code>等与<code>eip</code>相关联系的信息。<br>在<code>debuginfo_eip</code>里面，<code>__STAB_*</code>这些信息是从哪里来的呢？这里可以通过以下方式来了解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">look in the file kern/kernel.ld for __STAB_*</div><div class="line">run objdump -h obj/kern/kernel</div><div class="line">run objdump -G obj/kern/kernel</div><div class="line">run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</div></pre></td></tr></table></figure>
<h3 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.stabstr : &#123;</div><div class="line">    PROVIDE(__STABSTR_BEGIN__ = .);</div><div class="line">    *(.stabstr);</div><div class="line">    PROVIDE(__STABSTR_END__ = .);</div><div class="line">    BYTE(0)        /* Force the linker to allocate space</div><div class="line">               for this section */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如通过<code>objdump -h obj/kern/kernel</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@debug:~/6.828/lab# objdump -h obj/kern/kernel</div><div class="line"></div><div class="line">obj/kern/kernel:     file format elf32-i386</div><div class="line"></div><div class="line">Sections:</div><div class="line">Idx Name          Size      VMA       LMA       File off  Algn</div><div class="line">  0 .text         000019d7  f0100000  00100000  00001000  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div><div class="line">  1 .rodata       0000079c  f01019e0  001019e0  000029e0  2**5</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  2 .stab         00003955  f010217c  0010217c  0000317c  2**2</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  3 .stabstr      000018ba  f0105ad1  00105ad1  00006ad1  2**0</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</div><div class="line">  4 .data         0000a300  f0108000  00108000  00009000  2**12</div><div class="line">                  CONTENTS, ALLOC, LOAD, DATA</div><div class="line">  5 .bss          00000644  f0112300  00112300  00013300  2**5</div><div class="line">                  ALLOC</div><div class="line">  6 .comment      0000002b  00000000  00000000  00013300  2**0</div><div class="line">                  CONTENTS, READONLY</div></pre></td></tr></table></figure>
<p>这里就可以看到<code>.stabstr</code>段。</p>
<p>而<code>objdump -G obj/kern/kernel</code>可以把所有的详细信息都打印出来。<br>在链接脚本里面，明确指定了所有的字符都需要加载到固定的段里面。</p>
<p>需要在kern/monitor.c里面添加代码，完成功能如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">K&gt; backtrace</div><div class="line">Stack backtrace:</div><div class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</div><div class="line">         kern/monitor.c:143: monitor+106</div><div class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</div><div class="line">         kern/init.c:49: i386_init+59</div><div class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</div><div class="line">         kern/entry.S:70: &lt;unknown&gt;+0</div><div class="line">K&gt;</div></pre></td></tr></table></figure>
<p>每一行都会输出文件名以及行(根据eip得到)。但是需要注意的是这个monitor+106并不是说在monitor的106行。而是说离monitor的开始有106个bytes。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 一定要把文件名，函数名，等相应的信息另起一行进行输出。</div><div class="line">Be sure to print the file and function names on a separate line, to avoid confusing the grading script.</div></pre></td></tr></table></figure>
<p><code>printf(&quot;%.*s&quot;, length, string)</code> 可以输出指定长度的字符串。</p>
<p>由于优化的原因，一些<code>inline</code>的函数会被编译到调用方的代码里面。所以看到的结果会少掉某些函数。这主要是<code>-O2</code>这个代码优化带来的。</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>其实主要看上面格式的说明就行了。其他扯的太多，对求解作业不一定特别有用。</p>
<p><strong>文件名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">909    SO     0      2      f0101340 5591   lib/readline.c</div></pre></td></tr></table></figure>
<p>所以在根据<code>eip</code>来查找的时候，首先找文件。以下代码来自于函数<br><code>int debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Search the entire set of stabs for the source file (type N_SO).</span></div><div class="line">lfile = <span class="number">0</span>;</div><div class="line">rfile = (stab_end - stabs) - <span class="number">1</span>;</div><div class="line">stab_binsearch(stabs, &amp;lfile, &amp;rfile, N_SO, addr);</div><div class="line"><span class="keyword">if</span> (lfile == <span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div></pre></td></tr></table></figure>
<p><strong>函数</strong></p>
<p>原函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">char *</div><div class="line">strcpy(char *dst, const char *src)</div><div class="line">&#123;</div><div class="line">  char *ret;</div><div class="line"></div><div class="line">  ret = dst;</div><div class="line">  while ((*dst++ = *src++) != &apos;\0&apos;)</div><div class="line">    /* do nothing */;</div><div class="line">  return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析之后得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1131   FUN    0      0      f0101a69 6099   strcpy:F(0,20)=*(0,2)</div><div class="line">1132   PSYM   0      0      00000008 6121   dst:p(0,20) &lt;--- 栈中的偏移</div><div class="line">1133   PSYM   0      0      0000000c 6133   src:p(0,19) &lt;--- 栈中的偏移</div><div class="line">1134   SLINE  0      33     00000000 0 // 00000000 ---&gt; 33, 这里33就是表示函数定义的行号。</div><div class="line">1135   SLINE  0      36     00000006 0 // 第一行代码相对文件的行号。</div><div class="line">1136   SLINE  0      37     0000000c 0</div><div class="line">1137   SLINE  0      37     0000000d 0</div><div class="line">1138   SLINE  0      39     0000002b 0</div><div class="line">1139   SLINE  0      40     0000002e 0</div><div class="line">1140   LSYM   0      0      fffffffc 6145   ret:(0,20)</div><div class="line">1141   LBRAC  0      0      00000000 0</div><div class="line">1142   RBRAC  0      0      00000030 0</div></pre></td></tr></table></figure>
<p>第一行是函数名。第二行是符号名，第三行SLINE开始是函数体里面的代码。<code>LYSM</code>表示函数局部变量符号。<br><code>LBRAC</code>表示函数左边的花括号。<code>RBRAC</code>表示函数右边的花括号。</p>
<p>所以当给定<code>eip</code>之后。搜索到file之后。就开始找函数名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Search within that file's stabs for the function definition</span></div><div class="line"><span class="comment">// (N_FUN).</span></div><div class="line">lfun = lfile;</div><div class="line">rfun = rfile;</div><div class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_FUN, addr);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (lfun &lt;= rfun) &#123;</div><div class="line">  <span class="comment">// stabs[lfun] points to the function name</span></div><div class="line">  <span class="comment">// in the string table, but check bounds just in case.</span></div><div class="line">  <span class="keyword">if</span> (stabs[lfun].n_strx &lt; stabstr_end - stabstr)</div><div class="line">    info-&gt;eip_fn_name = stabstr + stabs[lfun].n_strx;</div><div class="line">  info-&gt;eip_fn_addr = stabs[lfun].n_value;</div><div class="line">  addr -= info-&gt;eip_fn_addr;</div><div class="line">  <span class="comment">// Search within the function definition for the line number.</span></div><div class="line">  lline = lfun;</div><div class="line">  rline = rfun;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// Couldn't find function stab!  Maybe we're in an assembly</span></div><div class="line">  <span class="comment">// file.  Search the whole file for the line number.</span></div><div class="line">  info-&gt;eip_fn_addr = addr;</div><div class="line">  lline = lfile;</div><div class="line">  rline = rfile;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Ignore stuff after the colon.</span></div><div class="line">info-&gt;eip_fn_namelen = strfind(info-&gt;eip_fn_name, <span class="string">':'</span>) - info-&gt;eip_fn_name;</div></pre></td></tr></table></figure>
<p><code>stab_binsearch</code>这个函数有意思的地方是：输入参数<code>lxxx, rxxx</code>,进去的时候，即是限制范围。也是最后的返回值。<br>此外，如果是跳到汇编代码里面的话，是无法找到函数体的定义的。在这种情况下就改变策略，只能把范围设置为整个文件。</p>
<p><strong>stabs</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Entries in the STABS table are formatted as follows.</span></div><div class="line"><span class="keyword">struct</span> Stab &#123;</div><div class="line">    <span class="keyword">uint32_t</span> n_strx;        <span class="comment">// index into string table of name</span></div><div class="line">    <span class="keyword">uint8_t</span> n_type;         <span class="comment">// type of symbol</span></div><div class="line">    <span class="keyword">uint8_t</span> n_other;        <span class="comment">// misc info (usually empty)</span></div><div class="line">    <span class="keyword">uint16_t</span> n_desc;        <span class="comment">// description field</span></div><div class="line">    <span class="keyword">uintptr_t</span> n_value;        <span class="comment">// value of symbol --&gt; 这里就是指地址。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">root@debug:~/<span class="number">6.828</span>/lab<span class="meta"># git diff</span></div><div class="line">diff --git a/kern/kdebug.c b/kern/kdebug.c</div><div class="line">index <span class="number">9547143.</span>.f85b570 <span class="number">100644</span></div><div class="line">--- a/kern/kdebug.c</div><div class="line">+++ b/kern/kdebug.c</div><div class="line">@@ <span class="number">-180</span>,<span class="number">6</span> +<span class="number">180</span>,<span class="number">25</span> @@ debuginfo_eip(<span class="keyword">uintptr_t</span> addr, <span class="keyword">struct</span> Eipdebuginfo *info)</div><div class="line">        <span class="comment">//      which one.</span></div><div class="line">        <span class="comment">// Your code here.</span></div><div class="line"></div><div class="line">+  <span class="keyword">int</span> olline = lline, orline = rline;</div><div class="line">+  stab_binsearch(stabs, &amp;olline, &amp;orline, N_SOL, (!(lline == lfile &amp;&amp; rline == rfile))*addr + info-&gt;eip_fn_addr);</div><div class="line">+  <span class="comment">// 如果没有找到N_SOL</span></div><div class="line">+  <span class="keyword">if</span> (olline &gt; orline) &#123;</div><div class="line">+    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</div><div class="line">+    <span class="comment">// 如果在N_SLINE也没有找到</span></div><div class="line">+    <span class="keyword">if</span> (lline &gt; rline) &#123;</div><div class="line">+       <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">+    &#125;</div><div class="line">+  &#125;</div><div class="line">+  <span class="comment">// 记录找到的行号</span></div><div class="line">+  info-&gt;eip_line = stabs[lline].n_desc;</div><div class="line">+</div><div class="line"></div><div class="line">        <span class="comment">// Search backwards from the line number for the relevant filename</span></div><div class="line">        <span class="comment">// stab.</span></div><div class="line">diff --git a/kern/monitor.c b/kern/monitor.c</div><div class="line">index e137e92..a0f188d <span class="number">100644</span></div><div class="line">--- a/kern/monitor.c</div><div class="line">+++ b/kern/monitor.c</div><div class="line">@@ <span class="number">-24</span>,<span class="number">6</span> +<span class="number">24</span>,<span class="number">7</span> @@ <span class="keyword">struct</span> Command &#123;</div><div class="line"> <span class="keyword">static</span> <span class="keyword">struct</span> Command commands[] = &#123;</div><div class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</div><div class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</div><div class="line">+  &#123; <span class="string">"backtrace"</span>, <span class="string">"Display backtrace info"</span>, mon_backtrace &#125;,</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="comment">/***** Implementations of basic kernel monitor commands *****/</span></div><div class="line">@@ <span class="number">-58</span>,<span class="number">6</span> +<span class="number">59</span>,<span class="number">30</span> @@ <span class="function"><span class="keyword">int</span></span></div><div class="line"> <span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></div><div class="line"> &#123;</div><div class="line">        <span class="comment">// Your code here.</span></div><div class="line">+  <span class="keyword">uint32_t</span> ebp = read_ebp();</div><div class="line">+  <span class="keyword">uint32_t</span> eip = <span class="number">0</span>;</div><div class="line">+  <span class="keyword">struct</span> Eipdebuginfo info;</div><div class="line">+  <span class="meta">#<span class="meta-keyword">define</span> TO_INT(x)  *((uint32_t*)(x))</span></div><div class="line">+  <span class="keyword">while</span> (ebp) &#123;</div><div class="line">+    eip = TO_INT((ebp+<span class="number">4</span>));</div><div class="line">+    cprintf(<span class="string">"ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,</div><div class="line">+            ebp,                <span class="comment">/*ebp*/</span></div><div class="line">+            eip,                <span class="comment">/*eip*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">8</span>)),    <span class="comment">/*arg1*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">12</span>)),   <span class="comment">/*arg2*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">16</span>)),   <span class="comment">/*arg3*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">20</span>)),   <span class="comment">/*arg4*/</span></div><div class="line">+            TO_INT((ebp+<span class="number">24</span>)));  <span class="comment">/*arg5*/</span></div><div class="line">+</div><div class="line">+    <span class="keyword">if</span>(!debuginfo_eip(eip, &amp;info)) &#123;</div><div class="line">+      cprintf(<span class="string">"%s:%d: %.*s+%d\n"</span>,</div><div class="line">+              info.eip_file,</div><div class="line">+              info.eip_line,</div><div class="line">+              info.eip_fn_namelen, info.eip_fn_name,</div><div class="line">+              eip - info.eip_fn_addr);</div><div class="line">+    &#125;</div><div class="line">+    ebp = TO_INT(ebp);</div><div class="line">+  &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">diff --git a/lib/printfmt.c b/lib/printfmt.c</div><div class="line">index <span class="number">28e01</span>c9.<span class="number">.1</span>d3a5fa <span class="number">100644</span></div><div class="line">--- a/lib/printfmt.c</div><div class="line">+++ b/lib/printfmt.c</div><div class="line">@@ <span class="number">-206</span>,<span class="number">10</span> +<span class="number">206</span>,<span class="number">13</span> @@ vprintfmt(<span class="keyword">void</span> (*putch)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *putdat, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</div><div class="line">                <span class="comment">// (unsigned) octal</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'o'</span>:</div><div class="line">                        <span class="comment">// Replace this with your code.</span></div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       putch(<span class="string">'X'</span>, putdat);</div><div class="line">-                       <span class="keyword">break</span>;</div><div class="line">+                       num = getint(&amp;ap, lflag);</div><div class="line">+                       <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123;</div><div class="line">+                               putch(<span class="string">'-'</span>, putdat);</div><div class="line">+                               num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</div><div class="line">+                       &#125;</div><div class="line">+                       base = <span class="number">8</span>;</div><div class="line">+                       <span class="keyword">goto</span> number;</div><div class="line"></div><div class="line">                <span class="comment">// pointer</span></div><div class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</div></pre></td></tr></table></figure>
<p><strong>出错记录</strong></p>
<ul>
<li>输出ebp的时候，输出成了<code>TO_INT(ebp)</code></li>
<li>N_SOL表示内联函数引进来的代码行。在处理的时候需要处理掉。</li>
<li>当没有找到函数的时候。一定要注意：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注意前面的处理：如果是能够找到相应的函数定义，那么</span></div><div class="line"><span class="comment">// addr -= info-&gt;eip_fn_addr;</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">468    FUN    0      0      f0100690 3954   mon_backtrace:F(0,1)</div><div class="line">472    SLINE  0      60     00000000 0</div><div class="line">473    SLINE  0      80     00000007 0</div><div class="line">474    SOL    0      0      f01006a3 2929   ./inc/x86.h</div><div class="line">475    SLINE  0      214    00000013 0  &lt;-- 这一行是在x86.h里面的read_ebp()</div><div class="line">476    SOL    0      0      f01006a5 3661   kern/monitor.c</div><div class="line">477    SLINE  0      82     00000015 0</div><div class="line">478    SLINE  0      84     00000017 0</div><div class="line">479    SLINE  0      85     00000051 0</div><div class="line">480    SLINE  0      82     00000053 0</div><div class="line">481    SLINE  0      88     00000057 0</div><div class="line">483    LBRAC  0      0      00000000 0      // 左花括号</div><div class="line">484    RBRAC  0      0      00000062 0      // 左花括号</div><div class="line">*/</div><div class="line"><span class="comment">// 是不是应该先找一下SOL?</span></div><div class="line"><span class="comment">/*</span></div><div class="line">if (lline == lfile &amp;&amp; rline == rfile) &#123;</div><div class="line">    // 如果没有找到函数，那么addr就没有被减过</div><div class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SOL, info-&gt;eip_fn_addr);</div><div class="line">&#125; else &#123;</div><div class="line">    // 如果找到过函数，那么addr就被减过了</div><div class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SOL, addr += info-&gt;eip_fn_addr);</div><div class="line">&#125;这段代码可以简化成如下代码</div></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2018/04/19/mit.6.828/jos-lab2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          MIT 6.828 Lab2
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab1" data-title="MIT 6.828 Lab1" data-url="https://jiyou.github.io/blog/blog/2018/04/15/mit.6.828/jos-lab1/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>