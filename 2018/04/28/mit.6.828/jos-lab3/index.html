<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>MIT 6.828 Lab3 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="合并首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。
athena% cd ~/6.828/labathena% add gitathena% git commit -am &apos;changes to lab2 after handin&apos;Created commit 734fab7: changes to lab2 after handin 4 files changed,">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Lab3">
<meta property="og:url" content="https://jiyou.github.io/blog/2018/04/28/mit.6.828/jos-lab3/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="合并首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。
athena% cd ~/6.828/labathena% add gitathena% git commit -am &apos;changes to lab2 after handin&apos;Created commit 734fab7: changes to lab2 after handin 4 files changed,">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/mit.6.828/lab3.idt.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/lab3.process.jpeg">
<meta property="og:image" content="https://jiyou.github.io/blog/blog/img/mit.6.828/lab3.irq.jpeg">
<meta property="og:updated_time" content="2018-04-28T02:43:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Lab3">
<meta name="twitter:description" content="合并首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。
athena% cd ~/6.828/labathena% add gitathena% git commit -am &apos;changes to lab2 after handin&apos;Created commit 734fab7: changes to lab2 after handin 4 files changed,">
<meta name="twitter:image" content="https://jiyou.github.io/blog/blog/img/mit.6.828/lab3.idt.jpeg">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-mit.6.828/jos-lab3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/28/mit.6.828/jos-lab3/" class="article-date">
  	<time datetime="2018-04-28T02:28:32.000Z" itemprop="datePublished">2018-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MIT 6.828 Lab3
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">athena% <span class="built_in">cd</span> ~/6.828/lab</div><div class="line">athena% add git</div><div class="line">athena% git commit -am <span class="string">'changes to lab2 after handin'</span></div><div class="line">Created commit 734fab7: changes to lab2 after handin</div><div class="line"> 4 files changed, 42 insertions(+), 9 deletions(-)</div><div class="line">athena% git pull</div><div class="line">Already up-to-date.</div><div class="line">athena% git checkout -b lab3 origin/lab3</div><div class="line">Branch lab3 <span class="built_in">set</span> up to track remote branch refs/remotes/origin/lab3.</div><div class="line">Switched to a new branch <span class="string">"lab3"</span></div><div class="line">athena% git merge lab2</div><div class="line">Merge made by recursive.</div><div class="line"> kern/pmap.c |   42 +++++++++++++++++++</div><div class="line"> 1 files changed, 42 insertions(+), 0 deletions(-)</div><div class="line">athena%</div></pre></td></tr></table></figure>
<h1 id="增加的文件"><a href="#增加的文件" class="headerlink" title="增加的文件"></a>增加的文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"></div><div class="line">inc/    env.h    Public definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        trap.h    Public definitions <span class="keyword">for</span> <span class="built_in">trap</span> handling</div><div class="line">        syscall.h    Public definitions <span class="keyword">for</span> system calls from user environments to the kernel</div><div class="line">        lib.h    Public definitions <span class="keyword">for</span> the user-mode support library</div><div class="line">kern/    env.h    Kernel-private definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        env.c    Kernel code implementing user-mode environments</div><div class="line">        trap.h    Kernel-private <span class="built_in">trap</span> handling definitions</div><div class="line">        trap.c    Trap handling code</div><div class="line">        trapentry.S    Assembly-language <span class="built_in">trap</span> handler entry-points</div><div class="line">        syscall.h    Kernel-private definitions <span class="keyword">for</span> system call handling</div><div class="line">        syscall.c    System call implementation code</div><div class="line">lib/    Makefrag    Makefile fragment to build user-mode library, obj/lib/libjos.a</div><div class="line">        entry.S    Assembly-language entry-point <span class="keyword">for</span> user environments</div><div class="line">        libmain.c    User-mode library setup code called from entry.S</div><div class="line">        syscall.c    User-mode system call stub <span class="built_in">functions</span></div><div class="line">        console.c    User-mode implementations of putchar and getchar, providing console I/O</div><div class="line">        exit.c    User-mode implementation of <span class="built_in">exit</span></div><div class="line">        panic.c    User-mode implementation of panic</div><div class="line">user/    *    Various <span class="built_in">test</span> programs to check kernel lab 3 code</div></pre></td></tr></table></figure>
<p>这里面就是lab3新增加的文件。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>JOS里面是把进程叫做<code>env</code>。定义是在<code>inc/env.h</code>。内核是用这个数据结构来管理用户的进程。</p>
<p>进程的结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env &#123;</div><div class="line">    struct Trapframe env_tf;    // Saved registers</div><div class="line">    struct Env *env_link;        // Next free Env</div><div class="line">    envid_t env_id;            // Unique environment identifier</div><div class="line">    envid_t env_parent_id;        // env_id of this env&apos;s parent</div><div class="line">    enum EnvType env_type;        // Indicates special system environments</div><div class="line">    unsigned env_status;        // Status of the environment</div><div class="line">    uint32_t env_runs;        // Number of times environment has run</div><div class="line"></div><div class="line">    // Address space</div><div class="line">    pde_t *env_pgdir;        // Kernel virtual address of page dir</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后详细介绍了每个字段。</p>
<p><strong>env_tf</strong><br>This structure, defined in inc/trap.h, holds the saved register values for the environment while that environment is not running: i.e., when the kernel or a different environment is running. The kernel saves these when switching from user to kernel mode, so that the environment can later be resumed where it left off.</p>
<p><strong>env_link</strong><br>This is a link to the next Env on the env_free_list. env_free_list points to the first free environment on the list.</p>
<p><strong>env_id</strong><br>The kernel stores here a value that uniquely identifiers the environment currently using this Env structure (i.e., using this particular slot in the envs array). After a user environment terminates, the kernel may re-allocate the same Env structure to a different environment - but the new environment will have a different env_id from the old one even though the new environment is re-using the same slot in the envs array.</p>
<p><strong>env_parent_id</strong><br>The kernel stores here the env_id of the environment that created this environment. In this way the environments can form a “family tree,” which will be useful for making security decisions about which environments are allowed to do what to whom.</p>
<p><strong>env_type</strong><br>This is used to distinguish special environments. For most environments, it will be ENV_TYPE_USER. We’ll introduce a few more types for special system service environments in later labs.</p>
<p><strong>env_status</strong><br>This variable holds one of the following values:</p>
<p><strong>ENV_FREE</strong><br>Indicates that the Env structure is inactive, and therefore on the<br>env_free_list.</p>
<p><strong>ENV_RUNNABLE</strong><br>Indicates that the Env structure represents an environment that is waiting to run on the processor.</p>
<p><strong>ENV_RUNNING</strong><br>Indicates that the Env structure represents the currently running environment.</p>
<p><strong>ENV_NOT_RUNNABLE</strong><br>Indicates that the Env structure represents a currently active environment, but it is not currently ready to run: for example, because it is waiting for an interprocess communication (IPC) from another environment.</p>
<p><strong>ENV_DYING</strong><br>Indicates that the Env structure represents a zombie environment. A zombie environment will be freed the next time it traps to the kernel. We will not use this flag until Lab 4.</p>
<p><strong>env_pgdir</strong><br>This variable holds the kernel virtual address of this environment’s page directory.</p>
<p>这个结构体是由一个链表来管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env *envs = NULL;        // All environments</div><div class="line">struct Env *curenv = NULL;        // The current env</div><div class="line">static struct Env *env_free_list;    // Free environment list</div></pre></td></tr></table></figure>
<h1 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exercise 1. Modify mem_init() in kern/pmap.c to allocate and map the envs array. This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.</div><div class="line"></div><div class="line">You should run your code and make sure check_kern_pgdir() succeeds.</div></pre></td></tr></table></figure>
<p>这里其实就是两个要求。一个是在内核内存区域分配一段区域来保存这个结构体。<br>另外就是把这个结构体映射到UENVS这个区域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</div><div class="line">// LAB 3: Your code here.</div><div class="line">n = sizeof(struct Env) * NENV;</div><div class="line">envs = (struct Env*) boot_alloc(n);</div><div class="line">memset(envs, 0, n);</div><div class="line"></div><div class="line">...</div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</div><div class="line">// (ie. perm = PTE_U | PTE_P).</div><div class="line">// Permissions:</div><div class="line">//    - the new image at UENVS  -- kernel R, user R</div><div class="line">//    - envs itself -- kernel RW, user NONE</div><div class="line">// LAB 3: Your code here.</div><div class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure>
<p>只需要认真读一注释就可以写出来。没有什么难度。</p>
<h1 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h1><p>配置运行环境。这里讲了一些有意思的用法。考虑这种情况。比如内核里面需要包含一个独立的程序。但是内核本身就是一个大的程序。那么如何把这个小程序放到内核里面去。</p>
<p>比如<code>obj/user/</code>这里生成一堆小程序。那么如何把这些程序放到内核程序里面？<br>实际上这些处理技巧在<code>kern/Makefrag</code>里面。</p>
<p>首先是定义需要生成的<code>binary</code>的文件列表</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Binary program images to embed within the kernel.</span></div><div class="line"><span class="comment"># Binary files for LAB3</span></div><div class="line">KERN_BINFILES :=    user/hello \</div><div class="line">            user/buggyhello \</div><div class="line">            user/buggyhello2 \</div><div class="line">            user/evilhello \</div><div class="line">            user/testbss \</div><div class="line">            user/divzero \</div><div class="line">            user/breakpoint \</div><div class="line">            user/softint \</div><div class="line">            user/badsegment \</div><div class="line">            user/faultread \</div><div class="line">            user/faultreadkernel \</div><div class="line">            user/faultwrite \</div><div class="line">            user/faultwritekernel</div><div class="line"></div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.c, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_SRCFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.S, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst $(OBJDIR)</span>/lib/%, <span class="variable">$(OBJDIR)</span>/kern/%, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line"></div><div class="line">KERN_BINFILES := <span class="variable">$(patsubst %, $(OBJDIR)</span>/%, <span class="variable">$(KERN_BINFILES)</span>)</div></pre></td></tr></table></figure>
<p>通过如下这种方式把<code>binary</code>放到kernel中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># How to build the kernel itself</div><div class="line">$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \</div><div class="line">      $(OBJDIR)/.vars.KERN_LDFLAGS</div><div class="line">    @echo + ld $@</div><div class="line">    $(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES)</div><div class="line">    $(V)$(OBJDUMP) -S $@ &gt; $@.asm</div><div class="line">    $(V)$(NM) -n $@ &gt; $@.sym</div></pre></td></tr></table></figure>
<p>注意后面<code>-b</code>这个参数就是把后面的文件直接加载到kernel里面。由于我们现在没有文件系统，内核就把用户程序一股脑链接到自己身上，在以后有了文件系统就不需要了。但是它给了我们一个便利，我们现在可以直接在内存上运行它。</p>
<p>可执行程序现在是加载到kernel的镜像里面了。可是如果想运行的时候，又如何定位到这些程序呢？</p>
<p>这个时候如果去看<code>obj/kern/kernel.sym</code>，就会发现这里面定义了很多变量。<code>gcc</code>生成的<code>.sym</code>文件里面包含的就是编译器生成的变量表，左边是虚拟地址，右边就是对应的变量。</p>
<p>链接命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo @ld -o obj/kern/kernel \</div><div class="line">    -m elf_i386 \</div><div class="line">    -T kern/kernel.ld \</div><div class="line">    -nostdlib \</div><div class="line">        obj/kern/entry.o \</div><div class="line">        obj/kern/entrypgdir.o \</div><div class="line">        obj/kern/init.o \</div><div class="line">        obj/kern/console.o \</div><div class="line">        obj/kern/monitor.o \</div><div class="line">        obj/kern/pmap.o \</div><div class="line">        obj/kern/env.o \</div><div class="line">        obj/kern/kclock.o \</div><div class="line">        obj/kern/printf.o \</div><div class="line">        obj/kern/trap.o \</div><div class="line">        obj/kern/trapentry.o \</div><div class="line">        obj/kern/syscall.o \</div><div class="line">        obj/kern/kdebug.o  \</div><div class="line">        obj/kern/printfmt.o  \</div><div class="line">        obj/kern/readline.o  \</div><div class="line">        obj/kern/string.o \</div><div class="line">        /usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a \</div><div class="line">    -b binary  \</div><div class="line">        obj/user/hello  \</div><div class="line">        obj/user/buggyhello \</div><div class="line">        obj/user/buggyhello2  \</div><div class="line">        obj/user/evilhello  \</div><div class="line">        obj/user/testbss  \</div><div class="line">        obj/user/divzero  \</div><div class="line">        obj/user/breakpoint \</div><div class="line">        obj/user/softint \</div><div class="line">        obj/user/badsegment \</div><div class="line">        obj/user/faultread \</div><div class="line">        obj/user/faultreadkernel \</div><div class="line">        obj/user/faultwrite \</div><div class="line">        obj/user/faultwritekernel</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f011b356 D _binary_obj_user_hello_start</div><div class="line">f0122b88 D _binary_obj_user_buggyhello_start</div><div class="line">f0122b88 D _binary_obj_user_hello_end</div><div class="line">f012a3bf D _binary_obj_user_buggyhello2_start</div><div class="line">f012a3bf D _binary_obj_user_buggyhello_end</div><div class="line">f0131c11 D _binary_obj_user_buggyhello2_end</div><div class="line">f0131c11 D _binary_obj_user_evilhello_start</div><div class="line">f0139447 D _binary_obj_user_evilhello_end</div><div class="line">f0139447 D _binary_obj_user_testbss_start</div><div class="line">f0140c94 D _binary_obj_user_divzero_start</div><div class="line">f0140c94 D _binary_obj_user_testbss_end</div><div class="line">f01484dd D _binary_obj_user_breakpoint_start</div><div class="line">f01484dd D _binary_obj_user_divzero_end</div><div class="line">f014fd14 D _binary_obj_user_breakpoint_end</div><div class="line">f014fd14 D _binary_obj_user_softint_start</div><div class="line">f0157548 D _binary_obj_user_badsegment_start</div><div class="line">f0157548 D _binary_obj_user_softint_end</div><div class="line">f015ed7f D _binary_obj_user_badsegment_end</div><div class="line">f015ed7f D _binary_obj_user_faultread_start</div><div class="line">f01665b5 D _binary_obj_user_faultread_end</div><div class="line">f01665b5 D _binary_obj_user_faultreadkernel_start</div><div class="line">f016ddf1 D _binary_obj_user_faultreadkernel_end</div><div class="line">f016ddf1 D _binary_obj_user_faultwrite_start</div><div class="line">f0175628 D _binary_obj_user_faultwrite_end</div><div class="line">f0175628 D _binary_obj_user_faultwritekernel_start</div><div class="line">f017ce65 D _binary_obj_user_faultwritekernel_end</div></pre></td></tr></table></figure>
<p>在内核代码里面就可以通过这些变量的指示来找到相应的程序的内存在哪里。<br>那么，这些变量又是如何生成的呢？</p>
<p><a href="https://balau82.wordpress.com/2012/02/19/linking-a-binary-blob-with-gcc/" target="_blank" rel="external">gcc include binary files</a></p>
<p>这里我们假设想把一个<code>hello.c</code>文件生成的<code>binary</code>放到<code>main.c</code>生成的<code>main</code>程序里面。操作如下：</p>
<p><strong>编译hello.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cat &lt;&lt;<span class="string">"EOF"</span>&gt; hello.<span class="function">c</span></div><div class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line">gcc hello.c -o hello</div></pre></td></tr></table></figure>
<p><strong>提取binary</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gcc hello.c -o hello</div><div class="line">objcopy -I binary -O elf32-i386 -B i386 hello hello.o</div></pre></td></tr></table></figure>
<p>首先说一下原理。</p>
<ul>
<li>编译生成<code>hello</code>，这是一个<code>elf</code>格式的完全可以独立运行的格式。</li>
<li>第二句话是将<code>hello</code>这个完整的<code>elf</code>当成一个巨大的<code>char binary[]</code>数组。类似于生成如下汇编代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">.global <span class="number">_b</span>inary_hello_start</div><div class="line">.global <span class="number">_b</span>inary_hello_end</div><div class="line">.global <span class="number">_b</span>inary_hello_size</div><div class="line"><span class="number">_b</span>inary_hello_start:</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line"><span class="number">_b</span>inary_hello_end:</div><div class="line"><span class="number">_b</span>inary_hello_size:</div><div class="line">    .dword x32xxx</div></pre></td></tr></table></figure>
<p>其中<code>xxxx</code>部分就是表示<code>hello</code>整个<code>ELF</code>文件的内容。</p>
<p><code>hello.o</code>就是把这个<code>.asm</code>汇编代码转成<code>object</code>文件。不信用<code>nm -n</code>命令查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># nm -n hello.o</span></div><div class="line">00000000 D _binary_hello_start</div><div class="line">00001c88 D _binary_hello_end</div><div class="line">00001c88 A _binary_hello_size</div><div class="line">root@debug:/tmp<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>所以这里需要明白。这里的<code>hello.o</code>与</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c hello.c -o hello.o</div></pre></td></tr></table></figure>
<p>是不一样的。这两个有本质的区别。并且比较<code>hello</code>与汇编生成的<code>hello.o</code>两者的大小，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># ls -al hello hello.o</span></div><div class="line">-rwxr-xr-x 1 root root 7304  4月 24 08:05 hello</div><div class="line">-rw-r--r-- 1 root root 7730  4月 24 08:05 hello.o  &lt;-- 要大很多</div></pre></td></tr></table></figure>
<p><strong>添加</strong></p>
<p>准备<code>main.c</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_start;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_end;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_size;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *pblob = &amp;<span class="number">_b</span>inary_hello_start;</div><div class="line">  <span class="keyword">while</span>(pblob &lt; &amp;<span class="number">_b</span>inary_hello_end)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %02X\n"</span>, pblob - &amp;<span class="number">_b</span>inary_hello_start, *pblob);</div><div class="line">    pblob++;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"size: %d\n"</span>, &amp;<span class="number">_b</span>inary_hello_size);</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>整合到一起</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c main.c -o main.o</div><div class="line">gcc main.o hello.o -o <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h2 id="env-init"><a href="#env-init" class="headerlink" title="env_init()"></a>env_init()</h2><p>这个函数的作用很简单，就是完成如下功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></div><div class="line"><span class="comment">// 把env_ids = 0</span></div><div class="line"><span class="comment">// and insert them into the env_free_list.</span></div><div class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></div><div class="line"><span class="comment">// 注意顺序，链表的是顺序与数组的顺序是完全一致的。</span></div><div class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></div><div class="line"><span class="comment">// env_alloc() returns envs[0]).</span></div><div class="line"><span class="comment">// 比如第一次申请的时候，肯定拿到的是envs[0]</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Set up envs array</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 直接用memset把所有元素清0了。</span></div><div class="line">    <span class="comment">// 这里其实不用清0也没有关系。是因为在mem_init里面已经清0b 。</span></div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(envs));</div><div class="line">    env_free_list = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        envs[i].env_link = env_free_list;</div><div class="line">        env_free_list = envs + i;</div><div class="line">    &#125;</div><div class="line">    assert(env_free_list == envs);</div><div class="line">    <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">    env_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里犯过的一个错误是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样操作，实际上是会造成溢出。这个循环也就会一直出问题。</p>
<h2 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm()"></a>env_setup_vm()</h2><p>这个函数的功能实际上就是给进程分配页目录表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></div><div class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></div><div class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></div><div class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></div><div class="line"><span class="comment">// of the environment's virtual address space.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></div><div class="line"><span class="comment">//    -E_NO_MEM if page directory or table could not be allocated.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">struct</span> PageInfo *p = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a page for the page directory</span></div><div class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">    <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//    - The VA space of all envs is identical above UTOP</span></div><div class="line">    <span class="comment">//    (except at UVPT, which we've set below).</span></div><div class="line">    <span class="comment">//    See inc/memlayout.h for permissions and layout.</span></div><div class="line">    <span class="comment">//    Can you use kern_pgdir as a template?  Hint: Yes.</span></div><div class="line">    <span class="comment">//    (Make sure you got the permissions right in Lab 2.)</span></div><div class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></div><div class="line">    <span class="comment">//    - You do not need to make any more calls to page_alloc.</span></div><div class="line">    <span class="comment">//    - Note: In general, pp_ref is not maintained for</span></div><div class="line">    <span class="comment">//    physical pages mapped only above UTOP, but env_pgdir</span></div><div class="line">    <span class="comment">//    is an exception -- you need to increment env_pgdir's</span></div><div class="line">    <span class="comment">//    pp_ref for env_free to work correctly.</span></div><div class="line">    <span class="comment">//    - The functions in kern/pmap.h are handy.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 要点：高于UTOP的虚拟地址都是一样的。因为给内核用了。但是UVPT除外。</span></div><div class="line">    <span class="comment">//      这里需要利用kern_pgdir作为一个模板</span></div><div class="line">    <span class="comment">// 确保kern_pgdir里面的权限是正确设置的。</span></div><div class="line">    <span class="comment">//      1. 小于UTOP的地址是空的</span></div><div class="line">    <span class="comment">//      2. 不需要调用page_alloc</span></div><div class="line">    <span class="comment">//      3. pp_ref高于UTOP的部分是不维护的。因为只有内核在用。</span></div><div class="line">    <span class="comment">//         但是env_pgdir是个例外，因为可能其他进程的页表会引用到</span></div><div class="line">    <span class="comment">//         所以需要p-&gt;pp_ref++;</span></div><div class="line">    e-&gt;env_pgdir = page2kva(p);</div><div class="line">    p-&gt;pp_ref++;</div><div class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"></div><div class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">    <span class="comment">// Permissions: kernel R, user R</span></div><div class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里也是像内核一样，把<code>UVPT</code>这块空间映射到了页目录表这里。通过这样一个映射。进程在查看自己的<br>内存信息的时候，可以直接通过<code>UVPT</code>这个地址得到。</p>
<p>这样可以发现，内核并没有提供一个叫<code>get_pgdir(void **pgdir)</code>这样的一个系统调用给用户进程。<br>而是通过一种共享内存的方式来实现的。而在<code>linux</code>系统里面，很多信息则是通过<code>/proc, /sysfs</code>这两个文件系统<br>接口来提供的。</p>
<h2 id="region-alloc"><a href="#region-alloc" class="headerlink" title="region_alloc"></a>region_alloc</h2><p><code>region_alloc</code>函数的功能就是填充<code>va</code>起始的虚拟地址。需要找到长度为<code>len</code>的物理内存地址来填满。<br>函数总的来说，还是比较简单。毕竟只是一个<code>lab</code>。并不需要考虑页面不够的情况。</p>
<p>唯一需要处理的就是把地址对齐之后，然后一页一页地开始处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></div><div class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></div><div class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></div><div class="line"><span class="comment">// Pages should be writable by user and kernel.</span></div><div class="line"><span class="comment">// Panic if any allocation attempt fails.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">    <span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">    <span class="comment">// 分配len字节的物理地址给进程env，并且要映射到虚拟地址va.</span></div><div class="line">    <span class="comment">// 不要初始化这个映射的页面。</span></div><div class="line">    <span class="comment">// 页面要可读，可写</span></div><div class="line">    <span class="comment">// 如果分配失败要panic.</span></div><div class="line">    <span class="comment">// region_alloc</span></div><div class="line">    <span class="keyword">void</span> *v = ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">size_t</span> l = ROUNDUP(len, PGSIZE);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; l; i += PGSIZE) &#123;</div><div class="line">        <span class="keyword">struct</span> PageInfo *p = page_alloc(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (!p) &#123;</div><div class="line">            panic(<span class="string">"region_alloc :%e"</span>, -E_NO_MEM);</div><div class="line">        &#125;</div><div class="line">        assert(!page_insert(e-&gt;env_pgdir, p, v, PTE_U | PTE_W));</div><div class="line">        v += PGSIZE;</div><div class="line">        <span class="comment">// 不要溢出</span></div><div class="line">        assert(v &gt; va &amp;&amp; i &lt; len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对于溢出的检查和处理。</p>
<h2 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h2><p><code>load_icode</code>函数本身是用来加载整个程序的。因为程序是<code>ELF</code>格式的。<br><code>ELF</code>里面提明了需要加到载的段内存地址<code>ph-&gt;p_va</code>，要加载的段的长度<code>ph-&gt;p_filesz</code>等信息。<br>仔细读一下注释就可以把代码写出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></div><div class="line"><span class="comment">// for a user process.</span></div><div class="line"><span class="comment">// 设置一个初始的程序代码段，栈，CPU标志位给用户程序。</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// 这个函数只会在内核初始化的时候被调用。并且是在第一次跳到用户</span></div><div class="line"><span class="comment">// 模式环境之前。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></div><div class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></div><div class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 这个函数加载所有从ELF二进制里面可加载的段到用户环境的内存里面。</span></div><div class="line"><span class="comment">// 加载到合适的想到的虚拟地址那里去。</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></div><div class="line"><span class="comment">// that are marked in the program header as being mapped</span></div><div class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 同时这个程序也会把应该清0的段对应的内存进行清0操作。比如程序里面的</span></div><div class="line"><span class="comment">// bss段。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></div><div class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></div><div class="line"><span class="comment">// boot/main.c to get ideas.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 实际上这个跟我们前面在bootloader里面做的事情是很像的。这个时候可以看</span></div><div class="line"><span class="comment">// 看boot/main.c。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Finally, this function maps one page for the program's initial stack.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 最后会加载一页做为程序初始的栈。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// load_icode panics if it encounters problems.</span></div><div class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></div><div class="line"><span class="comment">// 在什么情况下load_icode会挂掉。</span></div><div class="line"><span class="comment">// 给定的输入可能会出啥问题。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">uint8_t</span> *binary)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Hints:</span></div><div class="line">    <span class="comment">//  Load each program segment into virtual memory</span></div><div class="line">    <span class="comment">//  at the address specified in the ELF segment header.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF header里面记录了所有的段的信息。</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  只加载：ph-&gt;p_type = ELF_PROG_LOAD</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段的虚拟地址: ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  段大小: ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></div><div class="line">    <span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></div><div class="line">    <span class="comment">//  ph-&gt;p_va.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段起始: binary + ph-&gt;p_offset</span></div><div class="line">    <span class="comment">//  段长： ph-&gt;p_filesz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Any remaining memory bytes should be cleared to zero.</span></div><div class="line">    <span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  清零段：ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  All page protection bits should be user read/write for now.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  页权限: PTE_U | PTE_W</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></div><div class="line">    <span class="comment">//  assume for this function that no two segments will touch</span></div><div class="line">    <span class="comment">//  the same virtual page.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF段不需要页对齐：不会有两个段指向同样的虚拟地址</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You may find a function like region_alloc useful.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  region_alloc有用</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Loading the segments is much simpler if you can move data</span></div><div class="line">    <span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></div><div class="line">    <span class="comment">//  So which page directory should be in force during</span></div><div class="line">    <span class="comment">//  this function?</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  加载段还是比较简单的，比如可以把数据直接从含有ELF虚拟地址空间</span></div><div class="line">    <span class="comment">//  复制过去。所以这个时候应该加载的是哪个页目录表？</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You must also do something with the program's entry point,</span></div><div class="line">    <span class="comment">//  to make sure that the environment starts executing there.</span></div><div class="line">    <span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  你必须要利用program entry来做一些事情，以确保后面从这里开始执行。</span></div><div class="line">    <span class="comment">//  env_run &amp; env_pop_tf().</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Elf *ELFHDR = (<span class="keyword">struct</span> Elf*)binary;</div><div class="line">    assert(ELFHDR-&gt;e_magic == ELF_MAGIC);</div><div class="line">    <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></div><div class="line">    ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">    eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">            region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">            <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">            <span class="keyword">uint8_t</span> *dst = (<span class="keyword">uint8_t</span>*)ph-&gt;p_va;</div><div class="line">            <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">            <span class="comment">// uint8_t *dst = page2kva(page_lookup(e-&gt;env_pgdir, (void *)(ph-&gt;p_va), NULL));</span></div><div class="line">            <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">                <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lcr3(PADDR(kern_pgdir));</div><div class="line">    e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div><div class="line"></div><div class="line">    <span class="comment">// Now map one page for the program's initial stack</span></div><div class="line">    <span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    region_alloc(e, (<span class="keyword">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里唯一需要注意的是：以下这种方式是不工作的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">        region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">        <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">        <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">        <span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div><div class="line">        <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">            <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div></pre></td></tr></table></figure>
<p>首先说一下这种写法的意图。意图就是通过<code>kern_pgdir</code>这个虚拟地址空间把相应的页拷贝过去。<br>但是这里需要注意的是。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div></pre></td></tr></table></figure>
<p>这种拷贝方式只对单页面有效的。对于一个段，如果超出两个页，而这个两个页面在物理上并不连续的时候。<br>就出问题。</p>
<p>此外，一定要注意<code>tf_eip</code>的设置。</p>
<h2 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a>env_create</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></div><div class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// The new env's parent ID is set to 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Env *init_task = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 必须成功</span></div><div class="line">    assert(!env_alloc(&amp;init_task, <span class="number">0</span>));</div><div class="line">    init_task-&gt;env_parent_id = <span class="number">0</span>;</div><div class="line">    init_task-&gt;env_type = type;</div><div class="line">    load_icode(init_task, binary);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是申请一个进程描述符，然后把相应的代码加载上去。</p>
<h2 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a>env_run</h2><p>调度到用户进程上执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Context switch from curenv to env e.</span></div><div class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function does not return.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></div><div class="line">    <span class="comment">//       1. Set the current environment (if any) back to</span></div><div class="line">    <span class="comment">//          ENV_RUNNABLE if it is ENV_RUNNING (think about</span></div><div class="line">    <span class="comment">//          what other states it can be in),</span></div><div class="line">    <span class="comment">//       2. Set 'curenv' to the new environment,</span></div><div class="line">    <span class="comment">//       3. Set its status to ENV_RUNNING,</span></div><div class="line">    <span class="comment">//       4. Update its 'env_runs' counter,</span></div><div class="line">    <span class="comment">//       5. Use lcr3() to switch to its address space.</span></div><div class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></div><div class="line">    <span class="comment">//       registers and drop into user mode in the</span></div><div class="line">    <span class="comment">//       environment.</span></div><div class="line"></div><div class="line">    <span class="comment">// Hint: This function loads the new environment's state from</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf.  Go back through the code you wrote above</span></div><div class="line">    <span class="comment">//    and make sure you have set the relevant parts of</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf to sensible values.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">    curenv = e;</div><div class="line">    curenv-&gt;env_status = ENV_RUNNING;</div><div class="line">    e-&gt;env_runs++;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line">    <span class="comment">// panic("env_run not yet implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是做了一个非常简单的进程切换。把当前<code>curenv</code>进程切换到要运行的进程<code>e</code>上面。<br>过程还是比较简单，直接把页目录表加载上去之后，就开始跑了。</p>
<p>调用过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">start (kern/entry.S)</div><div class="line">i386_init (kern/init.c)</div><div class="line">    cons_init</div><div class="line">    mem_init</div><div class="line">    env_init</div><div class="line">    trap_init (still incomplete at this point)</div><div class="line">    env_create  # 建页目录表，加载代码</div><div class="line">    env_run     # 切换上下文</div><div class="line">        env_pop_tf</div></pre></td></tr></table></figure>
<p>注意，这里如果打算直接跑一下<code>make qemu-nox</code>的话。整个<code>OS</code>会不断地重启。<br>这是因为中断还没有设置。当<code>hello world</code>打算退出的时候，就会调用<code>sys_exit</code>系统调用。<br>中断还没有设置时，就会遇以保护错误。这个时候系统就会不断重启。</p>
<p><strong>注意</strong>如果是使用的MIT打补丁的<code>qemu</code>是不会重启的。只是这里没有必要专门为了这么一个实验去<br>搞他的那个补丁。</p>
<h1 id="中断号的描述"><a href="#中断号的描述" class="headerlink" title="中断号的描述"></a>中断号的描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:id :type :errorCode :info</div><div class="line">:0 :Fault :No :Divide Error</div><div class="line">:1 :Fault/Trap :No :Debug Exception</div><div class="line">:2 :Interrupt :No :NMI Interrupt</div><div class="line">:3 :Trap :No :Breakpoint</div><div class="line">:4 :Trap :No :Overflow</div><div class="line">:5 :Fault :No :Bound Check</div><div class="line">:6 :Fault :No :Illegal Opcode</div><div class="line">:7 :Fault :No :Device Not available</div><div class="line">:8 :Abort :Yes :Double Fault</div><div class="line">:10 :Fault :Yes :Invalid TSS</div><div class="line">:11 :Fault :Yes :Segment Not Present</div><div class="line">:12 :Fault :Yes :Stack Exception</div><div class="line">:13 :Fault :Yes :General Protection Fault</div><div class="line">:14 :Fault :Yes :Page Fault</div><div class="line">:16 :Fault :No :Floating Point Error</div><div class="line">:17 :Fault :Yes :Alignment Check</div><div class="line">:18 :Abort :No :Machine Check</div><div class="line">:19 :Fault :No :Simd Floating Point Error</div></pre></td></tr></table></figure>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>这里需要看一下这个图。</p>
<p><img src="/blog/img/mit.6.828/lab3.idt.jpeg" alt=""></p>
<p>如果对应到源码里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* Interrupt descriptor table.  (Must be built at run time because</span></div><div class="line"> * shifted function addresses can't be represented in relocation records.)</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> Gatedesc idt[<span class="number">256</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;</div><div class="line"><span class="keyword">struct</span> Pseudodesc idt_pd = &#123;</div><div class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>) idt</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的<code>idt</code>就是存放256个中断描述符的地方。只过这个时候还没有把<code>idt</code>加载到<code>CPU</code>上。而在<code>trap_init</code>的时候<br>把这些中断描述符填上去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">struct</span> Segdesc gdt[];</div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DIVIDE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEBUG_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_NMI_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BRKPT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_OFLOW_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BOUND_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ILLOP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEVICE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DBLFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_TSS_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SEGNP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_STACK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_GPFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_PGFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_FPERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ALIGN_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_MCHK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SIMDERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SYSCALL_handler</span><span class="params">()</span></span>;</div><div class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, T_DIVIDE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, T_DEBUG_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, T_NMI_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, T_BRKPT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_OFLOW], <span class="number">1</span>, GD_KT, T_OFLOW_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, T_BOUND_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, T_ILLOP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, T_DEVICE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, T_DBLFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, T_TSS_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, T_SEGNP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, T_STACK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, T_GPFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, T_PGFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, T_FPERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, T_ALIGN_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, T_MCHK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, T_SIMDERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, T_SYSCALL_handler, <span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Per-CPU setup </span></div><div class="line">    trap_init_percpu();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init_percpu</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></div><div class="line">    <span class="comment">// when we trap to the kernel.</span></div><div class="line">    ts.ts_esp0 = KSTACKTOP;</div><div class="line">    ts.ts_ss0 = GD_KD;</div><div class="line">    ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</div><div class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></div><div class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></div><div class="line">    ltr(GD_TSS0);</div><div class="line"></div><div class="line">    <span class="comment">// Load the IDT</span></div><div class="line">    lidt(&amp;idt_pd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可能的面临的一个问题是，这些中断处理程序是在哪里定义的呢？那么接下来写<code>trapentry.S</code>。</p>
<h3 id="trapentry-S"><a href="#trapentry-S" class="headerlink" title="trapentry.S"></a>trapentry.S</h3><p>整个中断的调用过程如下图所示：</p>
<p><img src="/blog/img/lab3.process.jpeg" alt=""></p>
<p>因此，在写代码的时候，需要先写<code>trapentry.S</code>里面的代码。首先读一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</div><div class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</div><div class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</div><div class="line"> *</div><div class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</div><div class="line"> * need to _declare_ one in C (for instance, to get a function pointer</div><div class="line"> * during IDT setup).  You can declare the function with</div><div class="line"> *   void NAME();</div><div class="line"> * where NAME is the argument passed to TRAPHANDLER.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER(name, num)                        \</div><div class="line">    .globl name;        /* define global symbol for &apos;name&apos; */    \</div><div class="line">    .type name, @function;    /* symbol type is function */        \</div><div class="line">    .align 2;        /* align function definition */        \</div><div class="line">    name:            /* function starts here */        \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div><div class="line"></div><div class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</div><div class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class="line"> * format in either case.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER_NOEC(name, num)                    \</div><div class="line">    .globl name;                            \</div><div class="line">    .type name, @function;                        \</div><div class="line">    .align 2;                            \</div><div class="line">    name:                                \</div><div class="line">    pushl $0;                            \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div></pre></td></tr></table></figure>
<p>这是因为<code>x86</code>的CPU硬件在遇到中断的时候，会进行自动化的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 如果是在ring <span class="number">0</span>，那么直接使用当前的ss/esp</div><div class="line"><span class="number">2.</span> 如果是在ring <span class="number">3</span>, 那么使用当前tss段里面的ss0/esp0。然后开始压栈</div></pre></td></tr></table></figure>
<p>无错误码时压栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>对于这种情况。<code>TRAPHANDLER_NOEC</code>会额外地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pushl $0;</div></pre></td></tr></table></figure>
<p>有错误码时压栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20</div><div class="line">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>因此，当压完栈之后。栈中的元素就是对应下面罗列的元素。由此可知，<br><strong>硬件栈是从上往下增长，一个结构体，代码最下面的元素是最先入栈。</strong></p>
<p>如果把结构体里面所有的元素放在从左往右的一行上。压栈顺序与函数入栈的顺序也是一样的。即从<strong>右往左</strong>入栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Trapframe &#123;</div><div class="line">    .....</div><div class="line">    <span class="keyword">uint32_t</span> tf_trapno;</div><div class="line">    <span class="comment">/* below here defined by x86 hardware */</span></div><div class="line">    <span class="keyword">uint32_t</span> tf_err;</div><div class="line">    <span class="keyword">uintptr_t</span> tf_eip;</div><div class="line">    <span class="keyword">uint16_t</span> tf_cs;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding3;</div><div class="line">    <span class="keyword">uint32_t</span> tf_eflags;</div><div class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></div><div class="line">    <span class="keyword">uintptr_t</span> tf_esp;</div><div class="line">    <span class="keyword">uint16_t</span> tf_ss;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding4;</div><div class="line">&#125; <span class="number">__</span>attribute__((packed));</div></pre></td></tr></table></figure>
<p>这些元素，有些是硬件压入栈的。有些是两个宏压入栈的。<br>但是，这两个宏的本意是用来声明中断处理函数的。这个时候可以根据硬件中断的描述编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line">TRAPHANDLER_NOEC(T_DIVIDE_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(T_DEBUG_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(T_NMI_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(T_BRKPT_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(T_OFLOW_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(T_BOUND_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(T_ILLOP_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(T_DEVICE_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(T_DBLFLT_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(T_TSS_handler, T_TSS)</div><div class="line">TRAPHANDLER(T_SEGNP_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(T_STACK_handler, T_STACK)</div><div class="line">TRAPHANDLER(T_GPFLT_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(T_PGFLT_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(T_FPERR_handler, T_FPERR)</div><div class="line">TRAPHANDLER(T_ALIGN_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(T_MCHK_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(T_SIMDERR_handler, T_SIMDERR)</div><div class="line">TRAPHANDLER_NOEC(T_SYSCALL_handler, T_SYSCALL)</div></pre></td></tr></table></figure>
<p>在写这里的时候，一定不要忘了系统调用号<code>T_SYSCALL</code>的设置。</p>
<h3 id="统一的中断处理"><a href="#统一的中断处理" class="headerlink" title="统一的中断处理"></a>统一的中断处理</h3><p>但是<code>struct Trapframe</code>里面还有好多其他元素。后面还是需要接着再入栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line"> * 注意压栈的顺序是从struct Trapframe的底部往上压</div><div class="line"> * 看一下前面的宏，已经压参数，压到了tf_trapno这里了。</div><div class="line"> * 注意：使用pusha指令</div><div class="line"> */</div><div class="line">_alltraps:</div><div class="line">    /*</div><div class="line">     * 注意这里直接用了pushl前面自动补0</div><div class="line">     * 如果要严格的对应</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %ds</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %es</div><div class="line">     */</div><div class="line">    pushl %ds</div><div class="line">    pushl %es</div><div class="line">    pushal</div><div class="line">    /*</div><div class="line">     * 这里是因为后面要调用trap函数</div><div class="line">     * 1. </div><div class="line">     *   trap函数的定义是trap(struct Trapframe *tf)</div><div class="line">     *   这里还有一个指针</div><div class="line">     *   这个时候压入pushl %esp这个寄存器的内容。</div><div class="line">     *   也就刚好是真正的指向struct Trapframe这个object的起始地址</div><div class="line">     * 2. </div><div class="line">     *   如果trap函数的定义是trap(struct Trapframe tfObject)</div><div class="line">     *   那么这个pushl %esp是没有必要压进去的</div><div class="line">     */</div><div class="line">    pushl %esp</div><div class="line">    /*然后指向内核数据段</div><div class="line">     * 硬件上中断门描述符进来的时候</div><div class="line">     * 已经把CPU设置成了GD_KT也就是内核代码段。</div><div class="line">     * 这个是硬件操作</div><div class="line">     */</div><div class="line">    movw $GD_KD, %ax</div><div class="line">    movw %ax, %ds</div><div class="line">    movw %ax, %es</div><div class="line">    call trap</div><div class="line"></div><div class="line">    /* 操作完成之后，</div><div class="line">     * 没有必要要按照反方向的顺序返回</div><div class="line">     * 因为trap函数最终会走到env_pop_tf()这个函数</div><div class="line">     * movl $tf, %esp</div><div class="line">     * popal</div><div class="line">     * popl %es</div><div class="line">     * popl %ds</div><div class="line">     * addl $0x08, %esp</div><div class="line">     * iret</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>注意上面代码中的注释。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个时候可以总结一下了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 发生中断或者trap，从ldtr里面找到ldt。</div><div class="line">2. 根据中断号找到这一项，即ldt[中断号]</div><div class="line">3. 根据ldt[中断号] == SETGATE(idt[T_MCHK], 0, GD_KT, T_MCHK_handler, 0);</div><div class="line">   取出当时设置的中断处理函数</div><div class="line">4. 跳转到中断函数</div><div class="line">5. 中断处理函数再跳转到trap函数。</div><div class="line">6. trap函数再根据tf-&gt;trap_no中断号来决定分发给哪个函数。</div></pre></td></tr></table></figure>
<p>也就是如下图：</p>
<p><img src="/blog/img/mit.6.828/lab3.irq.jpeg" alt=""></p>
<h2 id="trap-dispatch"><a href="#trap-dispatch" class="headerlink" title="trap_dispatch"></a>trap_dispatch</h2><p>trap函数接下来就是调用<code>trap_dispatch</code>分发了中断。所以函数的具体实现还得转到<code>trap_dispatch</code>这个函数里面来。<br>这个时候就要开始做练习5了。</p>
<p>Exercise 5. Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>.<br>You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>,<br><code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and<br>fix them. Remember that you can boot JOS into a particular user program using <code>make run-x</code><br>or <code>make run-x-nox</code>. For instance, <code>make run-hello-nox</code> runs the <code>hello</code> user program.</p>
<p>这里还是比较简单。<strong>注意</strong>这里只需要转到<code>page_fault_handler()</code>就可以了。并不需要在<code>page_fault_handler()</code>里面做任何真正的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"><span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</div><div class="line"><span class="keyword">case</span> T_PGFLT:</div><div class="line">    page_fault_handler(tf);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，对于断点来说，也是需要再加一个<code>case</code>就可了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_BRKPT:</div><div class="line">    monitor(tf);</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>但是需要注意，在以前写代码的时候，设置<code>SETGATE</code>的时候，需要设置<code>dpl=3</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SETGATE(idt[T_BRKPT], 1, GD_KT, T_BRKPT_handler, 3);</div></pre></td></tr></table></figure>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在开始写之前，需要考虑客户端是如何调用的。<code>inc/syscall.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* system call numbers */</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    SYS_cputs = <span class="number">0</span>,</div><div class="line">    SYS_cgetc,</div><div class="line">    SYS_getenvid,</div><div class="line">    SYS_env_destroy,</div><div class="line">    NSYSCALLS</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里定义了系统调用的数目。客户端的使用代码位于<code>lib/syscall.c</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">static inline int32_t</div><div class="line">syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</div><div class="line">&#123;</div><div class="line">    int32_t ret;</div><div class="line"></div><div class="line">    // Generic system call: pass system call number in AX,</div><div class="line">    // up to five parameters in DX, CX, BX, DI, SI.</div><div class="line">    // Interrupt kernel with T_SYSCALL.</div><div class="line">    //</div><div class="line">    // The "volatile" tells the assembler not to optimize</div><div class="line">    // this instruction away just because we don't use the</div><div class="line">    // return value.</div><div class="line">    //</div><div class="line">    // The last clause tells the assembler that this can</div><div class="line">    // potentially change the condition codes and arbitrary</div><div class="line">    // memory locations.</div><div class="line"></div><div class="line">    asm volatile("int %1\n"      // 这里指向num</div><div class="line">             : "=a" (ret)        // 返回值从eax 设置到 ret里面。</div><div class="line">             : "i" (T_SYSCALL),  // 这里随意选择一个寄存器</div><div class="line">               "a" (num),        // 把想要调用的中断号给eax</div><div class="line">               "d" (a1),         // 第一个参数给edx</div><div class="line">               "c" (a2),         // 第二个参数给ecx</div><div class="line">               "b" (a3),         // 第三个参数给ebx</div><div class="line">               "D" (a4),         // 第四个参数给edi</div><div class="line">               "S" (a5)          // 第五个参数给esi</div><div class="line">             : "cc", "memory");</div><div class="line"></div><div class="line">    // 如果我们的指令可以修改条件码寄存器（cc），我们必须将 "cc" 添加进修饰寄存器列表。</div><div class="line">    // 如果我们的指令以不可预测的方式修改了内存，那么需要将 "memory" 添加进修饰寄存器列表。</div><div class="line">    if(check &amp;&amp; ret &gt; 0)</div><div class="line">        panic("syscall %d returned %d (&gt; 0)", num, ret);</div><div class="line"></div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以在写底层<code>OS</code>的实现的时候，也一定要注意到这么一点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_SYSCALL:</div><div class="line">    <span class="keyword">if</span> (tf-&gt;tf_regs.reg_eax &gt;= NSYSCALLS) <span class="keyword">return</span> -E_INVAL;</div><div class="line">    tf-&gt;tf_regs.reg_eax = syscall(</div><div class="line">        tf-&gt;tf_regs.reg_eax,</div><div class="line">        tf-&gt;tf_regs.reg_edx,</div><div class="line">        tf-&gt;tf_regs.reg_ecx,</div><div class="line">        tf-&gt;tf_regs.reg_ebx,</div><div class="line">        tf-&gt;tf_regs.reg_edi,</div><div class="line">        tf-&gt;tf_regs.reg_esi</div><div class="line">    );</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>系统要实现的系统调用也没有太多。也就是<code>enum</code>那里列出来的那几个。所以在实现的时候，只需要通过<br><code>case</code>语句把系统调用引导过去就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></div><div class="line"><span class="keyword">int32_t</span></div><div class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></div><div class="line">    <span class="comment">// Return any appropriate return value.</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    <span class="keyword">switch</span> (syscallno) &#123;</div><div class="line">        <span class="keyword">case</span> SYS_cputs:</div><div class="line">            sys_cputs((<span class="keyword">char</span>*)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">        <span class="keyword">case</span> SYS_cgetc:</div><div class="line">            <span class="keyword">return</span> sys_cgetc();</div><div class="line">        <span class="keyword">case</span> SYS_getenvid:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_getenvid();</div><div class="line">        <span class="keyword">case</span> SYS_env_destroy:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_env_destroy(sys_getenvid());</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="内存的检测"><a href="#内存的检测" class="headerlink" title="内存的检测"></a>内存的检测</h2><p>接下来就会看到<code>SYS_cputs</code>函数里面是需要检查一下用户权限是否可以访问内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Print a string to the system console.</span></div><div class="line"><span class="comment">// The string is exactly 'len' characters long.</span></div><div class="line"><span class="comment">// Destroys the environment on memory errors.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></div><div class="line">    <span class="comment">// Destroy the environment if not.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_assert(curenv, s, len, PTE_P|PTE_U);</div><div class="line">    <span class="comment">// Print the string supplied by the user.</span></div><div class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这里<code>user_mem_assert</code>是需要在<code>kern/pmap.c</code>里面去实现的。代码跳转过去，会发现代码里<br>需要实现的是<code>user_mem_check()</code>。</p>
<p>首先给出一种低效的版本，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int</div><div class="line">user_mem_check(struct Env *env, const void *va, size_t len, int perm)</div><div class="line">&#123;</div><div class="line">    // LAB 3: Your code here.</div><div class="line">    // LAB 3: DONE</div><div class="line">    user_mem_check_addr = 0;</div><div class="line">    for (const void *b = va; (b - va) &lt; len; b++) &#123;</div><div class="line">        user_mem_check_addr = (size_t)b &lt; ULIM ? 0 : (size_t)b;</div><div class="line">        if (!user_mem_check_addr) &#123;</div><div class="line">            pte_t *pte = pgdir_walk(env-&gt;env_pgdir, b, 0);</div><div class="line">            if (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (size_t)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (user_mem_check_addr) return -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，为了防止溢出，在条件判断的时候，最好是使用<code>b-va &lt; len</code>这种格式。<br>这个处理实际上是比较简单粗爆的。每个内存地址都需要依次检查一下。<br>假设要检查的地址是<code>10 ~ 4097</code>。在检查完地址<code>10</code>之后。实际上是可以跳到下<br>一个页面大小对齐的地址上去的。也就是4096。这里处理起来非常简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">b = 当前地址</div><div class="line">// 要找到下一个页面对齐的地址</div><div class="line">b = ROUNDDOWN(b, PGSIZE) + PGSIZE</div></pre></td></tr></table></figure>
<p>那么代码就可以很容易地精简如下了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_check_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">void</span> *b = va; (b - va) &lt; len; b += PGSIZE) &#123;</div><div class="line">        <span class="comment">// 注意在这里检查一下内存地址的有效性</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">size_t</span>)b &lt; ULIM ? <span class="number">0</span> : (<span class="keyword">size_t</span>)b;</div><div class="line">        <span class="keyword">if</span> (!user_mem_check_addr) &#123;</div><div class="line">            <span class="keyword">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, b, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (<span class="keyword">size_t</span>)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (user_mem_check_addr) <span class="keyword">return</span> -E_FAULT;</div><div class="line">        b = ROUNDDOWN(b, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2018/04/19/mit.6.828/jos-lab2/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">MIT 6.828 Lab2</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab3" data-title="MIT 6.828 Lab3" data-url="https://jiyou.github.io/blog/blog/2018/04/28/mit.6.828/jos-lab3/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>