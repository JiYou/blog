<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>1.4 ObjectStore的接口 | 缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="标志位// Flag bitstypedef uint32_t osflagbits_t;const int SKIP_JOURNAL_REPLAY = 1 &amp;lt;&amp;lt; 0;const int SKIP_MOUNT_OMAP = 1 &amp;lt;&amp;lt; 1;
这里主要是工程意义上的写法比较有意思，比如要设置第x位，就1&amp;lt;&amp;lt;x。
成员以及函数以下部分都是ObjectStore的成员或">
<meta property="og:type" content="article">
<meta property="og:title" content="1.4 ObjectStore的接口">
<meta property="og:url" content="https://jiyou.github.io/blog/2018/07/31/ceph/5.ObjectStore的接口/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="标志位// Flag bitstypedef uint32_t osflagbits_t;const int SKIP_JOURNAL_REPLAY = 1 &amp;lt;&amp;lt; 0;const int SKIP_MOUNT_OMAP = 1 &amp;lt;&amp;lt; 1;
这里主要是工程意义上的写法比较有意思，比如要设置第x位，就1&amp;lt;&amp;lt;x。
成员以及函数以下部分都是ObjectStore的成员或">
<meta property="og:updated_time" content="2018-08-03T03:06:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="1.4 ObjectStore的接口">
<meta name="twitter:description" content="标志位// Flag bitstypedef uint32_t osflagbits_t;const int SKIP_JOURNAL_REPLAY = 1 &amp;lt;&amp;lt; 0;const int SKIP_MOUNT_OMAP = 1 &amp;lt;&amp;lt; 1;
这里主要是工程意义上的写法比较有意思，比如要设置第x位，就1&amp;lt;&amp;lt;x。
成员以及函数以下部分都是ObjectStore的成员或">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/stl">stl</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/ceph/" style="font-size: 16.67px;">ceph</a> <a href="/blog/tags/leetcode/" style="font-size: 13.33px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/stl/" style="font-size: 20px;">stl</a> <a href="/blog/tags/算法/" style="font-size: 13.33px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JiYou">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">code</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/stl">stl</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-ceph/5.ObjectStore的接口" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/31/ceph/5.ObjectStore的接口/" class="article-date">
  	<time datetime="2018-07-31T05:28:32.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      1.4 ObjectStore的接口
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Flag bits</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">osflagbits_t</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SKIP_JOURNAL_REPLAY = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> SKIP_MOUNT_OMAP = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这里主要是工程意义上的写法比较有意思，比如要设置第<code>x</code>位，就<br><code>1&lt;&lt;x</code>。</p>
<h1 id="成员以及函数"><a href="#成员以及函数" class="headerlink" title="成员以及函数"></a>成员以及函数</h1><p>以下部分都是<code>ObjectStore</code>的成员或者成员函数。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p><code>ObjectStore</code>上下文以及路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ObjectStore的路径</span></div><div class="line"><span class="built_in">string</span> path;</div><div class="line">CephContext* cct;</div></pre></td></tr></table></figure>
<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>好像很多抽象类在有很多派生类的时候，都很喜欢用这种<code>create</code>工厂方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * create - create an ObjectStore instance.</div><div class="line"> *</div><div class="line"> * This is invoked once at initialization time.</div><div class="line"> *</div><div class="line"> * @param type type of store. This is a string from the configuration file.</div><div class="line"> * @param data path (or other descriptor) for data</div><div class="line"> * @param journal path (or other descriptor) for journal (optional)</div><div class="line"> * @param flags which filestores should check if applicable</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ObjectStore *<span class="title">create</span><span class="params">(CephContext *cct,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; type,</div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; data,</div><div class="line">                           <span class="keyword">const</span> <span class="built_in">string</span>&amp; journal,</div><div class="line">                           <span class="keyword">osflagbits_t</span> flags = <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>可以看到，这里需要指定：</p>
<ul>
<li>需要的<code>ObjectStore</code>的类型</li>
<li>需要的<code>ObjectStore</code>的数据区</li>
<li><code>ObjectStore</code>的日志区</li>
<li><code>ObjectStore</code>的标志位</li>
</ul>
<p>这里的标志位主要是两个：</p>
<ol>
<li>是否需要<code>journal</code>重放</li>
<li>是否需要<code>mount omap</code></li>
</ol>
<p>注意看前面给出的两个<code>SKIP_</code>标志位。</p>
<h2 id="读取fsid"><a href="#读取fsid" class="headerlink" title="读取fsid"></a>读取fsid</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * probe a block device to learn the uuid of the owning OSD</div><div class="line"> *</div><div class="line"> * @param cct cct</div><div class="line"> * @param path path to device</div><div class="line"> * @param fsid [out] osd uuid</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">probe_block_device_fsid</span><span class="params">(</span></span></div><div class="line">    CephContext *cct,</div><div class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path,</div><div class="line">    uuid_d *fsid);</div></pre></td></tr></table></figure>
<p>这里是用来读取<code>ObjectStore</code>的<code>fsid</code>，也就是看一下属于哪个cluster。<br>不同的<code>ObjectStore</code>的实现是不一样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> ObjectStore::probe_block_device_fsid(</div><div class="line">    CephContext *cct,</div><div class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; path,</div><div class="line">    uuid_d *fsid)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WITH_BLUESTORE)</span></div><div class="line">    <span class="comment">// first try bluestore -- it has a crc on its header and will fail</span></div><div class="line">    <span class="comment">// reliably.</span></div><div class="line">    r = BlueStore::get_block_device_fsid(cct, path, fsid);</div><div class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">        lgeneric_dout(cct, <span class="number">0</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">" "</span> &lt;&lt; path &lt;&lt; <span class="string">" is bluestore, "</span></div><div class="line">                              &lt;&lt; *fsid &lt;&lt; dendl;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// okay, try FileStore (journal).</span></div><div class="line">    r = FileStore::get_block_device_fsid(cct, path, fsid);</div><div class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">        lgeneric_dout(cct, <span class="number">0</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">" "</span> &lt;&lt; path &lt;&lt; <span class="string">" is filestore, "</span></div><div class="line">                              &lt;&lt; *fsid &lt;&lt; dendl;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> -EINVAL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码的设计上来，实际上最好是把各种代码，分散到自己的实现里面。而不是在这里通过<code>if else</code>来调用。这里稍微通过<code>FileStore</code>展开一下。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">int FileStore::get_block_device_fsid(CephContext* cct, const string&amp; path,</div><div class="line">                                     uuid_d *fsid)</div><div class="line">&#123;</div><div class="line">    // make sure we don't try to use aio or direct_io (and get annoying</div><div class="line">    // error messages from failing to do so); performance implications</div><div class="line">    // should be irrelevant for this use</div><div class="line">    FileJournal j(cct, *fsid, 0, 0, path.c_str(), false, false);</div><div class="line">    return j.peek_fsid(*fsid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// This can not be used on an active journal</div><div class="line">int FileJournal::peek_fsid(uuid_d&amp; fsid)</div><div class="line">&#123;</div><div class="line">    assert(fd == -1);</div><div class="line">    int r = _open(false, false);</div><div class="line">    if (r)</div><div class="line">        return r;</div><div class="line">    r = read_header(&amp;header);</div><div class="line">    if (r &lt; 0)</div><div class="line">        goto out;</div><div class="line">    fsid = header.fsid;</div><div class="line">out:</div><div class="line">    close();</div><div class="line">    return r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出这段代码实际上就是打开<code>journal</code>，然后读取<code>journal</code>的头部，从头部中拿到<code>journal</code>的<code>header</code>信息，然后再取出其中的<code>fsid</code>。</p>
<h2 id="获取ObjectStore的性能数据"><a href="#获取ObjectStore的性能数据" class="headerlink" title="获取ObjectStore的性能数据"></a>获取ObjectStore的性能数据</h2><p>通过注释可以看出，这里主要是获取<code>ObjectStore</code>的<code>commit/apply</code>的latency信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Fetch Object Store statistics.</div><div class="line"> *</div><div class="line"> * Currently only latency of write and apply times are measured.</div><div class="line"> *</div><div class="line"> * This appears to be called with nothing locked.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">virtual</span> objectstore_perf_stat_t <span class="title">get_cur_stats</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>那么这里可以展开<code>get_cur_stats</code>看一下<code>FileStore.h</code>是如何处理的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> FSPerfTracker &#123;</div><div class="line">    PerfCounters::avg_tracker&lt;<span class="keyword">uint64_t</span>&gt; os_commit_latency_ns;</div><div class="line">    PerfCounters::avg_tracker&lt;<span class="keyword">uint64_t</span>&gt; os_apply_latency_ns;</div><div class="line"></div><div class="line">    <span class="keyword">objectstore_perf_stat_t</span> get_cur_stats() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">objectstore_perf_stat_t</span> ret;</div><div class="line">        ret.os_commit_latency_ns = os_commit_latency_ns.current_avg();</div><div class="line">        ret.os_apply_latency_ns = os_apply_latency_ns.current_avg();</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_from_perfcounters</span><span class="params">(PerfCounters &amp;logger)</span></span>;</div><div class="line">&#125; perf_tracker;</div><div class="line"></div><div class="line"><span class="keyword">objectstore_perf_stat_t</span> get_cur_stats() override &#123;</div><div class="line">    perf_tracker.update_from_perfcounters(*logger);</div><div class="line">    <span class="keyword">return</span> perf_tracker.get_cur_stats();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出来，这里更新的变量主要是：</p>
<ul>
<li>os_commit_latency_ns</li>
<li>os_apply_latency_ns</li>
</ul>
<h2 id="拿到性能计数器"><a href="#拿到性能计数器" class="headerlink" title="拿到性能计数器"></a>拿到性能计数器</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Fetch Object Store performance counters.</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * This appears to be called with nothing locked.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> PerfCounters* <span class="title">get_perf_counters</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这里大部分子类，如果存在性能计数器，那么基本上都是一句话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> PerfCounters* <span class="title">get_perf_counters</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123;</div><div class="line">    <span class="keyword">return</span> logger;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Ceph在通常情况下认为事务之间是没有相关性的，也就是说<code>事务A</code>与<code>事务B</code>可以用任何顺序来进行提交。那么如果是用户对于某些事务有先后顺序的要求呢？</p>
<p>比如一定要<code>事务A， 事务B，事务C</code>，这个时候就需要利用<code>Collection</code>把<code>A,B,C</code>排好序并且放在一起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个collection里面包含的是一系列有先后顺序的事务</div><div class="line"> * 在同一个collection里面的事务队列，在apply的时候，必面根据先后顺序一个一个来。</div><div class="line"> * 在不同collection的事务是可以并行提交的。</div><div class="line"> *</div><div class="line"> * ObjectStore users可以得到collection的指针，通过两种方式</div><div class="line"> * - open_collection()</div><div class="line"> * - create_new_collection()</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> CollectionImpl : <span class="keyword">public</span> RefCountedObject &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">coll_t</span> cid;</div><div class="line"></div><div class="line">    CollectionImpl(<span class="keyword">const</span> <span class="keyword">coll_t</span>&amp; c)</div><div class="line">        : RefCountedObject(<span class="literal">NULL</span>, <span class="number">0</span>),</div><div class="line">          cid(c) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/// wait for any queued transactions to apply</span></div><div class="line">    <span class="comment">// block until any previous transactions are visible.  specifically,</span></div><div class="line">    <span class="comment">// collection_list and collection_empty need to reflect prior operations.</span></div><div class="line">    <span class="comment">// flush函数的作用就是一个一个地apply transactions</span></div><div class="line">    <span class="comment">// 必须要等到前面的事务都生效之后，后面的事务才可以推进。</span></div><div class="line">    <span class="comment">// collection_list()和collection_empty()这两个函数</span></div><div class="line">    <span class="comment">// 需要反映之前的操作。</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>= <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p><strong>问题</strong>暂时不去管这个<code>collection_list</code>和<code>collection_empty</code>这两个函数的具体作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Async flush_commit</div><div class="line">     * 这个是异步flush commit</div><div class="line">     * 两种情况：</div><div class="line">     * 1. collection当前是空闲的，flush_commit返回true</div><div class="line">     *    c不动</div><div class="line">     * 2. collection并不空闲，这个方法返回false并且c会被异步调用.</div><div class="line">     *    一旦这个collection里面所有的事务都先于flush_commit函数applied/commited了</div><div class="line">     *    那么一个0值就会返回</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">flush_commit</span><span class="params">(Context *c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">const</span> coll_t &amp;<span class="title">get_cid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cid; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 定义Collection的句柄</span></div><div class="line"><span class="keyword">typedef</span> boost::intrusive_ptr&lt;CollectionImpl&gt; CollectionHandle;</div></pre></td></tr></table></figure>
<h2 id="Object的内容与语义"><a href="#Object的内容与语义" class="headerlink" title="Object的内容与语义"></a>Object的内容与语义</h2><p>所有<code>ObjectStore</code>里面的<code>objects</code>都是唯一的，无论是<code>ghobject_t和hobject_t</code>。<br><code>ObjectStore</code>的操作支持<code>创建，修改，删除，罗列</code>collection中的<code>objects</code>。</p>
<p>但是这里的<code>罗列</code>是根据<code>object key</code>来进行排列的。所有的<code>object name</code>在整个<code>Ceph</code>系统里面<br>都是唯一的。</p>
<p>每个<code>object</code>都会有三个离散的三个部分：</p>
<ul>
<li>数据</li>
<li>xattrs</li>
<li>omap_header</li>
<li>omap_entries</li>
</ul>
<p>关于<code>Omap</code>可以看一下这个链表：<a href="http://bean-li.github.io/ceph-omap/" target="_blank" rel="external">http://bean-li.github.io/ceph-omap/</a></p>
<p>简单地概述一下就是。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">FileStore的omap中存放的都是对象的属性信息，以key-value的形式存在，那么对于不同的属性，如何定义对象的键值key呢？</div><div class="line"></div><div class="line">最直接的想法就是（object_id + xattr_key），两者结合一起，形成对象的键值key，但是这种方法有一个问题，object_id可能会很长，尤其是当单个对象存在很多属性的时候，object_id不得不在key值中出现多次，这必然会造成存储空间的浪费。</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">Ceph的FileStore分成了<span class="number">2</span>步：</div><div class="line"></div><div class="line">第一步: 根据object_id生成一个比较短的seq，然后把这个seq存放到omap_header中。</div><div class="line">第二步: 然后seq + xattr_key形成对象的某个属性的键值。</div></pre></td></tr></table></figure>
<h3 id="如何生成seq"><a href="#如何生成seq" class="headerlink" title="如何生成seq"></a>如何生成seq</h3><p>如果是<code>LevelDB</code>来实现<code>Omap</code>的话，那么就是在<code>LevelDB</code>中存储一个<code>OSD</code>当前全局的<code>key</code>值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">key: SYS_PREFIX + GLOBAL_STATE_KEY</div><div class="line">value: state</div></pre></td></tr></table></figure>
<p>要申请<code>seq</code>的时候，针对这个<code>seq</code>上锁然后递增。<code>seq</code>是放在<code>state</code>里面的。<code>state</code>的内容就存放到<code>LevelDB</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> State &#123;</div><div class="line">    <span class="number">__u</span>8 v;</div><div class="line">    <span class="keyword">uint64_t</span> seq;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="object-id到seq"><a href="#object-id到seq" class="headerlink" title="object_id到seq"></a>object_id到seq</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">_</span>Header &#123;</div><div class="line">    <span class="keyword">uint64_t</span> seq;</div><div class="line">    <span class="keyword">uint64_t</span> parent;</div><div class="line">    <span class="keyword">uint64_t</span> num_children;</div><div class="line">    <span class="keyword">coll_t</span> c;</div><div class="line">    <span class="keyword">ghobject_t</span> oid; </div><div class="line">    SequencerPosition spos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当生成<code>seq</code>之后，立即生成一个<code>header</code>结构。然后把这个<code>header</code>存放到<code>LevelDB</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">key： HOBJECT_TO_SEQ + ghobject_key(oid)</div><div class="line">value: header</div></pre></td></tr></table></figure>
<h3 id="Object的data"><a href="#Object的data" class="headerlink" title="Object的data"></a>Object的data</h3><p>object的数据部分理念上是等价于一个文件系统里面的文件。对于object的随机和部分读写都要可以进行。对于数据部分的稀疏处理并不是一个强需求。一般而言，单个object不要太大，大的话一般100MB左右。</p>
<h3 id="Object的xattrs"><a href="#Object的xattrs" class="headerlink" title="Object的xattrs"></a>Object的xattrs</h3><p>xattrs主要是存放在文件系统的attrs上。而omap一般则是存放在<code>leveldb</code>上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*********************************</span></div><div class="line"> * 事务</div><div class="line"> *</div><div class="line"> * 一个事务包含了一系列修改操作。</div><div class="line"> *</div><div class="line"> * 一个事务的三个事件会导致回调。任何一个事务都会带如下的</div><div class="line"> * 回调函数。</div><div class="line"> *</div><div class="line"> *    on_applied_sync, on_applied, and on_commit.</div><div class="line"> *</div><div class="line"> * `on_applied`和`on_applied_sync`这两个回调都是在修改正式生效之后才会被触发。所谓的修改生效就是指修改被后面的操作可见。</div><div class="line"> *</div><div class="line"> * 唯一理论上的差异`on_applied`和`on_applied_sync`是在于callback发生的操作线程以及锁环境。`on_applied_sync`语意上就是说直接会被执行线程触发，往往是在急着要执行，并且在当前的环境下不能持有锁的调用环境。(去申请锁可能会导致wait也就是等待)</div><div class="line"> * 相反地`on_applied`则是另外一个Finisher线程来调用的。这也就是意味着调用环境满足去申请锁的各种条件(这里主要是指申请的时候可以wait)。</div><div class="line"> * 需要注意的是：on_applied和on_applied_sync有时候也会被叫做on_readable和on_readable_sync。</div><div class="line"> *</div><div class="line"> * on_commit回调则肯定是由另外一个Finisher线程来调用的。并且所有的修改操作已经写到journal上。也就是持久化了。</div><div class="line"> *</div><div class="line"> * 就从journal写日志的实现上来说，每次原始的修改（包含相关的数据）都可以被串行化到一个单一的buffer里面。这个串行化并不会拷贝任何数据本身，而是直接引用到原有的数据。这样一来，就需要原有的数据保持不变，直接on_commit回调函数成功。在实践上，缓冲区处理所有的这种情况，主要是通过bufferlist::raw_static引用到相应的data缓冲区。</div><div class="line"> *</div><div class="line"> * 一些ObjectStore的实施选实施他们自己形式的journal并且利用串行化来实现一个事务。在这种情况下就需要保证encode/decode逻辑合理地处理好version,并且要处理好升级。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * TRANSACTION ISOLATION  事务独立性</div><div class="line"> *</div><div class="line"> * 事务的独立性是由于调用方来实施的。除此之外，独立性是指，</div><div class="line"> * object相关的四个部分被一个事务修改/删除的时候，调用方并不会说去读取这个object的相应元素，特别是当这个事务有可能被阻塞的情况下。这里阻塞指的是`one_applied_sync`回调被执行了。</div><div class="line"> * 对于这个规则的违反并不会被ObjectStore所监管到。并且也不会有相应的错误被raise出来。</div><div class="line"> * 简单地说就是事务与事务之间是相互独立的，事务之间的关系，需要调用者来加以保证。</div><div class="line"> * Except as noted above, isolation is the responsibility of the</div><div class="line"> * caller. In other words, if any storage element (storage element</div><div class="line"> * == any of the four portions of an object as described above) is</div><div class="line"> * altered by a transaction (including deletion), the caller</div><div class="line"> * promises not to attempt to read that element while the</div><div class="line"> * transaction is pending (here pending means from the time of</div><div class="line"> * issuance until the "on_applied_sync" callback has been</div><div class="line"> * received). Violations of isolation need not be detected by</div><div class="line"> * ObjectStore and there is no corresponding error mechanism for</div><div class="line"> * reporting an isolation violation (crashing would be the</div><div class="line"> * appropriate way to report an isolation violation if detected).</div><div class="line"> *</div><div class="line"> * Enumeration operations may violate transaction isolation as</div><div class="line"> * described above when a storage element is being created or</div><div class="line"> * deleted as part of a transaction. In this case, ObjectStore is</div><div class="line"> * allowed to consider the enumeration operation to either precede</div><div class="line"> * or follow the violating transaction element. In other words, the</div><div class="line"> * presence/absence of the mutated element in the enumeration is</div><div class="line"> * entirely at the discretion of ObjectStore. The arbitrary ordering</div><div class="line"> * applies independently to each transaction element. For example,</div><div class="line"> * if a transaction contains two mutating elements "create A" and</div><div class="line"> * "delete B". And an enumeration operation is performed while this</div><div class="line"> * transaction is pending. It is permissable for ObjectStore to</div><div class="line"> * report any of the four possible combinations of the existence of</div><div class="line"> * A and B.</div><div class="line"> *</div><div class="line"> */</div></pre></td></tr></table></figure>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight"><table><tr><td class="code"><pre><div class="line">class Transaction &#123;</div><div class="line">public:</div><div class="line">    // 这里有点类似于设计了一套指令。</div><div class="line">    enum &#123;</div><div class="line">        OP_NOP =          0,</div><div class="line">        OP_TOUCH =        9,   // cid, oid</div><div class="line">        OP_WRITE =        10,  // cid, oid, offset, len, bl</div><div class="line">        OP_ZERO =         11,  // cid, oid, offset, len</div><div class="line">        OP_TRUNCATE =     12,  // cid, oid, len</div><div class="line">        OP_REMOVE =       13,  // cid, oid</div><div class="line">        OP_SETATTR =      14,  // cid, oid, attrname, bl</div><div class="line">        OP_SETATTRS =     15,  // cid, oid, attrset</div><div class="line">        OP_RMATTR =       16,  // cid, oid, attrname</div><div class="line">        OP_CLONE =        17,  // cid, oid, newoid</div><div class="line">        OP_CLONERANGE =   18,  // cid, oid, newoid, offset, len</div><div class="line">        OP_CLONERANGE2 =  30,  // cid, oid, newoid, srcoff, len, dstoff</div><div class="line"></div><div class="line">        OP_TRIMCACHE =    19,  // cid, oid, offset, len  **DEPRECATED**</div><div class="line"></div><div class="line">        OP_MKCOLL =       20,  // cid</div><div class="line">        OP_RMCOLL =       21,  // cid</div><div class="line">        OP_COLL_ADD =     22,  // cid, oldcid, oid</div><div class="line">        OP_COLL_REMOVE =  23,  // cid, oid</div><div class="line">        OP_COLL_SETATTR = 24,  // cid, attrname, bl</div><div class="line">        OP_COLL_RMATTR =  25,  // cid, attrname</div><div class="line">        OP_COLL_SETATTRS = 26,  // cid, attrset</div><div class="line">        OP_COLL_MOVE =    8,   // newcid, oldcid, oid</div><div class="line"></div><div class="line">        OP_RMATTRS =      28,  // cid, oid</div><div class="line">        OP_COLL_RENAME =       29,  // cid, newcid</div><div class="line"></div><div class="line">        OP_OMAP_CLEAR = 31,   // cid</div><div class="line">        OP_OMAP_SETKEYS = 32, // cid, attrset</div><div class="line">        OP_OMAP_RMKEYS = 33,  // cid, keyset</div><div class="line">        OP_OMAP_SETHEADER = 34, // cid, header</div><div class="line">        OP_SPLIT_COLLECTION = 35, // cid, bits, destination</div><div class="line">        OP_SPLIT_COLLECTION2 = 36, /* cid, bits, destination</div><div class="line">    doesn't create the destination */</div><div class="line">        OP_OMAP_RMKEYRANGE = 37,  // cid, oid, firstkey, lastkey</div><div class="line">        OP_COLL_MOVE_RENAME = 38,   // oldcid, oldoid, newcid, newoid</div><div class="line"></div><div class="line">        OP_SETALLOCHINT = 39,  // cid, oid, object_size, write_size</div><div class="line">        OP_COLL_HINT = 40, // cid, type, bl</div><div class="line"></div><div class="line">        OP_TRY_RENAME = 41,   // oldcid, oldoid, newoid</div><div class="line"></div><div class="line">        OP_COLL_SET_BITS = 42, // cid, bits</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // Transaction hint type</div><div class="line">    enum &#123;</div><div class="line">        COLL_HINT_EXPECTED_NUM_OBJECTS = 1,</div><div class="line">    &#125;;</div><div class="line">    // 真正的操作</div><div class="line">    struct Op &#123;</div><div class="line">        __le32 op;  // 这里用数字来表示操作的类型，也可以看做是指令的类型</div><div class="line">        __le32 cid;</div><div class="line">        __le32 oid;</div><div class="line">        __le64 off;</div><div class="line">        __le64 len;</div><div class="line">        __le32 dest_cid;</div><div class="line">        __le32 dest_oid;                  //OP_CLONE, OP_CLONERANGE</div><div class="line">        __le64 dest_off;                  //OP_CLONERANGE</div><div class="line">        union &#123;</div><div class="line">            struct &#123;</div><div class="line">                __le32 hint_type;             //OP_COLL_HINT</div><div class="line">            &#125;;</div><div class="line">            struct &#123;</div><div class="line">                __le32 alloc_hint_flags;      //OP_SETALLOCHINT</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">        __le64 expected_object_size;      //OP_SETALLOCHINT</div><div class="line">        __le64 expected_write_size;       //OP_SETALLOCHINT</div><div class="line">        __le32 split_bits;                //OP_SPLIT_COLLECTION2,OP_COLL_SET_BITS,</div><div class="line">        //OP_MKCOLL</div><div class="line">        __le32 split_rem;                 //OP_SPLIT_COLLECTION2</div><div class="line">    &#125; __attribute__ ((packed)) ;</div><div class="line">    // </div><div class="line">    struct TransactionData &#123;</div><div class="line">        __le64 ops;  // 这个应该是指的操作的数量</div><div class="line">        __le32 largest_data_len;</div><div class="line">        __le32 largest_data_off;</div><div class="line">        __le32 largest_data_off_in_data_bl;</div><div class="line">        __le32 fadvise_flags;</div><div class="line">    &#125; __attribute__ ((packed)) ;</div><div class="line"></div><div class="line">private:</div><div class="line">    TransactionData data;</div><div class="line"></div><div class="line">    map&lt;coll_t, __le32&gt; coll_index;</div><div class="line">    map&lt;ghobject_t, __le32&gt; object_index;</div><div class="line"></div><div class="line">    __le32 coll_id &#123;0&#125;;</div><div class="line">    __le32 object_id &#123;0&#125;;</div><div class="line"></div><div class="line">    bufferlist data_bl;</div><div class="line">    bufferlist op_bl;</div><div class="line"></div><div class="line">    bufferptr op_ptr;</div><div class="line"></div><div class="line">    list&lt;Context *&gt; on_applied;</div><div class="line">    list&lt;Context *&gt; on_commit;</div><div class="line">    list&lt;Context *&gt; on_applied_sync;</div><div class="line"></div><div class="line">public:</div><div class="line">    void _update_op(Op* op,</div><div class="line">                    vector&lt;__le32&gt; &amp;cm,</div><div class="line">                    vector&lt;__le32&gt; &amp;om) &#123;</div><div class="line">        // 根据情况来决定是否需要更新collection id</div><div class="line">        // 或者是object id</div><div class="line">        // 根据op的类型来决定</div><div class="line">        op-&gt;cid = cm[op-&gt;cid];</div><div class="line">        op-&gt;oid = om[op-&gt;oid];</div><div class="line">        op-&gt;dest_oid = om[op-&gt;dest_oid];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // bl里面是一个list</div><div class="line">    // list里面的每个元素都是一个Op结构</div><div class="line">    // 然后再通过_update_op(op_memory, cm, om)</div><div class="line">    // 来进行更新</div><div class="line">    void _update_op_bl(</div><div class="line">        bufferlist&amp; bl,</div><div class="line">        vector&lt;__le32&gt; &amp;cm,</div><div class="line">        vector&lt;__le32&gt; &amp;om)</div><div class="line">    &#123;</div><div class="line">        list&lt;bufferptr&gt; list = bl.buffers();</div><div class="line">        std::list&lt;bufferptr&gt;::iterator p;</div><div class="line"></div><div class="line">        for(p = list.begin(); p != list.end(); ++p) &#123;</div><div class="line">            assert(p-&gt;length() % sizeof(Op) == 0);</div><div class="line">            char* raw_p = p-&gt;c_str();</div><div class="line">            char* raw_end = raw_p + p-&gt;length();</div><div class="line">            while (raw_p &lt; raw_end) &#123;</div><div class="line">                _update_op(reinterpret_cast&lt;Op*&gt;(raw_p), cm, om);</div><div class="line">                raw_p += sizeof(Op);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /// Append the operations of the parameter to this Transaction.</div><div class="line">    // Those operations are removed from the parameter Transaction</div><div class="line">    // 这里更加类似于两个事务的合并，注意：</div><div class="line">    // other.op_bl是深度复制了的。</div><div class="line">    // ohter.data_bl则是没有深度复制</div><div class="line">    // 可能是觉得other还会在别的地方会有用处</div><div class="line">    void append(Transaction&amp; other) &#123;</div><div class="line">        data.ops += other.data.ops;</div><div class="line">        if (other.data.largest_data_len &gt; data.largest_data_len) &#123;</div><div class="line">            data.largest_data_len = other.data.largest_data_len;</div><div class="line">            data.largest_data_off = other.data.largest_data_off;</div><div class="line">            data.largest_data_off_in_data_bl = data_bl.length() + other.data.largest_data_off_in_data_bl;</div><div class="line">        &#125;</div><div class="line">        data.fadvise_flags |= other.data.fadvise_flags;</div><div class="line">        // splice的含义是把另外一个list放到on_applied/on_commit后面</div><div class="line">        // splice函数是说</div><div class="line">        // splice(Iterator position, list&lt;T&gt; l);</div><div class="line">        // 把l插入到postion位置。然后l里面的元素被move过去。所以</div><div class="line">        // 操作之后l变成空的了。</div><div class="line">        on_applied.splice(on_applied.end(), other.on_applied);</div><div class="line">        on_commit.splice(on_commit.end(), other.on_commit);</div><div class="line">        on_applied_sync.splice(on_applied_sync.end(), other.on_applied_sync);</div><div class="line"></div><div class="line">        //append coll_index &amp; object_index</div><div class="line">        // cm新生成，后面用来更新</div><div class="line">        vector&lt;__le32&gt; cm(other.coll_index.size());</div><div class="line">        map&lt;coll_t, __le32&gt;::iterator coll_index_p;</div><div class="line">        for (coll_index_p = other.coll_index.begin();</div><div class="line">             coll_index_p != other.coll_index.end();</div><div class="line">             ++coll_index_p) &#123;</div><div class="line">            // 这里更新cm这个vector</div><div class="line">            cm[coll_index_p-&gt;second] = _get_coll_id(coll_index_p-&gt;first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        vector&lt;__le32&gt; om(other.object_index.size());</div><div class="line">        map&lt;ghobject_t, __le32&gt;::iterator object_index_p;</div><div class="line">        for (object_index_p = other.object_index.begin();</div><div class="line">             object_index_p != other.object_index.end();</div><div class="line">             ++object_index_p) &#123;</div><div class="line">            // 这里更新的是om这个vector</div><div class="line">            om[object_index_p-&gt;second] = _get_object_id(object_index_p-&gt;first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // other.op_bl在这里是不能被更改的</div><div class="line">        //the other.op_bl SHOULD NOT be changes during append operation,</div><div class="line">        // 这里使用了另外一个bufferlist来处理这种case. </div><div class="line">        //we use additional bufferlist to avoid this problem</div><div class="line">        // 申请一个新的内存，长度为other.op_bl.length()</div><div class="line">        bufferptr other_op_bl_ptr(other.op_bl.length());</div><div class="line">        // 这里把other.op_bl里面的内容复制到新申请的内存里</div><div class="line">        other.op_bl.copy(0, other.op_bl.length(), other_op_bl_ptr.c_str());</div><div class="line">        bufferlist other_op_bl;</div><div class="line">        // 注意这里是一个list&lt;bufferptr&gt;, 所以这里用append把前面的内存缓冲区放进去</div><div class="line">        other_op_bl.append(other_op_bl_ptr);</div><div class="line"></div><div class="line">        //update other_op_bl with cm &amp; om</div><div class="line">        //When the other is appended to current transaction, all coll_index and</div><div class="line">        //object_index in other.op_buffer should be updated by new index of the</div><div class="line">        //combined transaction</div><div class="line">        // 然后利用list&lt;buffer&gt;把当前的transaction更新一把</div><div class="line">        _update_op_bl(other_op_bl, cm, om);</div><div class="line"></div><div class="line">        //append op_bl</div><div class="line">        // 把other的op_bl list append到op_bl里面</div><div class="line">        // 完成两个事务的op的合并</div><div class="line">        op_bl.append(other_op_bl);</div><div class="line">        //append data_bl</div><div class="line">        // data bl也是需要合并</div><div class="line">        data_bl.append(other.data_bl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Inquires about the Transaction as a whole. */</div><div class="line"></div><div class="line">    /// How big is the encoded Transaction buffer?</div><div class="line">    // 得到整个事务的长度</div><div class="line">    // 感觉这里不应该老是去计算</div><div class="line">    // 最好是有办法去优化</div><div class="line">    uint64_t get_encoded_bytes() &#123;</div><div class="line">        //layout: data_bl + op_bl + coll_index + object_index + data</div><div class="line"></div><div class="line">        // coll_index size, object_index size and sizeof(transaction_data)</div><div class="line">        // all here, so they may be computed at compile-time</div><div class="line">        size_t final_size = sizeof(__u32) * 2 + sizeof(data);</div><div class="line"></div><div class="line">        // coll_index second and object_index second</div><div class="line">        final_size += (coll_index.size() + object_index.size()) * sizeof(__le32);</div><div class="line"></div><div class="line">        // coll_index first</div><div class="line">        for (auto p = coll_index.begin(); p != coll_index.end(); ++p) &#123;</div><div class="line">            final_size += p-&gt;first.encoded_size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // object_index first</div><div class="line">        for (auto p = object_index.begin(); p != object_index.end(); ++p) &#123;</div><div class="line">            final_size += p-&gt;first.encoded_size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return data_bl.length() +</div><div class="line">               op_bl.length() +</div><div class="line">               final_size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    uint64_t get_num_bytes() &#123;</div><div class="line">        return get_encoded_bytes();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Size of largest data buffer to the "write" operation encountered so far</div><div class="line">    uint32_t get_data_length() &#123;</div><div class="line">        return data.largest_data_len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// offset within the encoded buffer to the start of the largest data buffer that's encoded</div><div class="line">    uint32_t get_data_offset()</div><div class="line">    &#123;</div><div class="line">        if (data.largest_data_off_in_data_bl) &#123;</div><div class="line">            return data.largest_data_off_in_data_bl +</div><div class="line">                   sizeof(__u8) +      // encode struct_v</div><div class="line">                   sizeof(__u8) +      // encode compat_v</div><div class="line">                   sizeof(__u32) +     // encode len</div><div class="line">                   sizeof(__u32);      // data_bl len</div><div class="line">        &#125;</div><div class="line">        return 0;  // none</div><div class="line">    &#125;</div><div class="line">    /// offset of buffer as aligned to destination within object.</div><div class="line">    int get_data_alignment()</div><div class="line">    &#123;</div><div class="line">        if (!data.largest_data_len)</div><div class="line">            return 0;</div><div class="line">        return (0 - get_data_offset()) &amp; ~CEPH_PAGE_MASK;</div><div class="line">    &#125;</div><div class="line">    /// Is the Transaction empty (no operations)</div><div class="line">    bool empty()</div><div class="line">    &#123;</div><div class="line">        // data里面的ops就是用来计数ops操作的数目</div><div class="line">        return !data.ops;</div><div class="line">    &#125;</div><div class="line">    /// Number of operations in the transation</div><div class="line">    int get_num_ops()</div><div class="line">    &#123;</div><div class="line">        return data.ops;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * iterator</div><div class="line">     *</div><div class="line">     * Helper object to parse Transactions.</div><div class="line">     *</div><div class="line">     * ObjectStore instances use this object to step down the encoded</div><div class="line">     * buffer decoding operation codes and parameters as we go.</div><div class="line">     *</div><div class="line">     */</div><div class="line">    class iterator</div><div class="line">    &#123;</div><div class="line">        Transaction *t;</div><div class="line"></div><div class="line">        uint64_t ops;</div><div class="line">        char* op_buffer_p;</div><div class="line"></div><div class="line">        bufferlist::const_iterator data_bl_p;</div><div class="line"></div><div class="line">    public:</div><div class="line">        vector&lt;coll_t&gt; colls;</div><div class="line">        vector&lt;ghobject_t&gt; objects;</div><div class="line"></div><div class="line">    private:</div><div class="line">        explicit iterator(Transaction *t)</div><div class="line">            : t(t),</div><div class="line">              data_bl_p(t-&gt;data_bl.cbegin()),</div><div class="line">              colls(t-&gt;coll_index.size()),</div><div class="line">              objects(t-&gt;object_index.size())</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            ops = t-&gt;data.ops;</div><div class="line">            op_buffer_p = t-&gt;op_bl.get_contiguous(0, t-&gt;data.ops * sizeof(Op));</div><div class="line"></div><div class="line">            map&lt;coll_t, __le32&gt;::iterator coll_index_p;</div><div class="line">            for (coll_index_p = t-&gt;coll_index.begin();</div><div class="line">                 coll_index_p != t-&gt;coll_index.end();</div><div class="line">                 ++coll_index_p) &#123;</div><div class="line">                colls[coll_index_p-&gt;second] = coll_index_p-&gt;first;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            map&lt;ghobject_t, __le32&gt;::iterator object_index_p;</div><div class="line">            for (object_index_p = t-&gt;object_index.begin();</div><div class="line">                 object_index_p != t-&gt;object_index.end();</div><div class="line">                 ++object_index_p) &#123;</div><div class="line">                objects[object_index_p-&gt;second] = object_index_p-&gt;first;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        friend class Transaction;</div><div class="line"></div><div class="line">    public:</div><div class="line"></div><div class="line">        bool have_op()</div><div class="line">        &#123;</div><div class="line">            return ops &gt; 0;</div><div class="line">        &#125;</div><div class="line">        Op* decode_op()</div><div class="line">        &#123;</div><div class="line">            assert(ops &gt; 0);</div><div class="line"></div><div class="line">            Op* op = reinterpret_cast&lt;Op*&gt;(op_buffer_p);</div><div class="line">            op_buffer_p += sizeof(Op);</div><div class="line">            ops--;</div><div class="line"></div><div class="line">            return op;</div><div class="line">        &#125;</div><div class="line">        string decode_string()</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            string s;</div><div class="line">            decode(s, data_bl_p);</div><div class="line">            return s;</div><div class="line">        &#125;</div><div class="line">        void decode_bp(bufferptr&amp; bp)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(bp, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_bl(bufferlist&amp; bl)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(bl, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset(map&lt;string,bufferptr&gt;&amp; aset)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(aset, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset(map&lt;string,bufferlist&gt;&amp; aset)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(aset, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_attrset_bl(bufferlist *pbl)</div><div class="line">        &#123;</div><div class="line">            decode_str_str_map_to_bl(data_bl_p, pbl);</div><div class="line">        &#125;</div><div class="line">        void decode_keyset(set&lt;string&gt; &amp;keys)</div><div class="line">        &#123;</div><div class="line">            using ceph::decode;</div><div class="line">            decode(keys, data_bl_p);</div><div class="line">        &#125;</div><div class="line">        void decode_keyset_bl(bufferlist *pbl)</div><div class="line">        &#123;</div><div class="line">            decode_str_set_to_bl(data_bl_p, pbl);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        const ghobject_t &amp;get_oid(__le32 oid_id)</div><div class="line">        &#123;</div><div class="line">            assert(oid_id &lt; objects.size());</div><div class="line">            return objects[oid_id];</div><div class="line">        &#125;</div><div class="line">        const coll_t &amp;get_cid(__le32 cid_id)</div><div class="line">        &#123;</div><div class="line">            assert(cid_id &lt; colls.size());</div><div class="line">            return colls[cid_id];</div><div class="line">        &#125;</div><div class="line">        uint32_t get_fadvise_flags() const</div><div class="line">        &#123;</div><div class="line">            return t-&gt;get_fadvise_flags();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    iterator begin()</div><div class="line">    &#123;</div><div class="line">        return iterator(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    void _build_actions_from_tbl();</div><div class="line"> </div><div class="line">    /**</div><div class="line">     * Helper functions to encode the various mutation elements of a</div><div class="line">     * transaction.  These are 1:1 with the operation codes (see</div><div class="line">     * enumeration above).  These routines ensure that the</div><div class="line">     * encoder/creator of a transaction gets the right data in the</div><div class="line">     * right place. Sadly, there's no corresponding version nor any</div><div class="line">     * form of seat belts for the decoder.</div><div class="line">     */</div><div class="line">    Op* _get_next_op()</div><div class="line">    &#123;</div><div class="line">        if (op_ptr.length() == 0 || op_ptr.offset() &gt;= op_ptr.length()) &#123;</div><div class="line">            op_ptr = bufferptr(sizeof(Op) * OPS_PER_PTR);</div><div class="line">        &#125;</div><div class="line">        bufferptr ptr(op_ptr, 0, sizeof(Op));</div><div class="line">        op_bl.append(ptr);</div><div class="line"></div><div class="line">        op_ptr.set_offset(op_ptr.offset() + sizeof(Op));</div><div class="line"></div><div class="line">        char* p = ptr.c_str();</div><div class="line">        memset(p, 0, sizeof(Op));</div><div class="line">        return reinterpret_cast&lt;Op*&gt;(p);</div><div class="line">    &#125;</div><div class="line">    __le32 _get_coll_id(const coll_t&amp; coll)</div><div class="line">    &#123;</div><div class="line">        map&lt;coll_t, __le32&gt;::iterator c = coll_index.find(coll);</div><div class="line">        if (c != coll_index.end())</div><div class="line">            return c-&gt;second;</div><div class="line"></div><div class="line">        __le32 index_id = coll_id++;</div><div class="line">        coll_index[coll] = index_id;</div><div class="line">        return index_id;</div><div class="line">    &#125;</div><div class="line">    __le32 _get_object_id(const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        map&lt;ghobject_t, __le32&gt;::iterator o = object_index.find(oid);</div><div class="line">        if (o != object_index.end())</div><div class="line">            return o-&gt;second;</div><div class="line"></div><div class="line">        __le32 index_id = object_id++;</div><div class="line">        object_index[oid] = index_id;</div><div class="line">        return index_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">    // 接下来这里生成各种事务的参数，指令</div><div class="line">    /// noop. 'nuf said</div><div class="line">    void nop()</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_NOP;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * touch</div><div class="line">     *</div><div class="line">     * Ensure the existance of an object in a collection. Create an</div><div class="line">     * empty object if necessary</div><div class="line">     */</div><div class="line">    void touch(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TOUCH;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Write data to an offset within an object. If the object is too</div><div class="line">     * small, it is expanded as needed.  It is possible to specify an</div><div class="line">     * offset beyond the current end of an object and it will be</div><div class="line">     * expanded as needed. Simple implementations of ObjectStore will</div><div class="line">     * just zero the data between the old end of the object and the</div><div class="line">     * newly provided data. More sophisticated implementations of</div><div class="line">     * ObjectStore will omit the untouched data and store it as a</div><div class="line">     * "hole" in the file.</div><div class="line">     *</div><div class="line">     * Note that a 0-length write does not affect the size of the object.</div><div class="line">     */</div><div class="line">    void write(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off, uint64_t len,</div><div class="line">               const bufferlist&amp; write_data, uint32_t flags = 0)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        uint32_t orig_len = data_bl.length();</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_WRITE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        _op-&gt;len = len;</div><div class="line">        encode(write_data, data_bl);</div><div class="line"></div><div class="line">        assert(len == write_data.length());</div><div class="line">        data.fadvise_flags = data.fadvise_flags | flags;</div><div class="line">        if (write_data.length() &gt; data.largest_data_len) &#123;</div><div class="line">            data.largest_data_len = write_data.length();</div><div class="line">            data.largest_data_off = off;</div><div class="line">            data.largest_data_off_in_data_bl = orig_len + sizeof(__u32);  // we are about to</div><div class="line">        &#125;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * zero out the indicated byte range within an object. Some</div><div class="line">     * ObjectStore instances may optimize this to release the</div><div class="line">     * underlying storage space.</div><div class="line">     *</div><div class="line">     * If the zero range extends beyond the end of the object, the object</div><div class="line">     * size is extended, just as if we were writing a buffer full of zeros.</div><div class="line">     * EXCEPT if the length is 0, in which case (just like a 0-length write)</div><div class="line">     * we do not adjust the object size.</div><div class="line">     */</div><div class="line">    void zero(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off, uint64_t len)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_ZERO;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        _op-&gt;len = len;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Discard all data in the object beyond the specified size.</div><div class="line">    void truncate(const coll_t&amp; cid, const ghobject_t&amp; oid, uint64_t off)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TRUNCATE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;off = off;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Remove an object. All four parts of the object are removed.</div><div class="line">    void remove(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_REMOVE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set an xattr of an object</div><div class="line">    void setattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const char* name, bufferlist&amp; val)</div><div class="line">    &#123;</div><div class="line">        string n(name);</div><div class="line">        setattr(cid, oid, n, val);</div><div class="line">    &#125;</div><div class="line">    /// Set an xattr of an object</div><div class="line">    void setattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const string&amp; s, bufferlist&amp; val)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(s, data_bl);</div><div class="line">        encode(val, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set multiple xattrs of an object</div><div class="line">    void setattrs(const coll_t&amp; cid, const ghobject_t&amp; oid, const map&lt;string,bufferptr&gt;&amp; attrset)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set multiple xattrs of an object</div><div class="line">    void setattrs(const coll_t&amp; cid, const ghobject_t&amp; oid, const map&lt;string,bufferlist&gt;&amp; attrset)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// remove an xattr from an object</div><div class="line">    void rmattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const char *name)</div><div class="line">    &#123;</div><div class="line">        string n(name);</div><div class="line">        rmattr(cid, oid, n);</div><div class="line">    &#125;</div><div class="line">    /// remove an xattr from an object</div><div class="line">    void rmattr(const coll_t&amp; cid, const ghobject_t&amp; oid, const string&amp; s)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMATTR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(s, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// remove all xattrs from an object</div><div class="line">    void rmattrs(const coll_t&amp; cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMATTRS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Clone an object into another object.</div><div class="line">     *</div><div class="line">     * Low-cost (e.g., O(1)) cloning (if supported) is best, but</div><div class="line">     * fallback to an O(n) copy is allowed.  All four parts of the</div><div class="line">     * object are cloned (data, xattrs, omap header, omap</div><div class="line">     * entries).</div><div class="line">     *</div><div class="line">     * The destination named object may already exist, in</div><div class="line">     * which case its previous contents are discarded.</div><div class="line">     */</div><div class="line">    void clone(const coll_t&amp; cid, const ghobject_t&amp; oid,</div><div class="line">               const ghobject_t&amp; noid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_CLONE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(noid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * Clone a byte range from one object to another.</div><div class="line">     *</div><div class="line">     * The data portion of the destination object receives a copy of a</div><div class="line">     * portion of the data from the source object. None of the other</div><div class="line">     * three parts of an object is copied from the source.</div><div class="line">     *</div><div class="line">     * The destination object size may be extended to the dstoff + len.</div><div class="line">     *</div><div class="line">     * The source range *must* overlap with the source object data. If it does</div><div class="line">     * not the result is undefined.</div><div class="line">     */</div><div class="line">    void clone_range(const coll_t&amp; cid, const ghobject_t&amp; oid,</div><div class="line">                     const ghobject_t&amp; noid,</div><div class="line">                     uint64_t srcoff, uint64_t srclen, uint64_t dstoff)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_CLONERANGE2;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(noid);</div><div class="line">        _op-&gt;off = srcoff;</div><div class="line">        _op-&gt;len = srclen;</div><div class="line">        _op-&gt;dest_off = dstoff;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Create the collection</div><div class="line">    void create_collection(const coll_t&amp; cid, int bits)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_MKCOLL;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Give the collection a hint.</div><div class="line">     *</div><div class="line">     * @param cid  - collection id.</div><div class="line">     * @param type - hint type.</div><div class="line">     * @param hint - the hint payload, which contains the customized</div><div class="line">     *               data along with the hint type.</div><div class="line">     */</div><div class="line">    void collection_hint(const coll_t&amp; cid, uint32_t type, const bufferlist&amp; hint)</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_HINT;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;hint_type = type;</div><div class="line">        encode(hint, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// remove the collection, the collection must be empty</div><div class="line">    void remove_collection(const coll_t&amp; cid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_RMCOLL;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void collection_move(const coll_t&amp; cid, const coll_t &amp;oldcid, const ghobject_t&amp; oid)</div><div class="line">    __attribute__ ((deprecated))</div><div class="line">    &#123;</div><div class="line">        // NOTE: we encode this as a fixed combo of ADD + REMOVE.  they</div><div class="line">        // always appear together, so this is effectively a single MOVE.</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_ADD;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(cid);</div><div class="line">        data.ops++;</div><div class="line"></div><div class="line">        _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_REMOVE;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void collection_move_rename(const coll_t&amp; oldcid, const ghobject_t&amp; oldoid,</div><div class="line">                                const coll_t &amp;cid, const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_MOVE_RENAME;</div><div class="line">        _op-&gt;cid = _get_coll_id(oldcid);</div><div class="line">        _op-&gt;oid = _get_object_id(oldoid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    void try_rename(const coll_t &amp;cid, const ghobject_t&amp; oldoid,</div><div class="line">                    const ghobject_t&amp; oid)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_TRY_RENAME;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oldoid);</div><div class="line">        _op-&gt;dest_oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove omap from oid</div><div class="line">    void omap_clear(</div><div class="line">        const coll_t &amp;cid,           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid  ///&lt; [in] Object from which to remove omap</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_CLEAR;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">    /// Set keys on oid omap.  Replaces duplicate keys.</div><div class="line">    void omap_setkeys(</div><div class="line">        const coll_t&amp; cid,                           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,                ///&lt; [in] Object to update</div><div class="line">        const map&lt;string, bufferlist&gt; &amp;attrset ///&lt; [in] Replacement keys and values</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(attrset, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set keys on an oid omap (bufferlist variant).</div><div class="line">    void omap_setkeys(</div><div class="line">        const coll_t &amp;cid,                           ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,                ///&lt; [in] Object to update</div><div class="line">        const bufferlist &amp;attrset_bl          ///&lt; [in] Replacement keys and values</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data_bl.append(attrset_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove keys from oid omap</div><div class="line">    void omap_rmkeys(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap</div><div class="line">        const set&lt;string&gt; &amp;keys ///&lt; [in] Keys to clear</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(keys, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove keys from oid omap</div><div class="line">    void omap_rmkeys(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap</div><div class="line">        const bufferlist &amp;keys_bl ///&lt; [in] Keys to clear</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        data_bl.append(keys_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Remove key range from oid omap</div><div class="line">    void omap_rmkeyrange(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object from which to remove the omap keys</div><div class="line">        const string&amp; first,    ///&lt; [in] first key in range</div><div class="line">        const string&amp; last      ///&lt; [in] first key past range, range is [first,last)</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_RMKEYRANGE;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(first, data_bl);</div><div class="line">        encode(last, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set omap header</div><div class="line">    void omap_setheader(</div><div class="line">        const coll_t &amp;cid,             ///&lt; [in] Collection containing oid</div><div class="line">        const ghobject_t &amp;oid,  ///&lt; [in] Object</div><div class="line">        const bufferlist &amp;bl    ///&lt; [in] Header value</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        using ceph::encode;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_OMAP_SETHEADER;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        encode(bl, data_bl);</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Split collection based on given prefixes, objects matching the specified bits/rem are</div><div class="line">    /// moved to the new collection</div><div class="line">    void split_collection(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        uint32_t bits,</div><div class="line">        uint32_t rem,</div><div class="line">        const coll_t &amp;destination)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SPLIT_COLLECTION2;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;dest_cid = _get_coll_id(destination);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        _op-&gt;split_rem = rem;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void collection_set_bits(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        int bits)</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_COLL_SET_BITS;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;split_bits = bits;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /// Set allocation hint for an object</div><div class="line">    /// make 0 values(expected_object_size, expected_write_size) noops for all implementations</div><div class="line">    void set_alloc_hint(</div><div class="line">        const coll_t &amp;cid,</div><div class="line">        const ghobject_t &amp;oid,</div><div class="line">        uint64_t expected_object_size,</div><div class="line">        uint64_t expected_write_size,</div><div class="line">        uint32_t flags</div><div class="line">    )</div><div class="line">    &#123;</div><div class="line">        Op* _op = _get_next_op();</div><div class="line">        _op-&gt;op = OP_SETALLOCHINT;</div><div class="line">        _op-&gt;cid = _get_coll_id(cid);</div><div class="line">        _op-&gt;oid = _get_object_id(oid);</div><div class="line">        _op-&gt;expected_object_size = expected_object_size;</div><div class="line">        _op-&gt;expected_write_size = expected_write_size;</div><div class="line">        _op-&gt;alloc_hint_flags = flags;</div><div class="line">        data.ops++;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="事务入队"><a href="#事务入队" class="headerlink" title="事务入队"></a>事务入队</h1><figure class="highlight"><table><tr><td class="code"><pre><div class="line">int queue_transaction(CollectionHandle&amp; ch,</div><div class="line">                      Transaction&amp;&amp; t,</div><div class="line">                      TrackedOpRef op = TrackedOpRef(),</div><div class="line">                      ThreadPool::TPHandle *handle = NULL)</div><div class="line">&#123;</div><div class="line">    vector&lt;Transaction&gt; tls;</div><div class="line">    tls.push_back(std::move(t));</div><div class="line">    return queue_transactions(ch, tls, op, handle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual int queue_transactions(</div><div class="line">    CollectionHandle&amp; ch, vector&lt;Transaction&gt;&amp; tls,</div><div class="line">    TrackedOpRef op = TrackedOpRef(),</div><div class="line">    ThreadPool::TPHandle *handle = NULL) = 0;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// versioning</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">get_db_statistics</span><span class="params">(Formatter *f)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">generate_db_histogram</span><span class="params">(Formatter *f)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">flush_cache</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dump_perf_counters</span><span class="params">(Formatter *f)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">get_type</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// mgmt</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">test_mount_in_use</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mount</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">umount</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fsck</span><span class="params">(<span class="keyword">bool</span> deep)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">repair</span><span class="params">(<span class="keyword">bool</span> deep)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_cache_shards</span><span class="params">(<span class="keyword">unsigned</span> num)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns 0 if the hobject is valid, -error otherwise</div><div class="line">     *</div><div class="line">     * Errors:</div><div class="line">     * -ENAMETOOLONG: locator/namespace/name too large</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">validate_hobject_key</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hobject_t</span> &amp;obj)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="title">get_max_attr_name_length</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mkfs</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// wipe</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">mkjournal</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// journal only</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">needs_journal</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//&lt; requires a journal</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">wants_journal</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//&lt; prefers a journal</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">allows_journal</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//&lt; allows a journal</span></div><div class="line"></div><div class="line">    <span class="comment">/// enumerate hardware devices (by 'devname', e.g., 'sda' as in /sys/block/sda)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_devices</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *devls)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// true if a txn is readable immediately after it is queued.</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_sync_onreadable</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is_rotational</div><div class="line">     *</div><div class="line">     * Check whether store is backed by a rotational (HDD) or non-rotational</div><div class="line">     * (SSD) device.</div><div class="line">     *</div><div class="line">     * This must be usable *before* the store is mounted.</div><div class="line">     *</div><div class="line">     * @return true for HDD, false for SSD</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_rotational</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is_journal_rotational</div><div class="line">     *</div><div class="line">     * Check whether journal is backed by a rotational (HDD) or non-rotational</div><div class="line">     * (SSD) device.</div><div class="line">     *</div><div class="line">     *</div><div class="line">     * @return true for HDD, false for SSD</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">is_journal_rotational</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">get_default_device_class</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> is_rotational() ? <span class="string">"hdd"</span> : <span class="string">"ssd"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">can_sort_nibblewise</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// assume a backend cannot, unless it says otherwise</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">statfs</span><span class="params">(<span class="keyword">struct</span> <span class="keyword">store_statfs_t</span> *buf)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collect_metadata</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; *pm)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * write_meta - write a simple configuration key out-of-band</div><div class="line">     *</div><div class="line">     * Write a simple key/value pair for basic store configuration</div><div class="line">     * (e.g., a uuid or magic number) to an unopened/unmounted store.</div><div class="line">     * The default implementation writes this to a plaintext file in the</div><div class="line">     * path.</div><div class="line">     *</div><div class="line">     * A newline is appended.</div><div class="line">     *</div><div class="line">     * @param key key name (e.g., "fsid")</div><div class="line">     * @param value value (e.g., a uuid rendered as a string)</div><div class="line">     * @returns 0 for success, or an error code</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">write_meta</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; value);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * read_meta - read a simple configuration key out-of-band</div><div class="line">     *</div><div class="line">     * Read a simple key value to an unopened/mounted store.</div><div class="line">     *</div><div class="line">     * Trailing whitespace is stripped off.</div><div class="line">     *</div><div class="line">     * @param key key name</div><div class="line">     * @param value pointer to value string</div><div class="line">     * @returns 0 for success, or an error code</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">read_meta</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key,</span></span></div><div class="line">                          <span class="built_in">std</span>::<span class="built_in">string</span> *value);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get ideal max value for collection_list()</div><div class="line">     *</div><div class="line">     * default to some arbitrary values; the implementation will override.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_ideal_list_max</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">64</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get a collection handle</div><div class="line">     *</div><div class="line">     * Provide a trivial handle as a default to avoid converting legacy</div><div class="line">     * implementations.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> CollectionHandle <span class="title">open_collection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span> &amp;cid)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * get a collection handle for a soon-to-be-created collection</div><div class="line">     *</div><div class="line">     * This handle must be used by queue_transaction that includes a</div><div class="line">     * create_collection call in order to become valid.  It will become the</div><div class="line">     * reference to the created collection.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> CollectionHandle <span class="title">create_new_collection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span> &amp;cid)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Synchronous read operations</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * exists -- Test for existance of object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @returns true if object exists, false otherwise</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">exists</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * set_collection_opts -- set pool options for a collectioninformation for an object</div><div class="line">     *</div><div class="line">     * @param cid collection</div><div class="line">     * @param opts new collection options</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">set_collection_opts</span><span class="params">(</span></span></div><div class="line">        CollectionHandle&amp; c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">pool_opts_t</span>&amp; opts) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * stat -- get information for an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param st output information for the object</div><div class="line">     * @param allow_eio if false, assert on -EIO operation failure</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">stat</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">struct</span> stat *st,</div><div class="line">        <span class="keyword">bool</span> allow_eio = <span class="literal">false</span>) = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * read -- read a byte range of data from an object</div><div class="line">     *</div><div class="line">     * Note: if reading from an offset past the end of the object, we</div><div class="line">     * return 0 (not, say, -EINVAL).</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param offset location offset of first byte to be read</div><div class="line">     * @param len number of bytes to be read</div><div class="line">     * @param bl output bufferlist</div><div class="line">     * @param op_flags is CEPH_OSD_OP_FLAG_*</div><div class="line">     * @returns number of bytes read on success, or negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">uint64_t</span> offset,</div><div class="line">        <span class="keyword">size_t</span> len,</div><div class="line">        bufferlist&amp; bl,</div><div class="line">        <span class="keyword">uint32_t</span> op_flags = <span class="number">0</span>) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * fiemap -- get extent map of data of an object</div><div class="line">     *</div><div class="line">     * Returns an encoded map of the extents of an object's data portion</div><div class="line">     * (map&lt;offset,size&gt;).</div><div class="line">     *</div><div class="line">     * A non-enlightened implementation is free to return the extent (offset, len)</div><div class="line">     * as the sole extent.</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param offset location offset of first byte to be read</div><div class="line">     * @param len number of bytes to be read</div><div class="line">     * @param bl output bufferlist for extent map information.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fiemap</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                       <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> len, bufferlist&amp; bl) = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fiemap</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                       <span class="keyword">uint64_t</span> offset, <span class="keyword">size_t</span> len, <span class="built_in">map</span>&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt;&amp; destmap) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattr -- get an xattr of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param name name of attr to read</div><div class="line">     * @param value place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getattr</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                        <span class="keyword">const</span> <span class="keyword">char</span> *name, bufferptr&amp; value) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattr -- get an xattr of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param name name of attr to read</div><div class="line">     * @param value place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getattr</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</div><div class="line">        <span class="keyword">const</span> <span class="built_in">string</span>&amp; name, bufferlist&amp; value)</div><div class="line">    &#123;</div><div class="line">        bufferptr bp;</div><div class="line">        <span class="keyword">int</span> r = getattr(c, oid, name.c_str(), bp);</div><div class="line">        value.push_back(bp);</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattrs -- get all of the xattrs of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param aset place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getattrs</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                         <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt;&amp; aset) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * getattrs -- get all of the xattrs of an object</div><div class="line">     *</div><div class="line">     * @param cid collection for object</div><div class="line">     * @param oid oid of object</div><div class="line">     * @param aset place to put output result.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getattrs</span><span class="params">(CollectionHandle &amp;c, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; oid,</span></span></div><div class="line">                 <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferlist&gt;&amp; aset)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt; bmap;</div><div class="line">        <span class="keyword">int</span> r = getattrs(c, oid, bmap);</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>,bufferptr&gt;::iterator i = bmap.begin();</div><div class="line">             i != bmap.end();</div><div class="line">             ++i) &#123;</div><div class="line">            aset[i-&gt;first].append(i-&gt;second);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// collections</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * list_collections -- get all of the collections known to this ObjectStore</div><div class="line">     *</div><div class="line">     * @param ls list of the collections in sorted order.</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">list_collections</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">coll_t</span>&gt;&amp; ls)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * does a collection exist?</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @returns true if it exists, false otherwise</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">collection_exists</span><span class="params">(<span class="keyword">const</span> <span class="keyword">coll_t</span>&amp; c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * is a collection empty?</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @param empty true if the specified collection is empty, false otherwise</div><div class="line">     * @returns 0 on success, negative error code on failure.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_empty</span><span class="params">(CollectionHandle&amp; c, <span class="keyword">bool</span> *empty)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * return the number of significant bits of the coll_t::pgid.</div><div class="line">     *</div><div class="line">     * This should return what the last create_collection or split_collection</div><div class="line">     * set.  A legacy backend may return -EAGAIN if the value is unavailable</div><div class="line">     * (because we upgraded from an older version, e.g., FileStore).</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_bits</span><span class="params">(CollectionHandle&amp; c)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * list contents of a collection that fall in the range [start, end) and no more than a specified many result</div><div class="line">     *</div><div class="line">     * @param c collection</div><div class="line">     * @param start list object that sort &gt;= this value</div><div class="line">     * @param end list objects that sort &lt; this value</div><div class="line">     * @param max return no more than this many results</div><div class="line">     * @param seq return no objects with snap &lt; seq</div><div class="line">     * @param ls [out] result</div><div class="line">     * @param next [out] next item sorts &gt;= this value</div><div class="line">     * @return zero on success, or negative error</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">collection_list</span><span class="params">(CollectionHandle &amp;c,</span></span></div><div class="line">                                <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; start, <span class="keyword">const</span> <span class="keyword">ghobject_t</span>&amp; end,</div><div class="line">                                <span class="keyword">int</span> max,</div><div class="line">                                <span class="built_in">vector</span>&lt;<span class="keyword">ghobject_t</span>&gt; *ls, <span class="keyword">ghobject_t</span> *next) = <span class="number">0</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/// OMAP</span></div><div class="line">    <span class="comment">/// Get omap contents</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        bufferlist *header,      <span class="comment">///&lt; [out] omap header</span></div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, bufferlist&gt; *out <span class="comment">/// &lt; [out] Key to value map</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get omap header</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_header</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        bufferlist *header,      <span class="comment">///&lt; [out] omap header</span></div><div class="line">        <span class="keyword">bool</span> allow_eio = <span class="literal">false</span> <span class="comment">///&lt; [in] don't assert on eio</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get keys defined on oid</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_keys</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,   <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid, <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *keys      <span class="comment">///&lt; [out] Keys defined on oid</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Get key values</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_get_values</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,         <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,       <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &amp;keys,     <span class="comment">///&lt; [in] Keys to get</span></div><div class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, bufferlist&gt; *out <span class="comment">///&lt; [out] Returned keys and values</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// Filters keys into out which are defined on oid</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">omap_check_keys</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,     <span class="comment">///&lt; [in] Collection containing oid</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid,   <span class="comment">///&lt; [in] Object containing omap</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; &amp;keys, <span class="comment">///&lt; [in] Keys to check</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; *out         <span class="comment">///&lt; [out] Subset of keys defined on oid</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns an object map iterator</div><div class="line">     *</div><div class="line">     * Warning!  The returned iterator is an implicit lock on filestore</div><div class="line">     * operations in c.  Do not use filestore methods on c while the returned</div><div class="line">     * iterator is live.  (Filling in a transaction is no problem).</div><div class="line">     *</div><div class="line">     * @return iterator, null on error</div><div class="line">     */</div><div class="line">    <span class="keyword">virtual</span> ObjectMap::<span class="function">ObjectMapIterator <span class="title">get_omap_iterator</span><span class="params">(</span></span></div><div class="line">        CollectionHandle &amp;c,   <span class="comment">///&lt; [in] collection</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">ghobject_t</span> &amp;oid  <span class="comment">///&lt; [in] object</span></div><div class="line">    ) = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">flush_journal</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">dump_journal</span><span class="params">(ostream&amp; out)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">snapshot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> -EOPNOTSUPP;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Set and get internal fsid for this instance. No external data is modified</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_fsid</span><span class="params">(uuid_d u)</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uuid_d <span class="title">get_fsid</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * Estimates additional disk space used by the specified amount of objects and caused by file allocation granularity and metadata store</div><div class="line">    * - num objects - total (including witeouts) object count to measure used space for.</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">virtual</span> uint64_t <span class="title">estimate_objects_overhead</span><span class="params">(<span class="keyword">uint64_t</span> num_objects)</span> </span>= <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">compact</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">has_builtin_csum</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2018/07/31/ceph/4.CompatSet/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          1.3 CompatSet
        
      </div>
    </a>
  
  
    <a href="/blog/2018/07/20/stl/11.type_traits/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">1.10 type traits</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/5.ObjectStore的接口" data-title="1.4 ObjectStore的接口" data-url="https://jiyou.github.io/blog/blog/2018/07/31/ceph/5.ObjectStore的接口/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>