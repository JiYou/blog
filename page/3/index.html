<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些有意思的事。">
<meta property="og:type" content="website">
<meta property="og:title" content="缘生故如幻">
<meta property="og:url" content="https://jiyou.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="记录一些有意思的事。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘生故如幻">
<meta name="twitter:description" content="记录一些有意思的事。">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/categories/ceph">ceph</a></li>
				        
							<li><a href="/blog/categories/PDP11">PDP11</a></li>
				        
							<li><a href="/blog/categories/Linux">Linux</a></li>
				        
							<li><a href="/blog/categories/Kernel">Kernel</a></li>
				        
							<li><a href="/blog/categories/mit.6.824">mit.6.824</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/Ceph/" style="font-size: 10px;">Ceph</a> <a href="/blog/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/blog/tags/Gdb/" style="font-size: 18.57px;">Gdb</a> <a href="/blog/tags/JOS/" style="font-size: 15.71px;">JOS</a> <a href="/blog/tags/Kernel/" style="font-size: 11.43px;">Kernel</a> <a href="/blog/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/blog/tags/MIT-6-824/" style="font-size: 10px;">MIT 6.824</a> <a href="/blog/tags/MIT-6-828/" style="font-size: 15.71px;">MIT 6.828</a> <a href="/blog/tags/Nova/" style="font-size: 10px;">Nova</a> <a href="/blog/tags/OS/" style="font-size: 10px;">OS</a> <a href="/blog/tags/OpenStack/" style="font-size: 12.86px;">OpenStack</a> <a href="/blog/tags/Paxos/" style="font-size: 10px;">Paxos</a> <a href="/blog/tags/Qemu/" style="font-size: 17.14px;">Qemu</a> <a href="/blog/tags/Unix-V6/" style="font-size: 14.29px;">Unix V6</a> <a href="/blog/tags/Woboq/" style="font-size: 10px;">Woboq</a> <a href="/blog/tags/bluestore/" style="font-size: 10px;">bluestore</a> <a href="/blog/tags/ceph/" style="font-size: 20px;">ceph</a> <a href="/blog/tags/libevent/" style="font-size: 10px;">libevent</a> <a href="/blog/tags/pdp11/" style="font-size: 12.86px;">pdp11</a> <a href="/blog/tags/xv6/" style="font-size: 10px;">xv6</a> <a href="/blog/tags/中断/" style="font-size: 10px;">中断</a> <a href="/blog/tags/分布式/" style="font-size: 10px;">分布式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/categories/ceph">ceph</a></li>
		        
					<li><a href="/blog/categories/PDP11">PDP11</a></li>
		        
					<li><a href="/blog/categories/Linux">Linux</a></li>
		        
					<li><a href="/blog/categories/Kernel">Kernel</a></li>
		        
					<li><a href="/blog/categories/mit.6.824">mit.6.824</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-paxos/libevent-begin-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/12/08/paxos/libevent-begin-1/" class="article-date">
  	<time datetime="2016-12-08T13:43:33.000Z" itemprop="datePublished">2016-12-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/12/08/paxos/libevent-begin-1/">libevent初步使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>因为最近在看libpaxos的代码，而这部分代码里面用了很多libevent的代码。所以这里需要大概学习一下libevent。</p>
<h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>这里大概总结一下libevent的使用步骤</p>
<h2 id="开始监听"><a href="#开始监听" class="headerlink" title="开始监听"></a>开始监听</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">listen(listener, MAX_SOCKET_CONNECTION)</div></pre></td></tr></table></figure>
<h2 id="设置eventBase"><a href="#设置eventBase" class="headerlink" title="设置eventBase"></a>设置eventBase</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">base = event_base_new();</div><div class="line">listen_event = event_new(base,</div><div class="line">						     listener,</div><div class="line">						     EV_WRITE|EV_READ|EV_PERSIST,</div><div class="line">						     do_accept,  <span class="comment">// &lt;-- 这里设置回调函数</span></div><div class="line">						     (<span class="keyword">void</span>*)base);</div><div class="line">event_add(listen_event, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<h2 id="开始处理消息"><a href="#开始处理消息" class="headerlink" title="开始处理消息"></a>开始处理消息</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">event_base_dispatch(base);</div></pre></td></tr></table></figure>
<h2 id="回调函数的设置"><a href="#回调函数的设置" class="headerlink" title="回调函数的设置"></a>回调函数的设置</h2><p>这里实际上是在做接收到新链接之后的响应函数。也就是说，每个链接进来，都会走到这里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_accept</span><span class="params">(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// short event is not used here.</span></div><div class="line">    <span class="keyword">struct</span> event_base *base = (<span class="keyword">struct</span> event_base*) arg;</div><div class="line">    <span class="keyword">evutil_socket_t</span> fd;</div><div class="line">    <span class="keyword">struct</span> sockaddr_in <span class="built_in">sin</span>;</div><div class="line">    <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">char</span> *error_msg = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> bufferevent *bev = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这里开始等待客户连接上来。</span></div><div class="line">    fd = accept(listener, (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>, &amp;slen);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">        ECHO_ERROR;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Accept: fd = %u\n"</span>, fd);</div><div class="line"></div><div class="line">    <span class="comment">// 当新进来一个用户的时候，这里创建一个新的链接buffer</span></div><div class="line">    <span class="comment">// 这里需要记录下这个客户进来的链接的fd</span></div><div class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</div><div class="line">    assert(<span class="literal">NULL</span> != bev);</div><div class="line"></div><div class="line">    <span class="comment">// 这里针对这个buffer添加回调函数。</span></div><div class="line">    <span class="comment">// 需要注意的是arg这里虽然表示的是base，但是实际上，base与arg</span></div><div class="line">    <span class="comment">// 之间并没有必然的联系，只是arg会作为read_cb/write_cb/error_db</span></div><div class="line">    <span class="comment">// 的最后一个参数。</span></div><div class="line">    bufferevent_setcb(bev, read_cb, write_cb, error_cb, arg);</div><div class="line">    <span class="comment">// 针对这个buffer开启的几种消息类型。</span></div><div class="line">    bufferevent_enable(bev, EV_READ|EV_WRITE|EV_PERSIST);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">void</span> *arg)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">void</span> *arg)</span> </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="回收资源"><a href="#回收资源" class="headerlink" title="回收资源"></a>回收资源</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">close(listener);</div><div class="line">event_base_free(base);</div></pre></td></tr></table></figure>
<h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/util.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_PORT 80</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SOCKET_CONNECTION 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 256</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ECHO_ERROR  do &#123;                              \</span></div><div class="line">                        error_msg = strerror(errno);  \</div><div class="line">                        perror(error_msg);            \</div><div class="line">                    &#125; while (0)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> lines[MAX_LINE + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">    <span class="keyword">evutil_socket_t</span> fd = bufferevent_getfd(bev);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ((n = bufferevent_read(bev, lines, MAX_LINE)) &gt; <span class="number">0</span>) &#123;</div><div class="line">        lines[n] = <span class="number">0</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"fd = %u read line: %s\n"</span>, fd, lines);</div><div class="line">        bufferevent_write(bev, lines, n);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">void</span> *arg)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">evutil_socket_t</span> fd = bufferevent_getfd(bev);</div><div class="line">    assert(<span class="number">-1</span> != fd);</div><div class="line">    <span class="keyword">if</span> (event &amp; BEV_EVENT_TIMEOUT) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Time out\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event &amp; BEV_EVENT_EOF) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Connection closed\n"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event &amp; BEV_EVENT_ERROR) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error happened\n"</span>);</div><div class="line">    &#125;</div><div class="line">    bufferevent_free(bev);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_accept</span><span class="params">(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="comment">// short event is not used here.</span></div><div class="line">    <span class="keyword">struct</span> event_base *base = (<span class="keyword">struct</span> event_base*) arg;</div><div class="line">    <span class="keyword">evutil_socket_t</span> fd;</div><div class="line">    <span class="keyword">struct</span> sockaddr_in <span class="built_in">sin</span>;</div><div class="line">    <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line">    <span class="keyword">char</span> *error_msg = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> bufferevent *bev = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 这里开始等待客户连接上来。</span></div><div class="line">    fd = accept(listener, (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>, &amp;slen);</div><div class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">        ECHO_ERROR;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Accept: fd = %u\n"</span>, fd);</div><div class="line"></div><div class="line">    <span class="comment">// 当新进来一个用户的时候，这里创建一个新的链接buffer</span></div><div class="line">    <span class="comment">// 这里需要记录下这个客户进来的链接的fd</span></div><div class="line">    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</div><div class="line">    assert(<span class="literal">NULL</span> != bev);</div><div class="line"></div><div class="line">    <span class="comment">// 这里针对这个buffer添加回调函数。</span></div><div class="line">    <span class="comment">// 需要注意的是arg这里虽然表示的是base，但是实际上，base与arg</span></div><div class="line">    <span class="comment">// 之间并没有必然的联系，只是arg会作为read_cb/write_cb/error_db</span></div><div class="line">    <span class="comment">// 的最后一个参数。</span></div><div class="line">    bufferevent_setcb(bev, read_cb, write_cb, error_cb, arg);</div><div class="line">    <span class="comment">// 针对这个buffer开启的几种消息类型。</span></div><div class="line">    bufferevent_enable(bev, EV_READ|EV_WRITE|EV_PERSIST);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *error_msg = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> sockaddr_in <span class="built_in">sin</span>;</div><div class="line">    <span class="keyword">struct</span> event_base *base = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> event *listen_event = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">evutil_socket_t</span> listener;</div><div class="line"></div><div class="line">    <span class="comment">// Arguments:</span></div><div class="line">    <span class="comment">// AF_INET     : AF_INET IPv4 Internet protocols</span></div><div class="line">    <span class="comment">// SOCK_STREAM :Provides sequenced, reliable, two-way,</span></div><div class="line">    <span class="comment">//              connection-based byte streams.</span></div><div class="line">    <span class="comment">// SOCK_NONBLOCK = 0</span></div><div class="line">    listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listener) &#123;</div><div class="line">        ECHO_ERROR;</div><div class="line">        <span class="keyword">goto</span> <span class="number">_</span>error_exit;</div><div class="line">    &#125;</div><div class="line">    assert(listener &gt; <span class="number">0</span>);</div><div class="line">    assert(<span class="number">-1</span> != evutil_make_listen_socket_reuseable(listener));</div><div class="line"></div><div class="line">    <span class="comment">// Begin to create the socket.</span></div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</div><div class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(LISTEN_PORT);</div><div class="line">    <span class="keyword">if</span> (bind(listener, (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        ECHO_ERROR;</div><div class="line">        <span class="keyword">goto</span> <span class="number">_</span>error_exit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (listen(listener, MAX_SOCKET_CONNECTION) &lt; <span class="number">0</span>) &#123;</div><div class="line">        ECHO_ERROR;</div><div class="line">        <span class="keyword">goto</span> <span class="number">_</span>error_exit;</div><div class="line">    &#125;</div><div class="line">    assert(<span class="number">-1</span> != evutil_make_socket_nonblocking(listener));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Begin to listen on %d\n"</span>, LISTEN_PORT);</div><div class="line"></div><div class="line">    <span class="comment">// begin to setup event.</span></div><div class="line">    base = event_base_new();</div><div class="line">    assert(<span class="literal">NULL</span> != base);</div><div class="line"></div><div class="line">    listen_event = event_new(base, listener, EV_WRITE|EV_READ|EV_PERSIST, do_accept, (<span class="keyword">void</span>*)base);</div><div class="line">    assert(<span class="literal">NULL</span> != listen_event);</div><div class="line">    <span class="comment">// 参数：event，超时时间,NULL表示无超时设置</span></div><div class="line">    event_add(listen_event, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    event_base_dispatch(base);</div><div class="line"></div><div class="line">    <span class="comment">// 2 stands for can not read/write</span></div><div class="line">    close(listener);</div><div class="line">    event_base_free(base);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="number">_</span>error_exit:</div><div class="line">    close(listener);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Ceph/">Ceph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/libevent/">libevent</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/libevent/">libevent</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-paxos/libevent-begin-1" data-title="libevent初步使用" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-how2read.code/seq-comment" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/11/22/how2read.code/seq-comment/" class="article-date">
  	<time datetime="2016-11-22T15:23:48.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/11/22/how2read.code/seq-comment/">seq comment</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>电子文档：第55页</p>
<p>在看《反璞归真－Unix技术内幕》一书的时候，对下面这段话当时不是特别理解，这里特别加一下注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">参数说明:</div><div class="line">nt 是程序段(文本段)大小(块数,每块 64 字节);</div><div class="line">nd 是数据段(初始化和 未初始化)大小;</div><div class="line">ns 是栈段大小;</div><div class="line">sep 指示程序段和数据段/栈段是否必须连续,1 表示可以分 开,0 表示必须连续。</div><div class="line"></div><div class="line">这是针对 PDP 11/70 芯片所做的处理,PDP 11/70 芯片中有 16 个活动页寄存器</div><div class="line">所以程序段和数据段/栈段可以分开,各用 8个寄存器映射;</div><div class="line">而 PDP 11/40 只有8个 活动页寄存器</div><div class="line">所以程序段和数据段/栈段必须连续。</div></pre></td></tr></table></figure>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>对这一段，我的理解是：<code>PDP-11/40</code>只有8个APR，如果再把程序段与数据区域分开。这里指的分开应该是指<code>APR</code>是不是分开的，比如某几个只给程序段使用，某几个只给数据区域使用。而不是表示地址或者物理地址是否是连续的。</p>
<p>不能分开的原因在于：如果<code>PDP-11/40</code>只有8组APR，如果分开，比如对半分。那么4个给程序段，4个给数据段。这么分容易出现的情况就是，比如：</p>
<ul>
<li>程序段用不了4个APR，但是数据区域却需要5个APR。就是一边有多余，一边还不足。这个时候不能满足要求。</li>
</ul>
<p>所以这8组APR必段是连在一起用。才能保证程序有64KB的空间。否则分开则不能保证有64KB的空间使用。</p>
<p>而PDP-11/70有16组，直接分成两半，就可以保证程序有64KB的空间可以使用。因为8组APR就可以指明64KB了。</p>
<p># </p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 设置软件活动页段寄存器来实现 * 所传入的 3 个参数大小的伪文本(程序)段、 * 数据段和栈段大小。 * 参数 sep 指示文本和数据/栈段是否分离.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Set up software prototype segmentation</div><div class="line"> * registers to implement the 3 pseudo</div><div class="line"> * text,data,stack segment sizes passed</div><div class="line"> * as arguments.</div><div class="line"> * The argument sep specifies if the</div><div class="line"> * text and data+stack segments are to</div><div class="line"> * be separated.</div><div class="line"> */</div><div class="line">estabur(nt, nd, ns, sep)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">register</span> a, *ap, *dp;</div><div class="line">	<span class="comment">// 切分是PDP-11/70机型的任务</span></div><div class="line">	<span class="keyword">if</span>(sep) &#123;</div><div class="line">		<span class="comment">// 如果发现机型是PDP-11/40，那么报错。</span></div><div class="line">		<span class="comment">// 注意报错的方式是返回状态错误码。</span></div><div class="line">		<span class="keyword">if</span>(cputype == <span class="number">40</span>)</div><div class="line">			<span class="keyword">goto</span> err;</div><div class="line">		<span class="comment">// 如果是PDP-11/70机型，由于程序段与数据区域各占用8个APR</span></div><div class="line">		<span class="comment">// 所以只需要保证程序段与数据区域不超出8页就OK</span></div><div class="line">		<span class="comment">// nseg函数是：(n+127)&gt;&gt;7；也就是往128的倍数取整。即取8KB的整数倍。</span></div><div class="line">		<span class="keyword">if</span>(nseg(nt) &gt; <span class="number">8</span> || nseg(nd)+nseg(ns) &gt; <span class="number">8</span>)</div><div class="line">			<span class="keyword">goto</span> err;</div><div class="line">	&#125; <span class="keyword">else</span></div><div class="line">		<span class="comment">// 如果不切分，比如PDP-11/40，总共只有8个APR，那么</span></div><div class="line">		<span class="comment">// 程序段与数据区域总的页数不能超过8页。</span></div><div class="line">		<span class="keyword">if</span>(nseg(nt)+nseg(nd)+nseg(ns) &gt; <span class="number">8</span>)</div><div class="line">			<span class="keyword">goto</span> err;</div><div class="line">	<span class="comment">// 如果这个程序需要的总的内存加起来比机器总的内存还要大，那么报错。</span></div><div class="line">	<span class="comment">// 注意，这里加了USIZE。</span></div><div class="line">	<span class="comment">// 那么为什么前面不加？</span></div><div class="line">	<span class="comment">// 答：USIZE也就是1KB＝16*64。无论是放在nd还是ns中，都是只是增加了16。</span></div><div class="line">	<span class="comment">//    那么如果要让前面的代码失败，无非是需要满足：</span></div><div class="line">	<span class="comment">//   cond1. nseg(nt)+nseg(nd)+nseg(ns) &lt;= 8 成立 即 nseg(nt)+nseg(nd)+nseg(ns) &lt;= 7</span></div><div class="line">	<span class="comment">//   cond2. nseg(nt)+nseg(nd + 16)+nseg(ns) &gt; 8 成立</span></div><div class="line">	<span class="comment">//    或者是</span></div><div class="line">	<span class="comment">//    nseg(nt)+nseg(nd)+nseg(ns + 16) &gt; 8 成立，但是这个条件实际上与上面那个是等价的。</span></div><div class="line">	<span class="comment">// 如果要条件cond1, cond2满足，</span></div><div class="line">	<span class="comment">// </span></div><div class="line">	<span class="comment">// 当cond1. nseg(nt)+nseg(nd)+nseg(ns) == 7。</span></div><div class="line">	<span class="comment">// 因为16与128对相比，最多也就是增加1个128（因为往上取整嘛）。如果cond1 == 6。cond2就不可能成立。</span></div><div class="line">	<span class="comment">// 实际上cond1 == 7的时候，也不会让cond2成立。因为16块也最多只增加一个128块（往上取整）。</span></div><div class="line">	<span class="comment">// </span></div><div class="line">	<span class="comment">// 当cond1 == 8的时候。cond2实际上是有可能成立的。</span></div><div class="line">	<span class="comment">// 但是，此时应该是必然触发：if (nt + nd + ns + USIZE &gt; maxmem)</span></div><div class="line">	<span class="keyword">if</span>(nt+nd+ns+USIZE &gt; maxmem)</div><div class="line">		<span class="keyword">goto</span> err;</div><div class="line"></div><div class="line">	</div><div class="line">	a = <span class="number">0</span>;</div><div class="line">	ap = &amp;u.u_uisa[<span class="number">0</span>];</div><div class="line">	dp = &amp;u.u_uisd[<span class="number">0</span>];</div><div class="line">	<span class="comment">// 这里指向</span></div><div class="line">	<span class="keyword">while</span>(nt &gt;= <span class="number">128</span>) &#123;</div><div class="line">		*dp++ = (<span class="number">127</span>&lt;&lt;<span class="number">8</span>) | RO;</div><div class="line">		*ap++ = a;</div><div class="line">		a =+ <span class="number">128</span>;</div><div class="line">		nt =- <span class="number">128</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(nt) &#123;</div><div class="line">		*dp++ = ((nt<span class="number">-1</span>)&lt;&lt;<span class="number">8</span>) | RO;</div><div class="line">		*ap++ = a;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(sep)</div><div class="line">	<span class="keyword">while</span>(ap &lt; &amp;u.u_uisa[<span class="number">8</span>]) &#123;</div><div class="line">		*ap++ = <span class="number">0</span>;</div><div class="line">		*dp++ = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	a = USIZE;</div><div class="line">	<span class="keyword">while</span>(nd &gt;= <span class="number">128</span>) &#123;</div><div class="line">		*dp++ = (<span class="number">127</span>&lt;&lt;<span class="number">8</span>) | RW;</div><div class="line">		*ap++ = a;</div><div class="line">		a =+ <span class="number">128</span>;</div><div class="line">		nd =- <span class="number">128</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(nd) &#123;</div><div class="line">		*dp++ = ((nd<span class="number">-1</span>)&lt;&lt;<span class="number">8</span>) | RW;</div><div class="line">		*ap++ = a;</div><div class="line">		a =+ nd;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(ap &lt; &amp;u.u_uisa[<span class="number">8</span>]) &#123;</div><div class="line">		*dp++ = <span class="number">0</span>;</div><div class="line">		*ap++ = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(sep)</div><div class="line">	<span class="keyword">while</span>(ap &lt; &amp;u.u_uisa[<span class="number">16</span>]) &#123;</div><div class="line">		*dp++ = <span class="number">0</span>;</div><div class="line">		*ap++ = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	a =+ ns;</div><div class="line">	<span class="keyword">while</span>(ns &gt;= <span class="number">128</span>) &#123;</div><div class="line">		a =- <span class="number">128</span>;</div><div class="line">		ns =- <span class="number">128</span>;</div><div class="line">		*--dp = (<span class="number">127</span>&lt;&lt;<span class="number">8</span>) | RW;</div><div class="line">		*--ap = a;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ns) &#123;</div><div class="line">		*--dp = ((<span class="number">128</span>-ns)&lt;&lt;<span class="number">8</span>) | RW | ED;</div><div class="line">		*--ap = a<span class="number">-128</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(!sep) &#123;</div><div class="line">		ap = &amp;u.u_uisa[<span class="number">0</span>];</div><div class="line">		dp = &amp;u.u_uisa[<span class="number">8</span>];</div><div class="line">		<span class="keyword">while</span>(ap &lt; &amp;u.u_uisa[<span class="number">8</span>])</div><div class="line">			*dp++ = *ap++;</div><div class="line">		ap = &amp;u.u_uisd[<span class="number">0</span>];</div><div class="line">		dp = &amp;u.u_uisd[<span class="number">8</span>];</div><div class="line">		<span class="keyword">while</span>(ap &lt; &amp;u.u_uisd[<span class="number">8</span>])</div><div class="line">			*dp++ = *ap++;</div><div class="line">	&#125;</div><div class="line">	sureg();</div><div class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">err:</div><div class="line">	u.u_error = ENOMEM;</div><div class="line">	<span class="keyword">return</span>(<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JOS/">JOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/MIT-6-828/">MIT 6.828</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Unix-V6/">Unix V6</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/UnixV6/">UnixV6</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-how2read.code/seq-comment" data-title="seq comment" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-unixv6/The-7th-Page" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/11/22/unixv6/The-7th-Page/" class="article-date">
  	<time datetime="2016-11-22T13:45:44.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/11/22/unixv6/The-7th-Page/">The Kernel 7th APR</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>由于<code>PDP-11/40</code>采用的是<code>unibus</code>模式。也就是说，所有的寄存器，外设等等都是在同一个地址空间里面。所以PSW寄存器也是在内存地址空间里面。<br>首先是查看<code>PSW</code>的地址。在<code>PDP-11/40</code>的手册里面，写的地址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0777,776 CPU STATUS</div></pre></td></tr></table></figure>
<p>但是在《反璞归真－Unix技术内幕》书中却是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0177,776</div></pre></td></tr></table></figure>
<p>这两者如何统一？哪个是对的？</p>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>实际上，两个都是对的。这是因为<code>PDP-11/40 handbook</code>主要是介绍物理硬件特性，不会介绍软件部分，因此这里写的地址是真实的物理地址，采用8进制的方式。</p>
<p>而在书中主要是介绍内核为主，那么在介绍地址的时候，采用的是虚拟地址。所以，一个对应的是真实的物理地址，一个对应的是操作系统内核模式下的虚拟地址。</p>
<h1 id="如何统一"><a href="#如何统一" class="headerlink" title="如何统一"></a>如何统一</h1><p>那么，这里需要查看一下如何通过虚拟地址，转换成真实的物理地址。注意，下面在讨论的时候，都是在内核模式下讨论。</p>
<h2 id="2进制"><a href="#2进制" class="headerlink" title="2进制"></a>2进制</h2><p><code>PSW</code>虚拟地址的2进制为：<code>注意：PDP-11/40</code>是一个16位机器。虚拟地址也是16位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1,111,111,111,111,110</div></pre></td></tr></table></figure>
<p>虚拟地址分为三部分：页选择位，块编号，块内偏移。</p>
<h3 id="页选择位"><a href="#页选择位" class="headerlink" title="页选择位"></a>页选择位</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1,11   1,111,111,111,110</div><div class="line">|__|</div><div class="line">  |------&gt; APR选择，这里选中第七号APR</div></pre></td></tr></table></figure>
<p>这里可以看出，选中的APR为第7个APR。第7个APR的内容在代码中是如下设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file sys/conf/m40.s</span></div><div class="line"><span class="number">737</span>     mov $IO,(r0)+</div><div class="line"><span class="number">738</span>     mov $<span class="number">77406</span>,(r1)+        / rw <span class="number">4</span>k</div><div class="line"></div><div class="line"><span class="number">828</span> IO  = <span class="number">7600</span></div></pre></td></tr></table></figure>
<p>在这里，主要是将7号APR中的PAR设置为<code>IO</code>，而<code>IO</code>的值为7600。</p>
<p><strong>注意</strong>代码中都是采用的是8进制数。</p>
<p><code>07600</code>换算成<code>10</code>进制数就是<code>H3968</code>。但是，注意的是PAR指定的是以块为单位，也就是说，选中的是整个硬件系统<code>4096</code>块里面的<code>3968</code>块做为基址。而一个块是64字节。因此，这里PAR的基址也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">3968 * 64 = 248KB</div></pre></td></tr></table></figure>
<p>而整个系统只有<code>256KB</code>，因此，第7号APR选中的是系统的最后8KB。</p>
<p>这里利用8进制来表示基地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">7600</span> * <span class="number">100</span> = <span class="number">760000</span> <span class="comment">// H64的8进制就是100。</span></div></pre></td></tr></table></figure>
<h3 id="块编号"><a href="#块编号" class="headerlink" title="块编号"></a>块编号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1,11   1,111,111,    111,110</div><div class="line">       |________|</div><div class="line">           |------&gt; 选中0177块</div></pre></td></tr></table></figure>
<p>8进制的0177，换成10进制，也就是127。所以这里指向的是系统最后一块64字节。</p>
<p>在这一页中，<code>177</code>块的地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">177 * 100 = 17700 // H64表示8进制为100</div></pre></td></tr></table></figure>
<h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1,11   1,111,111,    111,110</div><div class="line">                      |___|</div><div class="line">                        |------&gt; 偏移值为76</div></pre></td></tr></table></figure>
<p>而<code>076</code>换成10进制，也就是62。</p>
<p>所以虚拟地址：<code>0177,776</code>表示的真实的物理地址是256KB的最高位的最后两个字节。</p>
<h3 id="换算"><a href="#换算" class="headerlink" title="换算"></a>换算</h3><p><code>基地址＋块地址＋偏移量 = 760000 + 17700 + 76 = 777 776</code>。也就是真实的物理地址。</p>
<h1 id="基他寄存器的地址映射"><a href="#基他寄存器的地址映射" class="headerlink" title="基他寄存器的地址映射"></a>基他寄存器的地址映射</h1><h2 id="SSR0"><a href="#SSR0" class="headerlink" title="SSR0"></a>SSR0</h2><p>通过同样的计算方法，也可以算出其他寄存器的位置。比如书中讲到SSR0寄存器的虚拟地址为<code>65402</code>。注意，这里用的是10进制。那么换算成8进制，就是<code>177572</code>。</p>
<p>写成2进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 111, 111, 101, 111, 010</div><div class="line">切分一下，得到</div><div class="line"></div><div class="line">1 11----1, 111, 101----111, 010</div></pre></td></tr></table></figure>
<p>可以看到，这里又选中了7号APR，块号为0175, 内部偏移量为072。那么8进制表示的物理地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">7600 * 100 + 175 * 100 + 72 = 7600 + 17500 + 72 = 777 572</div></pre></td></tr></table></figure>
<p>刚好又对应上<code>PDP-11/40 handbook</code>中<code>B-2</code>页的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">777752 11/45 SSR0</div></pre></td></tr></table></figure>
<h2 id="UISA0"><a href="#UISA0" class="headerlink" title="UISA0"></a>UISA0</h2><p>UISA0的虚拟地址用10进制表示为：<code>65440</code>。用8进制则是：<code>177640</code>。写成2进制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1,111,111,110,100,000</div><div class="line">切分一下：</div><div class="line">1,11-------1,111,110,-----100,000</div></pre></td></tr></table></figure>
<p>可以看到，选中的仍然是7号APR，内部偏移量为<code>0176</code>，块内偏移量为<code>60</code>。那么可以计算出物理地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">7600 * 100 + 176 * 100 + 60 = 760000 + 17600 + 60 = 777660</div></pre></td></tr></table></figure>
<h2 id="计算物理地址的程序"><a href="#计算物理地址的程序" class="headerlink" title="计算物理地址的程序"></a>计算物理地址的程序</h2><p>这里写个计算物理地址的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="number">_</span>virtual_address &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset:<span class="number">6</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> block_no:<span class="number">7</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> apr_no:<span class="number">3</span>;</div><div class="line">&#125; <span class="number">__</span>attribute__ ((packed))  virtual_address;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    virtual_address x;</div><div class="line">    <span class="keyword">short</span> vd;</div><div class="line">    <span class="keyword">int</span> apr_no, block_no, offset;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> apr_base_address = <span class="number">0760000</span>;</div><div class="line">    <span class="keyword">int</span> address = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: lookup-address address_in_hex\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vd = atoi(argv[<span class="number">1</span>]);</div><div class="line">    x = *((virtual_address*)(&amp;vd));</div><div class="line"></div><div class="line">    apr_no = x.apr_no;</div><div class="line">    block_no = x.block_no;</div><div class="line">    offset = x.offset;</div><div class="line"></div><div class="line">    assert(apr_no == <span class="number">7</span>);</div><div class="line"></div><div class="line">    address = apr_base_address + block_no * <span class="number">64</span> + offset;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%o\n"</span>, address);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如可以查看<code>65454</code>的地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./lookup-address 65454</div><div class="line">777656</div></pre></td></tr></table></figure>
<h1 id="其他地址"><a href="#其他地址" class="headerlink" title="其他地址"></a>其他地址</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Type    Address     Vector    Description</div><div class="line">-       17 777 776  -         PSW - Program status word</div><div class="line">-       17 777 774  -         Stack limit register</div><div class="line">-       17 777 772  -         PIRQ - Software IRQ register</div><div class="line">-       17 777 766  -         CER - CPU Error Register</div><div class="line">-       17 777 640  -         MMU User mode PAR  &lt;--- 重要</div><div class="line">-       17 777 600  -         MMU User mode PDR</div><div class="line">-       17 777 576  -         MMU SR2</div><div class="line">-       17 777 574  -         MMU SR1</div><div class="line">-       17 777 572  -         MMU SR0</div><div class="line">-       17 777 570  -         Console switch and display register</div><div class="line">KL11    17 777 560  60/64/4   KL11 Console serial line</div><div class="line">KW11L   17 777 546  100/6     KW-11L Line clock - default 60Hz</div><div class="line">RK11    17 777 400  220/5     RK11 RK05 Disk controller</div><div class="line">RH11/70 17 776 700  254/5     RH11/RH70 Mass bus controller - RP/RM disk</div><div class="line">KL11    17 776 500  300/304/4 KL11 optional 2nd serial line</div><div class="line">KL11    17 776 510  310/314/4 KL11 optional 3rd serial line</div><div class="line">KL11    17 776 520  320/324/4 KL11 optional 4th serial line</div><div class="line">XU      17 774 510  120/5     DEUNA controller</div><div class="line">RL11    17 774 400  160/5     RL11 RL02 disk controller</div><div class="line">M9312   17 773 000  -         M9312-style bootrom</div><div class="line">-       17 772 516  -         MMU SR3</div><div class="line">-       17 772 340  -         MMU Kernel mode PAR  &lt;-- 重要</div><div class="line">-       17 772 300  -         MMU Kernel mode PDR</div><div class="line">-       17 772 240  -         MMU Supervisor mode PAR</div><div class="line">-       17 772 200  -         MMU Supervisor mode PDR</div><div class="line">-       17 770 200  -         Unibus map registers</div></pre></td></tr></table></figure>
<p>来源：<a href="http://pdp2011.sytse.net/wordpress/pdp-11/" target="_blank" rel="external">http://pdp2011.sytse.net/wordpress/pdp-11/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JOS/">JOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/MIT-6-828/">MIT 6.828</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Unix-V6/">Unix V6</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/UnixV6/">UnixV6</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-unixv6/The-7th-Page" data-title="The Kernel 7th APR" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-unixv6/Unix-v6-interrupt" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/11/21/unixv6/Unix-v6-interrupt/" class="article-date">
  	<time datetime="2016-11-21T09:05:41.000Z" itemprop="datePublished">2016-11-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/11/21/unixv6/Unix-v6-interrupt/">Unix V6 中断响应处理整理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="中断处理硬件部分"><a href="#中断处理硬件部分" class="headerlink" title="中断处理硬件部分"></a>中断处理硬件部分</h1><p><img src="/blog/img/unixv6/interrupt-hardware.jpeg" alt=""></p>
<h1 id="中断处理软件部分"><a href="#中断处理软件部分" class="headerlink" title="中断处理软件部分"></a>中断处理软件部分</h1><h2 id="被中断的为用户进程"><a href="#被中断的为用户进程" class="headerlink" title="被中断的为用户进程"></a>被中断的为用户进程</h2><p><img src="/blog/img/unixv6/interrupt-user-program.jpeg" alt=""></p>
<h2 id="被中断的是内核进程"><a href="#被中断的是内核进程" class="headerlink" title="被中断的是内核进程"></a>被中断的是内核进程</h2><p><img src="/blog/img/unixv6/interrupt-kernel-program.jpeg" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JOS/">JOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/MIT-6-828/">MIT 6.828</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Unix-V6/">Unix V6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/中断/">中断</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/UnixV6/">UnixV6</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-unixv6/Unix-v6-interrupt" data-title="Unix V6 中断响应处理整理" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-paxos/Compile-Paxos" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/11/17/paxos/Compile-Paxos/" class="article-date">
  	<time datetime="2016-11-17T08:30:49.000Z" itemprop="datePublished">2016-11-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/11/17/paxos/Compile-Paxos/">编译libpaxos</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>编译的方法很简单，在ubuntu上只需要以下几步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://bitbucket.org/sciascid/libpaxos.git</div><div class="line">mkdir libpaxos/build</div><div class="line"><span class="built_in">cd</span> libpaxos/build</div><div class="line">apt-get install libevent-dev libmsgpack*</div><div class="line">cmake ..</div><div class="line">make</div></pre></td></tr></table></figure>
<p>然后就可以编译成功。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Paxos/">Paxos</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-paxos/Compile-Paxos" data-title="编译libpaxos" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/write-os-1-bootloader" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/10/30/mit.6.828/write-os-1-bootloader/" class="article-date">
  	<time datetime="2016-10-30T13:32:58.000Z" itemprop="datePublished">2016-10-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/10/30/mit.6.828/write-os-1-bootloader/">自己动手写操作系统-1.bootloader</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>这里主要是通过自己动手实现<code>MIT 6.828</code>课程里面的主要部分。也就是<code>JOS</code>以及<code>XV6</code>。实验环境是采用<code>ubuntu</code>。可以参考<code>xv6</code>系统博文里面实验环境的搭建。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先当PC带电启动的时候，会自动搜索可启动介质：需要满足下面两个需求：</p>
<ul>
<li>可启动介质的大小是512。</li>
<li>启动介质必须以<code>0x55,0xaa</code>结束。</li>
</ul>
<p>如果找到这样的启动介质，那么会把相应的内容加载到<code>0x7c00</code>，然后从<code>0x7c00</code>去取指令开始执行。</p>
<h2 id="最简单的bootloader"><a href="#最简单的bootloader" class="headerlink" title="最简单的bootloader"></a>最简单的bootloader</h2><p>这里为了开发出一个与<code>xv6</code>类似的操作系统，那么首先需要的就是写个最简单的<code>bootloader</code>，在编写的时候，是以<code>JOS/xv6</code>的实现为目标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">.code16</div><div class="line">.global start</div><div class="line"></div><div class="line">start:</div><div class="line">    jmp start</div></pre></td></tr></table></figure>
<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ul>
<li>首先<code>.code16</code>表明当前指令还在<code>16</code>位模式下执行。</li>
<li><code>.global start</code>表示声明的函数<code>start</code>，是全局可以见的。</li>
<li><code>start:</code>关键字开始就是程序的代码部分。</li>
</ul>
<p>代码实现非常简单，就是直接跳到<code>start</code>处再开始执行。</p>
<h2 id="制作可启动介质"><a href="#制作可启动介质" class="headerlink" title="制作可启动介质"></a>制作可启动介质</h2><p>首先根据上面的代码，执行汇编命令进行编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector -fno-pic -nostdinc -I. -c bootasm.S</div><div class="line">ld -m    elf_i386 -N <span class="_">-e</span> start -Ttext 0x7C00 -o bootblock.o bootasm.o</div><div class="line">objdump -S bootblock.o &gt; bootblock.asm</div><div class="line">objcopy -S -O binary -j .text bootblock.o bootblock</div></pre></td></tr></table></figure>
<p>经过这一系统命令的处理，就可以得到一个只包含指令的二进制文件<code>bootblock</code>。那么这个文件是如何得到的？前面执行的指令的含义是什么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -&gt; 指明使用gcc来编译写的汇编代码</div><div class="line">-c  -&gt; c表示compile</div><div class="line">-fno-builtin -&gt; 不要使用内建函数</div><div class="line">-fno-omit-frame-pointer -&gt; 不要忽略帧指针</div><div class="line">-fno-pic -&gt; not position independent code，也就是说这里生成的代码是地址相关的。</div><div class="line">-fno-stack-protector -&gt; 不要提供栈保护</div><div class="line">-fno-strict-aliasing -&gt; 不要在编译的时候弄成强制对齐。</div><div class="line">-ggdb -&gt; 要支持gdb调试</div><div class="line">-m32 -&gt; 采用32位系统的编译方式。</div><div class="line">-MD -&gt; 就是在编译的时候，除了生成a.o文件，还会生成a.d依赖关系描述文件。</div><div class="line">-nostdinc -&gt; 不要包含标准库。</div><div class="line"></div><div class="line"><span class="comment"># ld指令</span></div><div class="line">-m elf_i386 这个是说在load的时候，采用elf_i386模式。</div><div class="line">-N 表示生成出来的文件最好是可读性比较高。</div><div class="line"></div><div class="line"><span class="comment"># objdump 这里是将生成好的bootblock.o文件返汇编成bootblock.asm汇编程序。</span></div><div class="line"><span class="comment"># objcopy 则是单纯地将二进制指令部分拷贝出来。</span></div><div class="line">-S 表示strip-all</div><div class="line">-O binary表示按二进制的格式输出</div><div class="line">-j .text 表示拷贝代码段</div></pre></td></tr></table></figure>
<h1 id="制作可启动介质-1"><a href="#制作可启动介质-1" class="headerlink" title="制作可启动介质"></a>制作可启动介质</h1><p>这个时候就可以利用生成的文件制作可启动介质，制作的原理很简单，就是在原来的文件后面追加内容，比如在<code>510</code>位置开始放<code>0x55,0xaa</code>即可。放置的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line">open(SIG, <span class="variable">$ARGV</span>[0]) || die <span class="string">"open <span class="variable">$ARGV</span>[0]: $!"</span>;</div><div class="line"></div><div class="line"><span class="variable">$n</span> = sysread(SIG, <span class="variable">$buf</span>, 1000);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="variable">$n</span> &gt; 510)&#123;</div><div class="line">  <span class="built_in">print</span> STDERR <span class="string">"boot block too large: <span class="variable">$n</span> bytes (max 510)\n"</span>;</div><div class="line">  <span class="built_in">exit</span> 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span> STDERR <span class="string">"boot block is <span class="variable">$n</span> bytes (max 510)\n"</span>;</div><div class="line"></div><div class="line"><span class="variable">$buf</span> .= <span class="string">"\0"</span> x (510-<span class="variable">$n</span>);</div><div class="line"><span class="variable">$buf</span> .= <span class="string">"\x55\xAA"</span>;</div><div class="line"></div><div class="line">open(SIG, <span class="string">"&gt;<span class="variable">$ARGV</span>[0]"</span>) || die <span class="string">"open &gt;<span class="variable">$ARGV</span>[0]: $!"</span>;</div><div class="line"><span class="built_in">print</span> SIG <span class="variable">$buf</span>;</div><div class="line">close SIG;</div></pre></td></tr></table></figure>
<p>这个脚本的使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./sign.pl bootblock</div></pre></td></tr></table></figure>
<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>如果每次编译都是从头开始执行这些指令，无疑是非常麻烦的，那么有没有什么好的方法？答案就是写<code>Makefile</code>。那么可以编写一个初步版本的<code>Makefile</code>能够完成一步生成可启动介质的功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">CC = $(TOOLPREFIX)gcc</div><div class="line">AS = $(TOOLPREFIX)gas</div><div class="line">LD = $(TOOLPREFIX)ld</div><div class="line">OBJCOPY = $(TOOLPREFIX)objcopy</div><div class="line">OBJDUMP = $(TOOLPREFIX)objdump</div><div class="line">CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer</div><div class="line">CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">echo</span> -fno-stack-protector)</div><div class="line">ASFLAGS = -m32 -gdwarf-2 -Wa,-divide</div><div class="line">LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2&gt;/dev/null)</div><div class="line"></div><div class="line">bootblock: bootasm.S</div><div class="line">	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S</div><div class="line">	$(LD) $(LDFLAGS) -N <span class="_">-e</span> start -Ttext 0x7C00 -o bootblock.o bootasm.o</div><div class="line">	$(OBJDUMP) -S bootblock.o &gt; bootblock.asm</div><div class="line">	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock</div><div class="line">	./sign.pl bootblock</div><div class="line"></div><div class="line">QEMU=qemu-system-i386</div><div class="line">QEMUOPTS = -drive file=bootblock,index=0,media=disk,format=raw -m 128 $(QEMUEXTRA)</div><div class="line"></div><div class="line"><span class="comment"># try to generate a unique GDB port</span></div><div class="line">GDBPORT = $(shell expr `id -u` % 5000 + 25000)</div><div class="line"><span class="comment"># QEMU's gdb stub command line changed in 0.11</span></div><div class="line">QEMUGDB = $(shell <span class="keyword">if</span> $(QEMU) -help | grep -q <span class="string">'^-gdb'</span>; \</div><div class="line">    <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"-gdb tcp::<span class="variable">$(GDBPORT)</span>"</span>; \</div><div class="line">    <span class="keyword">else</span> <span class="built_in">echo</span> <span class="string">"-s -p <span class="variable">$(GDBPORT)</span>"</span>; <span class="keyword">fi</span>)</div><div class="line"></div><div class="line"></div><div class="line">qemu: bootblock</div><div class="line">	$(QEMU) -serial mon:stdio $(QEMUOPTS)</div><div class="line"></div><div class="line">qemu-gdb: bootblock</div><div class="line">	@<span class="built_in">echo</span> <span class="string">"*** Now run 'gdb'."</span> 1&gt;&amp;2</div><div class="line">	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)</div><div class="line"></div><div class="line">qemu-nox-gdb: bootblock</div><div class="line">	@<span class="built_in">echo</span> <span class="string">"*** Now run 'gdb'."</span> 1&gt;&amp;2</div><div class="line">	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)</div><div class="line"></div><div class="line">clean:</div><div class="line">	rm -rf *.asm bootblock kernel *.txt *.o *.d</div></pre></td></tr></table></figure>
<p>这个<code>Makefile</code>里面添加对于代码的编译，以及<code>qemu</code>调试的支持。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/xv6/">xv6</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/write-os-1-bootloader" data-title="自己动手写操作系统-1.bootloader" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/ceph-rbd-read" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/10/27/ceph/ceph-rbd-read/" class="article-date">
  	<time datetime="2016-10-26T16:24:58.000Z" itemprop="datePublished">2016-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/10/27/ceph/ceph-rbd-read/">Ceph 调试 RBD读写流程-2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RBD读取接口"><a href="#RBD读取接口" class="headerlink" title="RBD读取接口"></a>RBD读取接口</h1><p>经过前面一篇文章，应该可以进入到<code>RBD</code>读取数据的接口了。也就是进入到<code>librbd/librbd.cc</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line"> |2628    extern "C" int rbd_aio_read(rbd_image_t image, uint64_t off, size_t len,                                                   |</div><div class="line"> |2629                                char *buf, rbd_completion_t c)                                                                 |</div><div class="line">&gt;|2630    &#123;                                                                                                                          |</div><div class="line"> |2631      librbd::ImageCtx *ictx = (librbd::ImageCtx *)image;                                                                      |</div><div class="line"> |2632      librbd::RBD::AioCompletion *comp = (librbd::RBD::AioCompletion *)c;                                                      |</div><div class="line"> |2633      tracepoint(librbd, aio_read_enter, ictx, ictx-&gt;name.c_str(), ictx-&gt;snap_name.c_str(), ictx-&gt;read_only, off, len, buf, com|</div><div class="line"> |2634      ictx-&gt;aio_work_queue-&gt;aio_read(get_aio_completion(comp), off, len, buf, NULL,                                            |</div><div class="line"> |2635                                     0);                                                                                       |</div><div class="line"> |2636      tracepoint(librbd, aio_read_exit, 0);                                                                                    |</div><div class="line"> |2637      return 0;                                                                                                                |</div><div class="line"> |2638    &#125;</div></pre></td></tr></table></figure>
<p>注意s-&gt;image的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">(gdb) print s-&gt;image</div><div class="line">$<span class="number">5</span> = (<span class="keyword">rbd_image_t</span>) <span class="number">0x555556521b90</span></div></pre></td></tr></table></figure>
<p>参数的含义：</p>
<ul>
<li>这里<code>rbd_image_t</code>是在<code>rbd_aio_open()</code>也就是打开<code>rbd</code>设备的时候生成的<code>ImageCtx</code>。后面再讲<code>rbd_aio_open</code>的流程，这里先看一下读取的流程。</li>
<li>off表示读取的偏移量，目前为0.</li>
<li>len表示读取的数据的大小，这里为2048。</li>
<li><code>c</code>是前面成的回调函数的结构体指针，类型是<code>librbd::RBD::AioCompletion</code>，里面会包含一个 <code>librbd::AioCompletion</code>的结构<code>pc</code>，在这个结构里面才真正包含相应的信息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">librbd::<span class="function">AioCompletion* <span class="title">get_aio_completion</span><span class="params">(librbd::RBD::AioCompletion *comp)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;librbd::AioCompletion *&gt;(comp-&gt;pc); <span class="comment">// &lt;-- 这里就是直接返回那个pc指针。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后面的读取应该可以明白，就是把磁盘指定位置<code>offset = 0, length = 2048</code>的内容读取到缓冲区里面。</p>
<h1 id="aio-read"><a href="#aio-read" class="headerlink" title="aio_read()"></a>aio_read()</h1><p>接下来就是进入到接口里面<code>aio_read()</code>函数部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file: librbd/AioImageRequestWQ.cc:94</span></div><div class="line"><span class="comment">// 这里需要注意从上层传进来的参数。其中op_flags ＝ 0并且 native_async = 0</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> AioImageRequestWQ::aio_read(AioCompletion *c, <span class="keyword">uint64_t</span> off, <span class="keyword">uint64_t</span> len,</div><div class="line">                                 <span class="keyword">char</span> *buf, bufferlist *pbl, <span class="keyword">int</span> op_flags,</div><div class="line">                                 <span class="keyword">bool</span> native_async) &#123;</div><div class="line"></div><div class="line">  c-&gt;init_time(&amp;m_image_ctx, librbd::AIO_TYPE_READ);  <span class="comment">// 这里m_image_ctx会引用aio_work_queue这里面的成员m_image_ctx。这里就是librbd::ImageCtx类型。</span></div><div class="line">  CephContext *cct = m_image_ctx.cct; <span class="comment">// 注意m_image_ctx里面会包含一个CephContext的指针。</span></div><div class="line"></div><div class="line">  <span class="comment">// 输出debut信息</span></div><div class="line">  ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">"aio_read: ictx="</span> &lt;&lt; &amp;m_image_ctx &lt;&lt; <span class="string">", "</span></div><div class="line">                 &lt;&lt; <span class="string">"completion="</span> &lt;&lt; c &lt;&lt; <span class="string">", off="</span> &lt;&lt; off &lt;&lt; <span class="string">", "</span></div><div class="line">                 &lt;&lt; <span class="string">"len="</span> &lt;&lt; len &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="string">"flags="</span> &lt;&lt; op_flags &lt;&lt; dendl;</div><div class="line"></div><div class="line">  <span class="comment">// 这里native_async为0</span></div><div class="line">  <span class="keyword">if</span> (native_async &amp;&amp; m_image_ctx.event_socket.is_valid()) &#123;</div><div class="line">    c-&gt;set_event_notify(<span class="literal">true</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!start_in_flight_op(c)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  RWLock::<span class="function">RLocker <span class="title">owner_locker</span><span class="params">(m_image_ctx.owner_lock)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// if journaling is enabled -- we need to replay the journal because</span></div><div class="line">  <span class="comment">// it might contain an uncommitted write</span></div><div class="line">  <span class="keyword">bool</span> lock_required;</div><div class="line">  &#123;</div><div class="line">    RWLock::<span class="function">RLocker <span class="title">locker</span><span class="params">(m_lock)</span></span>;</div><div class="line">    lock_required = m_require_lock_on_read;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (m_image_ctx.non_blocking_aio || writes_blocked() || !writes_empty() ||</div><div class="line">      lock_required) &#123;</div><div class="line">    <span class="built_in">queue</span>(<span class="keyword">new</span> AioImageRead&lt;&gt;(m_image_ctx, c, &#123;&#123;off, len&#125;&#125;, buf, pbl, op_flags));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    c-&gt;start_op();</div><div class="line">    AioImageRequest&lt;&gt;::aio_read(&amp;m_image_ctx, c, &#123;&#123;off, len&#125;&#125;, buf, pbl,</div><div class="line">                                op_flags);</div><div class="line">    finish_in_flight_op();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据结构的引用"><a href="#数据结构的引用" class="headerlink" title="数据结构的引用"></a>数据结构的引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">BDRVRBDState *s = bs-&gt;opaque;</div><div class="line"></div><div class="line"><span class="comment">// then</span></div><div class="line"><span class="keyword">void</span> *image = s-&gt;image;</div><div class="line"></div><div class="line">librbd::ImageCtx *ictx = (librbd::ImageCtx *)image;</div><div class="line"></div><div class="line"><span class="comment">// 然后在AioImageRequestWQ里面还有一个ImageCtx类，这个类的指针也是指同前面传进来的s-&gt;image这个image的地址。</span></div></pre></td></tr></table></figure>
<p>其他更加详细的数据结构的，需要看<code>rbd_aio_open</code>函数。总的来，这里可以看出来，<code>ImageCtx</code>应该是指向同一个数据结构。</p>
<h2 id="回调函数时间初始化"><a href="#回调函数时间初始化" class="headerlink" title="回调函数时间初始化"></a>回调函数时间初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// librbd/AioCompletion.cc</span></div><div class="line">  &gt;|<span class="number">129</span>       <span class="keyword">void</span> AioCompletion::init_time(ImageCtx *i, <span class="keyword">aio_type_t</span> t) &#123;                                                               |</div><div class="line">   |<span class="number">130</span>         Mutex::<span class="function">Locker <span class="title">locker</span><span class="params">(lock)</span></span>;                                                                                            |</div><div class="line">   |<span class="number">131</span>         <span class="keyword">if</span> (ictx == <span class="literal">nullptr</span>) &#123;   <span class="comment">// 刚进这里的时候，ictx为空                                                                      |</span></div><div class="line">   |<span class="number">132</span>           ictx = i;                                                                                                            |</div><div class="line">   |<span class="number">133</span>           aio_type = t;          <span class="comment">// RBD_AIO_READ                                                                               |</span></div><div class="line">   |<span class="number">134</span>           start_time = ceph_clock_now(ictx-&gt;cct);                                                                              |</div><div class="line">   |<span class="number">135</span>         &#125;                                                                                                                      |</div><div class="line">   |<span class="number">136</span>       &#125;</div></pre></td></tr></table></figure>
<p>当准备开始要读取数据的时候，首先从<code>librbd::AioCompletion</code>进行处理，最开始的处理，需要注意三方面：</p>
<ul>
<li>设置锁，在多线程的情况下，应该是为了防止对同一个指针比如ictx同时进行赋值。比如两个线程都发现这个回调指针为空的情况。</li>
<li>设置ictx指针，指向m_image_ctx。这个数据结构属于<code>librbd::AioCompletion</code>。</li>
<li>设置异步操作的类型，这里进来的时候，应该是<code>AIO_RBD_READ</code>。</li>
<li>设置操作开始的时间。需要注意的是，操作开始的时间是记录在回调函数的结构里面。</li>
</ul>
<h2 id="librbd-ImageCtx的内容"><a href="#librbd-ImageCtx的内容" class="headerlink" title="librbd::ImageCtx的内容"></a>librbd::ImageCtx的内容</h2><p>首先看一下指针指向的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">(gdb) print &amp;m_image_ctx</div><div class="line">$<span class="number">14</span> = (librbd::ImageCtx *) <span class="number">0x555556521b90</span></div></pre></td></tr></table></figure>
<p>这里可以查看一下<code>librbd::ImageCtx</code>的内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">$9 = (librbd::ImageCtx &amp;) @0x555556521b90: &#123;cct = 0x55555635a9b0, perfcounter = 0x7fffa00012a0, header = &#123;</div><div class="line">    text = '\000' &lt;repeats 39 times&gt;, block_name = '\000' &lt;repeats 23 times&gt;, signature = "\000\000\000",</div><div class="line">    version = "\000\000\000\000\000\000\000", options = &#123;order = 0 '\000', crypt_type = 0 '\000', comp_type = 0 '\000',</div><div class="line">      unused = 0 '\000'&#125;, image_size = &#123;v = 0&#125;, snap_seq = &#123;v = 0&#125;, snap_count = &#123;v = 0&#125;, reserved = &#123;v = 0&#125;, snap_names_len = &#123;</div><div class="line">      v = 0&#125;, snaps = 0x555556521c10&#125;, snapc = &#123;seq = &#123;val = 0&#125;, snaps = std::vector of length 0, capacity 0&#125;,</div><div class="line">  snaps = std::vector of length 0, capacity 0, snap_info = std::map with 0 elements, snap_ids = std::map with 0 elements,</div><div class="line">  snap_id = 18446744073709551614, snap_exists = true, read_only = false, flush_encountered = false, lockers = std::map with 0 elements</div><div class="line">    , exclusive_locked = true, lock_tag = "internal", name = "new-libvirt-image", snap_name = "", data_ctx = &#123;</div><div class="line">    io_ctx_impl = 0x555556522570&#125;, md_ctx = &#123;io_ctx_impl = 0x5555565223d0&#125;, image_watcher = 0x7fffa0004580, journal = 0x0,</div><div class="line">  owner_lock = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0,</div><div class="line">        __nr_writers_queued = 0, __writer = 0, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0&#125;, __size = '\000' &lt;repeats 55 times&gt;,</div><div class="line">      __align = 0&#125;, name = "librbd::ImageCtx::owner_lock (0x555556521b90)", id = -1, nrlock = &#123;val = 0&#125;, nwlock = &#123;val = 0&#125;,</div><div class="line">    track = true, lockdep = true&#125;, md_lock = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0,</div><div class="line">        __nr_readers_queued = 0, __nr_writers_queued = 0, __writer = 0, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0&#125;,</div><div class="line">      __size = '\000' &lt;repeats 55 times&gt;, __align = 0&#125;, name = "librbd::ImageCtx::md_lock (0x555556521b90)", id = -1, nrlock = &#123;</div><div class="line">      val = 0&#125;, nwlock = &#123;val = 0&#125;, track = true, lockdep = true&#125;, cache_lock = &#123;</div><div class="line">    name = "librbd::ImageCtx::cache_lock (0x555556521b90)", id = -1, recursive = false, lockdep = true, backtrace = false, _m = &#123;</div><div class="line">      __data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 1, __kind = 2, __spins = 0, __elision = 0, __list = &#123;__prev = 0x0,</div><div class="line">          __next = 0x0&#125;&#125;, __size = '\000' &lt;repeats 12 times&gt;, "\001\000\000\000\002", '\000' &lt;repeats 22 times&gt;, __align = 0&#125;,</div><div class="line">    nlock = 0, locked_by = 0, cct = 0x0, logger = 0x0&#125;, snap_lock = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0,</div><div class="line">        __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0, __nr_writers_queued = 0, __writer = 0, __shared = 0,</div><div class="line">        __pad1 = 0, __pad2 = 0, __flags = 0&#125;, __size = '\000' &lt;repeats 55 times&gt;, __align = 0&#125;,</div><div class="line">    name = "librbd::ImageCtx::snap_lock (0x555556521b90)", id = -1, nrlock = &#123;val = 0&#125;, nwlock = &#123;val = 0&#125;, track = true,</div><div class="line">    lockdep = true&#125;, parent_lock = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0,</div><div class="line">        __nr_readers_queued = 0, __nr_writers_queued = 0, __writer = 0, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0&#125;,</div><div class="line">      __size = '\000' &lt;repeats 55 times&gt;, __align = 0&#125;, name = "librbd::ImageCtx::parent_lock (0x555556521b90)", id = -1, nrlock = &#123;</div><div class="line">      val = 0&#125;, nwlock = &#123;val = 0&#125;, track = true, lockdep = true&#125;, object_map_lock = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0,</div><div class="line">        __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0, __nr_writers_queued = 0, __writer = 0, __shared = 0,</div><div class="line">        __pad1 = 0, __pad2 = 0, __flags = 0&#125;, __size = '\000' &lt;repeats 55 times&gt;, __align = 0&#125;,</div><div class="line">    name = "librbd::ImageCtx::object_map_lock (0x555556521b90)", id = -1, nrlock = &#123;val = 0&#125;, nwlock = &#123;val = 0&#125;, track = true,</div><div class="line">    lockdep = true&#125;, async_ops_lock = &#123;name = "librbd::ImageCtx::async_ops_lock (0x555556521b90)", id = -1, recursive = false,</div><div class="line">    lockdep = true, backtrace = false, _m = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 2, __spins = 0,</div><div class="line">        __elision = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;, __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;,</div><div class="line">      __align = 0&#125;, nlock = 0, locked_by = 0, cct = 0x0, logger = 0x0&#125;, copyup_list_lock = &#123;</div><div class="line">    name = "librbd::ImageCtx::copyup_list_lock (0x555556521b90)", id = -1, recursive = false, lockdep = true, backtrace = false, _m = &#123;</div><div class="line">      __data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 2, __spins = 0, __elision = 0, __list = &#123;__prev = 0x0,</div><div class="line">          __next = 0x0&#125;&#125;, __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;, __align = 0&#125;, nlock = 0,</div><div class="line">    locked_by = 0, cct = 0x0, logger = 0x0&#125;, completed_reqs_lock = &#123;name = "librbd::ImageCtx::completed_reqs_lock (0x555556521b90)",</div><div class="line">    id = -1, recursive = false, lockdep = true, backtrace = false, _m = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0,</div><div class="line">        __kind = 2, __spins = 0, __elision = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;,</div><div class="line">      __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;, __align = 0&#125;, nlock = 0, locked_by = 0, cct = 0x0,</div><div class="line">    logger = 0x0&#125;, extra_read_flags = 0, old_format = false, order = 22 '\026', size = 104857600, features = 61,</div><div class="line">  object_prefix = "rbd_data.102374b0dc51", format_string = 0x7fffa0001950 "rbd_data.102374b0dc51.%016llx",</div><div class="line">  header_oid = "rbd_header.102374b0dc51", id = "102374b0dc51", parent_md = &#123;spec = &#123;pool_id = -1, image_id = "", snap_id = &#123;</div><div class="line">        val = 18446744073709551614&#125;&#125;, overlap = 0&#125;, parent = 0x0, stripe_unit = 4194304, stripe_count = 1, flags = 0, layout = &#123;</div><div class="line">    stripe_unit = 4194304, stripe_count = 1, object_size = 4194304, pool_id = 0, pool_ns = ""&#125;, object_cacher = 0x7fffa0001340,</div><div class="line">  writeback_handler = 0x7fffa0002950, object_set = 0x7fffa0002400, readahead = &#123;static NO_LIMIT = 18446744073709551615,</div><div class="line">    m_trigger_requests = 10, m_readahead_min_bytes = 0, m_readahead_max_bytes = 524288,</div><div class="line">    m_alignments = std::vector of length 3, capacity 3 = &#123;4194304, 4194304, 4194304&#125;, m_lock = &#123;name = "Readahead::m_lock", id = -1,</div><div class="line">      recursive = false, lockdep = true, backtrace = false, _m = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0,</div><div class="line">          __kind = 2, __spins = 0, __elision = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;,</div><div class="line">        __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;, __align = 0&#125;, nlock = 0, locked_by = 0, cct = 0x0,</div><div class="line">      logger = 0x0&#125;, m_nr_consec_read = 0, m_consec_read_bytes = 0, m_last_pos = 0, m_readahead_pos = 0, m_readahead_trigger_pos = 0,</div><div class="line">    m_readahead_size = 0, m_pending = 0, m_pending_lock = &#123;name = "Readahead::m_pending_lock", id = -1, recursive = false,</div><div class="line">      lockdep = true, backtrace = false, _m = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 2, __spins = 0,</div><div class="line">          __elision = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;,</div><div class="line">        __size = '\000' &lt;repeats 16 times&gt;, "\002", '\000' &lt;repeats 22 times&gt;, __align = 0&#125;, nlock = 0, locked_by = 0, cct = 0x0,</div><div class="line">      logger = 0x0&#125;, m_pending_waiting = empty std::list&#125;, total_bytes_read = 0, copyup_list = std::map with 0 elements, async_ops = &#123;</div><div class="line">    _front = 0x0, _back = 0x0, _size = 0&#125;, async_requests = &#123;_front = 0x0, _back = 0x0, _size = 0&#125;,</div><div class="line">  async_requests_waiters = empty std::list, state = 0x555556523cb0, operations = 0x555556524df0, exclusive_lock = 0x7fffa0001b50,</div><div class="line">  object_map = 0x0, resize_reqs = &#123;_front = 0x0, _back = 0x0, _size = 0&#125;, aio_work_queue = 0x555556527e70, completed_reqs = &#123;</div><div class="line">    _front = 0x0, _back = 0x0, _size = 0&#125;, event_socket = &#123;socket = -1, type = 0&#125;, op_work_queue = 0x555556528060,</div><div class="line">  static METADATA_CONF_PREFIX = "conf_", non_blocking_aio = true, cache = true, cache_writethrough_until_flush = true,</div><div class="line">  cache_size = 33554432, cache_max_dirty = 25165824, cache_target_dirty = 16777216, cache_max_dirty_age = 1,</div><div class="line">  cache_max_dirty_object = 0, cache_block_writes_upfront = false, concurrent_management_ops = 10, balance_snap_reads = false,</div><div class="line">  localize_snap_reads = false, balance_parent_reads = false, localize_parent_reads = true, readahead_trigger_requests = 10,</div><div class="line">  readahead_max_bytes = 524288, readahead_disable_after_bytes = 52428800, clone_copy_on_read = false, blacklist_on_break_lock = true,</div><div class="line">  blacklist_expire_seconds = 0, request_timed_out_seconds = 30, enable_alloc_hint = true, journal_order = 24 '\030',</div><div class="line">  journal_splay_width = 4 '\004', journal_commit_age = 5, journal_object_flush_interval = 0, journal_object_flush_bytes = 0,</div><div class="line">  journal_object_flush_age = 0, journal_pool = "", asok_hook = 0x7fffa0002600, exclusive_lock_policy = 0x555556523d80,</div><div class="line">  journal_policy = 0x555556528190&#125;</div></pre></td></tr></table></figure>
<h2 id="CephContext的内容"><a href="#CephContext的内容" class="headerlink" title="CephContext的内容"></a>CephContext的内容</h2><p>首先看一下指针指向的地址：<code>$12 = (CephContext *) 0x55555635a9b0</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">$11 = &#123;nref = &#123;val = 1&#125;, _conf = 0x5555564c5f60, _log = 0x5555564c9a60, _module_type = 8, _init_flags = 0, _set_uid = 0, _set_gid = 0,</div><div class="line">  _set_uid_string = "", _set_gid_string = "", _crypto_inited = true, _service_thread = 0x555556519aa0, _log_obs = 0x55555635a7e0,</div><div class="line">  _admin_socket = 0x5555564ca5c0, _service_thread_lock = &#123;lock = 1&#125;, _perf_counters_collection = 0x5555564ca4e0,</div><div class="line">  _perf_counters_conf_obs = 0x0, _admin_hook = 0x5555564c8ce0, _heartbeat_map = 0x5555564ca790, _associated_objs_lock = &#123;lock = 1&#125;,</div><div class="line">  _associated_objs = std::map with 4 elements = &#123;["librados_tp.so"] = 0x5555564cced0,</div><div class="line">    ["librbd::TaskFinisher::m_safe_timer"] = 0x7fffa00029b0, ["librbd::thread_pool"] = 0x55555651a180,</div><div class="line">    ["librbd_tp.so"] = 0x555556524dd0&#125;, _crypto_none = 0x5555564cca20, _crypto_aes = 0x5555564cca40, _cct_obs = 0x5555564c8f70,</div><div class="line">  _feature_lock = &#123;lock = 1&#125;, _experimental_features = std::set with 0 elements, _plugin_registry = 0x5555564ca870,</div><div class="line">  _lockdep_obs = 0x55555635cae0, crush_location = &#123;cct = 0x55555635a9b0, loc = std::multimap with 0 elements,</div><div class="line">    lock = &#123;&lt;std::__mutex_base&gt; = &#123;_M_mutex = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0, __kind = 0, __spins = 0,</div><div class="line">            __elision = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;, __size = '\000' &lt;repeats 39 times&gt;,</div><div class="line">          __align = 0&#125;&#125;, &lt;No data fields&gt;&#125;&#125;, _cct_perf = 0x0, _cct_perf_lock = &#123;lock = 1&#125;&#125;</div></pre></td></tr></table></figure>
<h2 id="start-in-flight-op"><a href="#start-in-flight-op" class="headerlink" title="start_in_flight_op()"></a>start_in_flight_op()</h2><p>函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">&gt;|<span class="number">393</span>     <span class="keyword">int</span> AioImageRequestWQ::start_in_flight_op(AioCompletion *c) &#123;                                                              |</div><div class="line"> |<span class="number">394</span>       RWLock::<span class="function">RLocker <span class="title">locker</span><span class="params">(m_lock)</span></span>;                                                                                          |</div><div class="line"> |<span class="number">395</span>                                                                                                                                |</div><div class="line"> |<span class="number">396</span>       <span class="keyword">if</span> (m_shutdown) &#123;                                                                                                        |</div><div class="line"> |<span class="number">397</span>         CephContext *cct = m_image_ctx.cct;                                                                                    |</div><div class="line"> |<span class="number">398</span>         lderr(cct) &lt;&lt; <span class="string">"IO received on closed image"</span> &lt;&lt; dendl;                                                                  |</div><div class="line"> |<span class="number">399</span>                                                                                                                                |</div><div class="line"> |<span class="number">400</span>         c-&gt;fail(-ESHUTDOWN);                                                                                                   |</div><div class="line"> |<span class="number">401</span>         <span class="keyword">return</span> <span class="literal">false</span>;                                                                                                          |</div><div class="line"> |<span class="number">402</span>       &#125;                                                                                                                        |</div><div class="line"> |<span class="number">403</span>                                                                                                                                |</div><div class="line"> |<span class="number">404</span>       m_in_flight_ops.inc();                                                                                                   |</div><div class="line"> |<span class="number">405</span>       <span class="keyword">return</span> <span class="literal">true</span>;                                                                                                             |</div><div class="line"> |<span class="number">406</span>     &#125;</div></pre></td></tr></table></figure>
<h3 id="磁盘已关闭"><a href="#磁盘已关闭" class="headerlink" title="磁盘已关闭"></a>磁盘已关闭</h3><p>当获取锁之后，直接看一下是否要<code>m_shutdown</code>。由于现在第一个开始准备读，那么<code>m_shutdown</code>肯定为<code>false</code>。所以在这里实际上会跳过<code>if(){}</code>语句，如果要关闭，那么这里就直接调用<code>c-&gt;fail()</code>。</p>
<h3 id="m-in-flight-ops"><a href="#m-in-flight-ops" class="headerlink" title="m_in_flight_ops()"></a>m_in_flight_ops()</h3><p>在这个函数里面开始计数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> |<span class="number">100</span>     <span class="keyword">namespace</span> ceph &#123;                                                                                                           |</div><div class="line"> |<span class="number">101</span>       <span class="keyword">class</span> <span class="keyword">atomic_t</span> &#123;            <span class="comment">// &lt;----注意这里是定义了atomic_t                                                                |</span></div><div class="line"> |<span class="number">102</span>         AO_t val;                                                                                                              |</div><div class="line"> |<span class="number">103</span>       <span class="keyword">public</span>:                                                                                                                  |</div><div class="line"> |<span class="number">104</span>         <span class="keyword">atomic_t</span>(AO_t i=<span class="number">0</span>) : val(i) &#123;&#125;                                                                                         |</div><div class="line"> |<span class="number">105</span>         <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(AO_t v)</span> </span>&#123;                                                                                                     |</div><div class="line"> |<span class="number">106</span>           AO_store(&amp;val, v);                                                                                                   |</div><div class="line"> |<span class="number">107</span>         &#125;                                                                                                                      |</div><div class="line"> |<span class="number">108</span>         <span class="function">AO_t <span class="title">inc</span><span class="params">()</span> </span>&#123;                                                                                                           |</div><div class="line">&gt;|<span class="number">109</span>           <span class="keyword">return</span> AO_fetch_and_add1(&amp;val) + <span class="number">1</span>;                                                                                  |</div><div class="line"> |<span class="number">110</span>         &#125;</div></pre></td></tr></table></figure>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>那么接下来获取读写锁中读锁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">RWLock::<span class="function">RLocker <span class="title">owner_locker</span><span class="params">(m_image_ctx.owner_lock)</span></span>;</div></pre></td></tr></table></figure>
<p>获取成功之后，还会进入当前类里面的读锁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">113</span>       <span class="comment">// if journaling is enabled -- we need to replay the journal because                                                     |</span></div><div class="line">|<span class="number">114</span>       <span class="comment">// it might contain an uncommitted write                                                                                 |</span></div><div class="line">|<span class="number">115</span>       <span class="keyword">bool</span> lock_required;                                                                                                      |</div><div class="line">|<span class="number">116</span>       &#123;                                                                                                                        |</div><div class="line">|<span class="number">117</span>         RWLock::<span class="function">RLocker <span class="title">locker</span><span class="params">(m_lock)</span></span>;     <span class="comment">// m_lock is member in AioImageRequestWQ                                           |</span></div><div class="line">|<span class="number">118</span>         lock_required = m_require_lock_on_read;   <span class="comment">// debug here is false                                                       |</span></div><div class="line">|<span class="number">119</span>       &#125;</div></pre></td></tr></table></figure>
<p>这里使用的<code>m_lock</code>是<code>AioImageRequestWQ</code>当前这个类的锁。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">(gdb) print m_lock</div><div class="line">$16 = &#123;L = &#123;__data = &#123;__lock = 0, __nr_readers = 0, __readers_wakeup = 0, __writer_wakeup = 0, __nr_readers_queued = 0,</div><div class="line">      __nr_writers_queued = 0, __writer = 0, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0&#125;, __size = '\000' &lt;repeats 55 times&gt;,</div><div class="line">    __align = 0&#125;, name = "AioImageRequestWQ::m_lock (0x555556527e70)", id = -1, nrlock = &#123;val = 0&#125;, nwlock = &#123;val = 0&#125;, track = true,</div><div class="line">  lockdep = true&#125;</div></pre></td></tr></table></figure>
<p>注意变量的值<code>m_require_lock_on_read = false</code>。</p>
<h2 id="队列的处理"><a href="#队列的处理" class="headerlink" title="队列的处理"></a>队列的处理</h2><p>接下来的操作，需要看一下是否需要：放到队列中去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">&gt;|<span class="number">121</span>       <span class="keyword">if</span> (m_image_ctx.non_blocking_aio || writes_blocked() || !writes_empty() ||                                               |</div><div class="line"> |<span class="number">122</span>           lock_required) &#123;                                                                                                     |</div><div class="line"> |<span class="number">123</span>         <span class="built_in">queue</span>(<span class="keyword">new</span> AioImageRead(m_image_ctx, c, off, len, buf, pbl, op_flags));  <span class="comment">// &lt;--  AioImageRead()                         |</span></div><div class="line"> |<span class="number">124</span>       &#125; <span class="keyword">else</span> &#123;                                                                                                                 |</div><div class="line"> |<span class="number">125</span>         AioImageRequest&lt;&gt;::aio_read(&amp;m_image_ctx, c, off, len, buf, pbl, op_flags);                                            |</div><div class="line"> |<span class="number">126</span>         finish_in_flight_op();                                                                                                 |</div><div class="line"> |<span class="number">127</span>       &#125;                                                                                                                        |</div><div class="line"> |<span class="number">128</span>     &#125;</div></pre></td></tr></table></figure>
<p>在决定看这段逻辑之前，看一下这几个变量的含义：</p>
<ul>
<li>m_image_ctx.non_blocking_aio如果是非阻塞型IO。在<code>debug</code>的时候，输出为真。</li>
<li>writes_blocked()</li>
<li>!writes_empty()</li>
<li>lock_required</li>
</ul>
<p>由于第一个条件为真，所以是肯定会掉到<code>queue</code>里面去的。</p>
<h2 id="AioImageRead"><a href="#AioImageRead" class="headerlink" title="AioImageRead"></a>AioImageRead</h2><p>可以看出来，磁盘读取操作的时候，就是按着如下的顺序：</p>
<ul>
<li>生成/获取<code>ImageCtx</code></li>
<li>从<code>ImageCtx</code>中拿到<code>AioImageRequestWQ</code>，也就是<code>异步磁盘请求队列</code>。</li>
<li>把<code>AioImageRead</code>请求放到<code>队列</code>中。</li>
</ul>
<p>后面在处理的时候，就需要注意看一下这个队列是如何处理这个请求的。应该是有一个专门的线程在处理这个。在讨论线程之前，先看一下是如何生成<code>AioImageRead</code>这个类的。</p>
<h3 id="类的生成"><a href="#类的生成" class="headerlink" title="类的生成"></a>类的生成</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">queue</span>(<span class="keyword">new</span> AioImageRead(m_image_ctx, c, off, len, buf, pbl, op_flags));</div></pre></td></tr></table></figure>
<p>这里使用new来生成一个<code>AioImageRead</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">AioImageRead (op_flags=<span class="number">0</span>, pbl=<span class="number">0x0</span>, buf=<span class="number">0x5555564c5400</span> <span class="string">"xM4\342\377\177"</span>, len=<span class="number">2048</span>, off=<span class="number">0</span>, aio_comp=<span class="number">0x5555565281f0</span>, image_ctx=...,</div><div class="line">    <span class="keyword">this</span>=<span class="number">0x55555651ef20</span>) at librbd/AioImageRequestWQ.cc:<span class="number">123</span></div></pre></td></tr></table></figure>
<p>调用构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">./librbd/AioImageRequest.h</div><div class="line">   |<span class="number">64</span>      <span class="keyword">class</span> AioImageRead : <span class="keyword">public</span> AioImageRequest&lt;&gt; &#123;                                                                            |</div><div class="line">   |<span class="number">65</span>      <span class="keyword">public</span>:                                                                                                                    |</div><div class="line">   |<span class="number">66</span>        AioImageRead(ImageCtx &amp;image_ctx, AioCompletion *aio_comp, <span class="keyword">uint64_t</span> off,                                                 |</div><div class="line">   |<span class="number">67</span>                     <span class="keyword">size_t</span> len, <span class="keyword">char</span> *buf, bufferlist *pbl, <span class="keyword">int</span> op_flags)                                                       |</div><div class="line">   |<span class="number">68</span>          : AioImageRequest(image_ctx, aio_comp), m_buf(buf), m_pbl(pbl),                                                        |</div><div class="line">   |<span class="number">69</span>            m_op_flags(op_flags) &#123;                                                                                               |</div><div class="line">  &gt;|<span class="number">70</span>          m_image_extents.push_back(<span class="built_in">std</span>::make_pair(off, len));                                                                   |</div><div class="line">   |<span class="number">71</span>        &#125;</div></pre></td></tr></table></figure>
<p>有意思的是，在这个构造函数里面，传入了几个重要的指针：</p>
<ul>
<li>ImageCtx</li>
<li>AioCompletion</li>
<li><code>off -&gt; 0</code></li>
<li><code>size -&gt; 2048</code></li>
<li>bufferlist<br>这里可以说一下<code>bufferlist</code>是指向上一节里面生成的<code>acb-&gt;bounce</code>内存缓冲区。回顾一下，这个内存缓冲区，主要是利用<code>qemu_alignment(unit, total_size)</code>来生成的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">acb-&gt;bounce = qemu_blockalign(bs, qiov-&gt;size); <span class="comment">// 分配size大小的内存，但是必须要是按照bs-&gt;bl.alignment里面的2^x倍数对齐。</span></div></pre></td></tr></table></figure>
<ul>
<li>op_flags (0)</li>
</ul>
<p>生成的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">librbd::AioImageRequestWQ::aio_read (<span class="keyword">this</span>=<span class="number">0x555556527e70</span>, c=c@entry=<span class="number">0x5555565281f0</span>, off=off@entry=<span class="number">0</span>, len=len@entry=<span class="number">2048</span>,</div><div class="line">    buf=buf@entry=<span class="number">0x5555564c5400</span> <span class="string">"xM4\342\377\177"</span>, pbl=pbl@entry=<span class="number">0x0</span>, op_flags=op_flags@entry=<span class="number">0</span>, native_async=native_async@entry=<span class="literal">true</span>)</div><div class="line">    at librbd/AioImageRequestWQ.cc:<span class="number">123</span></div></pre></td></tr></table></figure>
<h3 id="放入Queue"><a href="#放入Queue" class="headerlink" title="放入Queue"></a>放入Queue</h3><p>接下来便是把这个<code>AioImageRead</code>类放到<code>Queue</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> +--librbd/AioImageRequestWQ.cc------------------------------------------------------------------------------------------------------+</div><div class="line">&gt;|<span class="number">433</span>     <span class="keyword">void</span> AioImageRequestWQ::<span class="built_in">queue</span>(AioImageRequest&lt;&gt; *req) &#123;                                                                    |</div><div class="line"> |<span class="number">434</span>       CephContext *cct = m_image_ctx.cct;                                                                                      |</div><div class="line"> |<span class="number">435</span>       ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">": ictx="</span> &lt;&lt; &amp;m_image_ctx &lt;&lt; <span class="string">", "</span>                                                          |</div><div class="line"> |<span class="number">436</span>                      &lt;&lt; <span class="string">"req="</span> &lt;&lt; req &lt;&lt; dendl;                                                                                |</div><div class="line"> |<span class="number">437</span>                                                                                                                                |</div><div class="line"> |<span class="number">438</span>       assert(m_image_ctx.owner_lock.is_locked());                                                                              |</div><div class="line"> |<span class="number">439</span>       <span class="keyword">bool</span> write_op = req-&gt;is_write_op();                                                                                      |</div><div class="line"> |<span class="number">440</span>       <span class="keyword">if</span> (write_op) &#123;                                                                                                          |</div><div class="line"> |<span class="number">441</span>         m_queued_writes.inc();                                                                                                 |</div><div class="line"> |<span class="number">442</span>       &#125; <span class="keyword">else</span> &#123;                                                                                                                 |</div><div class="line"> |<span class="number">443</span>         m_queued_reads.inc();                                                                                                  |</div><div class="line"> |<span class="number">444</span>       &#125;                                                                                                                        |</div><div class="line"> |<span class="number">445</span>                                                                                                                                |</div><div class="line"> |<span class="number">446</span>       ThreadPool::PointerWQ&lt;AioImageRequest&lt;&gt; &gt;::<span class="built_in">queue</span>(req);   <span class="comment">// 这里调用父类的方法                                              |</span></div><div class="line"> |<span class="number">447</span>                                                                                                                                |</div><div class="line"> |<span class="number">448</span>       <span class="keyword">if</span> ((write_op &amp;&amp; is_lock_required()) ||                                                                                  |</div><div class="line"> |<span class="number">449</span>           (!write_op &amp;&amp; m_require_lock_on_read)) &#123;                                                                             |</div><div class="line"> |<span class="number">450</span>         m_image_ctx.exclusive_lock-&gt;request_lock(<span class="literal">nullptr</span>);                                                                     |</div><div class="line"> |<span class="number">451</span>       &#125;                                                                                                                        |</div><div class="line"> |<span class="number">452</span>     &#125;</div></pre></td></tr></table></figure>
<p>这里在放到<code>queue</code>的时候，会依次进行如下操作：</p>
<ul>
<li>拿到<code>ImageCtx</code>的锁，获得这个<code>ImageCtx</code>的锁。</li>
<li>查看是读/写操作，分别对相应的操作进行计数。比如这里还是第一个进来的读请求，计数肯定是为0。<code>(gdb) print m_queued_reads
$10 = {val = 0}</code></li>
<li>放到<code>ThreadPool::PointerWQ&lt;AioImageRequest&lt;&gt; &gt;::queue</code>操作队列中。</li>
<li>放置完成之后，如果是写操作，那么还是需要对锁做一下进一步的处理。</li>
</ul>
<p>需要注意的是，这里父类是：<code>ThreadPool::PointerWQ&lt;AioImageRequest&lt;&gt; &gt;</code>也就是说里面的元素本该是<code>AioImageRequest&lt;&gt;</code>。但是前面构造出来的放到<code>queue</code>里面的元素却是:<code>AioImageRead</code>。这是因为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> AioImageRead : <span class="keyword">public</span> AioImageRequest&lt;&gt; &#123; <span class="comment">// 类AioImageRead继承于AioImageRequest&lt;&gt;</span></div><div class="line">   ....</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="CommonQueue"><a href="#CommonQueue" class="headerlink" title="CommonQueue"></a>CommonQueue</h4><p>接下来，就是介绍最核心的部分，也就是将操作真正放到Queue里面的处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">./common/WorkQueue.h</div><div class="line">   |<span class="number">363</span>         <span class="function"><span class="keyword">void</span> <span class="title">queue</span><span class="params">(T *item)</span> </span>&#123;                                                                                                  |</div><div class="line">  &gt;|<span class="number">364</span>           Mutex::<span class="function">Locker <span class="title">l</span><span class="params">(m_pool-&gt;<span class="number">_l</span>ock)</span></span>;                                                                                      |</div><div class="line">   |<span class="number">365</span>           m_items.push_back(item);                                                                                             |</div><div class="line">   |<span class="number">366</span>           m_pool-&gt;<span class="number">_</span>cond.SignalOne();                                                                                           |</div><div class="line">   |<span class="number">367</span>         &#125;</div></pre></td></tr></table></figure>
<p><code>m_items</code>就是一个<code>list</code>。下面看一下<code>SignalOne()</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">./common/Cond.h</div><div class="line">   |<span class="number">110</span>       <span class="function"><span class="keyword">int</span> <span class="title">SignalOne</span><span class="params">()</span> </span>&#123;                                                                                                        |</div><div class="line">   |<span class="number">111</span>         <span class="comment">// make sure signaler is holding the waiter's lock.                                                                    |</span></div><div class="line">  &gt;|<span class="number">112</span>         assert(waiter_mutex == <span class="literal">NULL</span> ||                                                                                         |</div><div class="line">   |<span class="number">113</span>                waiter_mutex-&gt;is_locked());                                                                                     |</div><div class="line">   |<span class="number">114</span>                                                                                                                                |</div><div class="line">   |<span class="number">115</span>         <span class="keyword">int</span> r = pthread_cond_signal(&amp;<span class="number">_</span>c);                                                                                      |</div><div class="line">   |<span class="number">116</span>         <span class="keyword">return</span> r;                                                                                                              |</div><div class="line">   |<span class="number">117</span>       &#125;</div></pre></td></tr></table></figure>
<p>使用<code>pthread_cond_signal</code>生成一个信号。然再把结果返回。</p>
<h3 id="线程的处理"><a href="#线程的处理" class="headerlink" title="线程的处理"></a>线程的处理</h3><p>注意这段类之间的继承关系：</p>
<p><img src="/blog/img/ceph-rbd-debug/classlibrbd_1_1AioImageRequestWQ__inherit__graph.png" alt=""></p>
<p>首先看加入的Queue的类AioImageRequestWQ的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 可以看出来，这个Queue是一个线程池的子类。</span></div><div class="line"><span class="comment">// 也就是说，丢入到这个Queue里面的数据，会被线程所处理。</span></div><div class="line"><span class="keyword">class</span> AioImageRequestWQ : <span class="keyword">protected</span> ThreadPool::PointerWQ&lt;AioImageRequest&lt;ImageCtx&gt; &gt; &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AioImageRequestWQ继承于PointerWQ。其中<code>queue</code>的代码，直接继承<code>PointerWQ</code>的<code>queue</code>代码。可以看到，入Qeueu操作，比较简单，实际上就是在std::list&lt;&gt;m_items里面添加了一项，并且是采用是记录指针的方式（避免写入数据的多次复制。）</p>
<p>加入Queue之后，由于这个Queue是一个线程池：线程处理函数位于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> AioImageRequestWQ::process(AioImageRequest&lt;&gt; *req) &#123;</div><div class="line"><span class="comment">// .. 将写请求发送出去。</span></div><div class="line">  &#123;</div><div class="line">    RWLock::<span class="function">RLocker <span class="title">owner_locker</span><span class="params">(m_image_ctx.owner_lock)</span></span>;</div><div class="line">    req-&gt;send();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="comment">// ... 做后继的清理工作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>接下来便开始准备把请求发送出去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">file: librbd/AioImageRequestWQ.cc</div><div class="line">   |<span class="number">346</span>     <span class="keyword">void</span> AioImageRequestWQ::process(AioImageRequest&lt;&gt; *req) &#123;                                                                  |</div><div class="line">   |<span class="number">347</span>       CephContext *cct = m_image_ctx.cct;                                                                                      |</div><div class="line">B+&gt;|<span class="number">348</span>       ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="number">__f</span>unc__ &lt;&lt; <span class="string">": ictx="</span> &lt;&lt; &amp;m_image_ctx &lt;&lt; <span class="string">", "</span>                                                          |</div><div class="line">   |<span class="number">349</span>                      &lt;&lt; <span class="string">"req="</span> &lt;&lt; req &lt;&lt; dendl;                                                                                |</div><div class="line">   |<span class="number">350</span>                                                                                                                                |</div><div class="line">   |<span class="number">351</span>       &#123;                                                                                                                        |</div><div class="line">   |<span class="number">352</span>         RWLock::<span class="function">RLocker <span class="title">owner_locker</span><span class="params">(m_image_ctx.owner_lock)</span></span>;                                                                  |</div><div class="line">   |<span class="number">353</span>         req-&gt;send();   <span class="comment">// 真正的发送操作                                                                                         |</span></div><div class="line">   |<span class="number">354</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">355</span>                                                                                                                                |</div><div class="line">   |<span class="number">356</span>       finish_queued_op(req);                                                                                                   |</div><div class="line">   |<span class="number">357</span>       <span class="keyword">if</span> (req-&gt;is_write_op()) &#123;                                                                                                |</div><div class="line">   |<span class="number">358</span>         finish_in_progress_write();                                                                                            |</div><div class="line">   |<span class="number">359</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">360</span>       <span class="keyword">delete</span> req;                                                                                                              |</div><div class="line">   |<span class="number">361</span>                                                                                                                                |</div><div class="line">   |<span class="number">362</span>       finish_in_flight_op();                                                                                                   |</div><div class="line">   |<span class="number">363</span>     &#125;</div></pre></td></tr></table></figure>
<p>接下来就进入到真正的发送动作。这里采用的是将发送动作写在<code>Request</code>类里面，所以这里进入到<code>AioImageRequest</code>类的<code>send</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">librbd/AioImageRequest.cc</div><div class="line">   |<span class="number">130</span>     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;                                                                                                      |</div><div class="line">  &gt;|<span class="number">131</span>     <span class="keyword">void</span> AioImageRequest&lt;I&gt;::send() &#123;                                                                                          |</div><div class="line">   |<span class="number">132</span>       assert(m_image_ctx.owner_lock.is_locked());                                                                              |</div><div class="line">   |<span class="number">133</span>                                                                                                                                |</div><div class="line">   |<span class="number">134</span>       CephContext *cct = m_image_ctx.cct;                                                                                      |</div><div class="line">   |<span class="number">135</span>       ldout(cct, <span class="number">20</span>) &lt;&lt; get_request_type() &lt;&lt; <span class="string">": ictx="</span> &lt;&lt; &amp;m_image_ctx &lt;&lt; <span class="string">", "</span>                                                |</div><div class="line">   |<span class="number">136</span>                      &lt;&lt; <span class="string">"completion="</span> &lt;&lt; m_aio_comp &lt;&lt;  dendl;                                                                 |</div><div class="line">   |<span class="number">137</span>                                                                                                                                |</div><div class="line">   |<span class="number">138</span>       m_aio_comp-&gt;get();                                                                                                       |</div><div class="line">   |<span class="number">139</span>       send_request();                                                                                                          |</div><div class="line">   |<span class="number">140</span>     &#125;</div></pre></td></tr></table></figure>
<p>在发送读操作的时候，首先去<code>m_aio_comp</code>即<code>librbd::AioCompletion</code>那里拿个锁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ./librbd/AioCompletion.h</span></div><div class="line">   |<span class="number">146</span>         <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;                                                                                                           |</div><div class="line">  &gt;|<span class="number">147</span>           lock.Lock();                                                                                                         |</div><div class="line">   |<span class="number">148</span>           assert(ref &gt; <span class="number">0</span>);      <span class="comment">// ref 初始值为1                                                                                |</span></div><div class="line">   |<span class="number">149</span>           ref++;                                                                                                               |</div><div class="line">   |<span class="number">150</span>           lock.Unlock();                                                                                                       |</div><div class="line">   |<span class="number">151</span>         &#125;</div></pre></td></tr></table></figure>
<p>当锁拿到之后，开始利用<code>send_request()</code>发送请求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file: librbd/AioImageRequest.cc</span></div><div class="line">   |<span class="number">148</span>     <span class="keyword">void</span> AioImageRead::send_request() &#123;                                                                                        |</div><div class="line">  &gt;|<span class="number">149</span>       CephContext *cct = m_image_ctx.cct;                                                                                      |</div><div class="line">   |<span class="number">150</span>                                                                                                                                |</div><div class="line">   |<span class="number">151</span>       <span class="keyword">if</span> (m_image_ctx.object_cacher &amp;&amp; m_image_ctx.readahead_max_bytes &gt; <span class="number">0</span> &amp;&amp;                                                  |</div><div class="line">   |<span class="number">152</span>           !(m_op_flags &amp; LIBRADOS_OP_FLAG_FADVISE_RANDOM)) &#123;                                                                   |</div><div class="line">   |<span class="number">153</span>         readahead(&amp;m_image_ctx, m_image_extents);                                                                              |</div><div class="line">   |<span class="number">154</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">155</span>                                                                                                                                |</div><div class="line">   |<span class="number">156</span>       librados::<span class="keyword">snap_t</span> snap_id;                                                                                                |</div><div class="line">   |<span class="number">157</span>       <span class="built_in">map</span>&lt;<span class="keyword">object_t</span>,<span class="built_in">vector</span>&lt;ObjectExtent&gt; &gt; object_extents;                                                                      |</div><div class="line">   |<span class="number">158</span>       <span class="keyword">uint64_t</span> buffer_ofs = <span class="number">0</span>;                                                                                                 |</div><div class="line">   |<span class="number">159</span>       &#123;                                                                                                                        |</div><div class="line">   |<span class="number">160</span>         <span class="comment">// prevent image size from changing between computing clip and recording                                               |</span></div><div class="line">   |<span class="number">161</span>         <span class="comment">// pending async operation                                                                                             |</span></div><div class="line">   |<span class="number">162</span>         RWLock::<span class="function">RLocker <span class="title">snap_locker</span><span class="params">(m_image_ctx.snap_lock)</span></span>;                                                                    |</div><div class="line">   |<span class="number">163</span>         snap_id = m_image_ctx.snap_id;</div><div class="line">   |<span class="number">164</span>                                                                                                                                |</div><div class="line">   |<span class="number">165</span>         <span class="comment">// map                                                                                                                 |</span></div><div class="line">   |<span class="number">166</span>         <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">uint64_t</span>,<span class="keyword">uint64_t</span>&gt; &gt;::const_iterator p =                                                              |</div><div class="line">   |<span class="number">167</span>                m_image_extents.begin();                                                                                        |</div><div class="line">   |<span class="number">168</span>              p != m_image_extents.end(); ++p) &#123;                                                                                |</div><div class="line">   |<span class="number">169</span>           <span class="keyword">uint64_t</span> len = p-&gt;second;                                                                                            |</div><div class="line">   |<span class="number">170</span>           <span class="keyword">int</span> r = clip_io(&amp;m_image_ctx, p-&gt;first, &amp;len);                                                                       |</div><div class="line">   |<span class="number">171</span>           <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;                                                                                                         |</div><div class="line">   |<span class="number">172</span>             m_aio_comp-&gt;fail(r);                                                                                               |</div><div class="line">   |<span class="number">173</span>             <span class="keyword">return</span>;                                                                                                            |</div><div class="line">   |<span class="number">174</span>           &#125;                                                                                                                    |</div><div class="line">   |<span class="number">175</span>           <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;                                                                                                      |</div><div class="line">   |<span class="number">176</span>             <span class="keyword">continue</span>;                                                                                                          |</div><div class="line">   |<span class="number">177</span>           &#125;                                                                                                                    |</div><div class="line">   |<span class="number">178</span>                                                                                                                                |</div><div class="line">   |<span class="number">179</span>           Striper::file_to_extents(cct, m_image_ctx.format_string,                                                             |</div><div class="line">   |<span class="number">180</span>                                    &amp;m_image_ctx.layout, p-&gt;first, len, <span class="number">0</span>,                                                      |</div><div class="line">   |<span class="number">181</span>                                    object_extents, buffer_ofs);                                                                |</div><div class="line">   |<span class="number">182</span>           buffer_ofs += len;                                                                                                   |</div><div class="line">   |<span class="number">183</span>         &#125;                                                                                                                      |</div><div class="line">   |<span class="number">184</span>       &#125;</div><div class="line">   |<span class="number">185</span>                                                                                                                                |</div><div class="line">   |<span class="number">186</span>       m_aio_comp-&gt;read_buf = m_buf;                                                                                            |</div><div class="line">   |<span class="number">187</span>       m_aio_comp-&gt;read_buf_len = buffer_ofs;                                                                                   |</div><div class="line">   |<span class="number">188</span>       m_aio_comp-&gt;read_bl = m_pbl;                                                                                             |</div><div class="line">   |<span class="number">189</span>                                                                                                                                |</div><div class="line">   |<span class="number">190</span>       <span class="comment">// pre-calculate the expected number of read requests                                                                    |</span></div><div class="line">   |<span class="number">191</span>       <span class="keyword">uint32_t</span> request_count = <span class="number">0</span>;                                                                                              |</div><div class="line">   |<span class="number">192</span>       <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;object_extent : object_extents) &#123;                                                                             |</div><div class="line">   |<span class="number">193</span>         request_count += object_extent.second.size();                                                                          |</div><div class="line">   |<span class="number">194</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">195</span>       m_aio_comp-&gt;set_request_count(request_count);                                                                            |</div><div class="line">   |<span class="number">196</span>                                                                                                                                |</div><div class="line">   |<span class="number">197</span>       <span class="comment">// issue the requests                                                                                                    |</span></div><div class="line">   |<span class="number">198</span>       <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;object_extent : object_extents) &#123;                                                                             |</div><div class="line">   |<span class="number">199</span>         <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;extent : object_extent.second) &#123;                                                                            |</div><div class="line">   |<span class="number">200</span>           ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">" oid "</span> &lt;&lt; extent.oid &lt;&lt; <span class="string">" "</span> &lt;&lt; extent.offset &lt;&lt; <span class="string">"~"</span>                                               |</div><div class="line">   |<span class="number">201</span>                          &lt;&lt; extent.length &lt;&lt; <span class="string">" from "</span> &lt;&lt; extent.buffer_extents                                                 |</div><div class="line">   |<span class="number">202</span>                          &lt;&lt; dendl;</div><div class="line">   |<span class="number">203</span>                                                                                                                                |</div><div class="line">   |<span class="number">204</span>           C_AioRead *req_comp = <span class="keyword">new</span> C_AioRead(m_aio_comp);                                                                     |</div><div class="line">   |<span class="number">205</span>           AioObjectRead *req = <span class="keyword">new</span> AioObjectRead(&amp;m_image_ctx, extent.oid.name,                                                |</div><div class="line">   |<span class="number">206</span>                                                  extent.objectno, extent.offset,                                               |</div><div class="line">   |<span class="number">207</span>                                                  extent.length,                                                                |</div><div class="line">   |<span class="number">208</span>                                                  extent.buffer_extents, snap_id,                                               |</div><div class="line">   |<span class="number">209</span>                                                  <span class="literal">true</span>, req_comp, m_op_flags);                                                  |</div><div class="line">   |<span class="number">210</span>           req_comp-&gt;set_req(req);                                                                                              |</div><div class="line">   |<span class="number">211</span>                                                                                                                                |</div><div class="line">   |<span class="number">212</span>           <span class="keyword">if</span> (m_image_ctx.object_cacher) &#123;                                                                                     |</div><div class="line">   |<span class="number">213</span>             C_CacheRead *cache_comp = <span class="keyword">new</span> C_CacheRead(&amp;m_image_ctx, req);                                                      |</div><div class="line">   |<span class="number">214</span>             m_image_ctx.aio_read_from_cache(extent.oid, extent.objectno,                                                       |</div><div class="line">   |<span class="number">215</span>                                             &amp;req-&gt;data(), extent.length,                                                       |</div><div class="line">   |<span class="number">216</span>                                             extent.offset, cache_comp, m_op_flags);                                            |</div><div class="line">   |<span class="number">217</span>           &#125; <span class="keyword">else</span> &#123;                                                                                                             |</div><div class="line">   |<span class="number">218</span>             req-&gt;send();                                                                                                       |</div><div class="line">   |<span class="number">219</span>           &#125;                                                                                                                    |</div><div class="line">   |<span class="number">220</span>         &#125;                                                                                                                      |</div><div class="line">   |<span class="number">221</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">222</span>                                                                                                                                |</div><div class="line">   |<span class="number">223</span>       m_aio_comp-&gt;put();                                                                                                       |</div><div class="line">   |<span class="number">224</span>                                                                                                                                |</div><div class="line">   |<span class="number">225</span>       m_image_ctx.perfcounter-&gt;inc(l_librbd_rd);                                                                               |</div><div class="line">   |<span class="number">226</span>       m_image_ctx.perfcounter-&gt;inc(l_librbd_rd_bytes, buffer_ofs);                                                             |</div><div class="line">   |<span class="number">227</span>     &#125;</div></pre></td></tr></table></figure>
<p>这部分代码特别长，需要切分成好几个方面来进行描述。</p>
<h4 id="readahead"><a href="#readahead" class="headerlink" title="readahead"></a>readahead</h4><p>首先看一下对于readahead的处理。(在第一次开始读的时候，这里并没有起到readahead()的功能。也就是说在这里什么都还没有做。)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//file librbd/AioImageRequest.cc</span></div><div class="line">   |<span class="number">148</span>     <span class="keyword">void</span> AioImageRead::send_request() &#123;                                                                                        |</div><div class="line">   |<span class="number">149</span>       CephContext *cct = m_image_ctx.cct;                                                                                      |</div><div class="line">   |<span class="number">150</span></div><div class="line">  &gt;|<span class="number">151</span>       <span class="keyword">if</span> (m_image_ctx.object_cacher &amp;&amp; m_image_ctx.readahead_max_bytes &gt; <span class="number">0</span> &amp;&amp;                                                  |</div><div class="line">   |<span class="number">152</span>           !(m_op_flags &amp; LIBRADOS_OP_FLAG_FADVISE_RANDOM)) &#123;                                                                   |</div><div class="line">   |<span class="number">153</span>         readahead(&amp;m_image_ctx, m_image_extents);                                                                              |</div><div class="line">   |<span class="number">154</span>       &#125;</div></pre></td></tr></table></figure>
<p>这里需要读取的<code>extents</code>为<code>m_image_extents</code>就是前面需要读取的<code>off,len</code>值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">(gdb) print image_extents</div><div class="line">$<span class="number">28</span> = <span class="built_in">std</span>::<span class="built_in">vector</span> of length <span class="number">1</span>, capacity <span class="number">1</span> = &#123;&#123;first = <span class="number">0</span>, second = <span class="number">2048</span>&#125;&#125;</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>首先看几个变量的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">(gdb) print m_image_ctx.object_cacher</div><div class="line">$<span class="number">24</span> = (ObjectCacher *) <span class="number">0x7fffa0001340</span></div><div class="line">(gdb) print m_image_ctx.readahead_max_bytes</div><div class="line">$<span class="number">25</span> = <span class="number">524288</span> = <span class="number">512</span>KB</div><div class="line">(gdb) print m_op_flags</div><div class="line">$<span class="number">26</span> = <span class="number">0</span></div><div class="line">(gdb) print LIBRADOS_OP_FLAG_FADVISE_RANDOM - <span class="number">4</span></div><div class="line">$<span class="number">27</span> = <span class="number">0</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>所以这里可以看得出来，是肯定会进入到<code>readahead</code>函数的。而<code>readahead</code>的最大的<code>bytes</code>数目为<code>512KB</code>。那么接下来查看<code>readahead</code>的代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">file: librbd/internal.cc</div><div class="line">   |3678      void readahead(ImageCtx *ictx,                                                                                           |</div><div class="line">   |3679                     const vector&lt;pair&lt;uint64_t,uint64_t&gt; &gt;&amp; image_extents)                                                    |</div><div class="line">  &gt;|3680      &#123;                                                                                                                        |</div><div class="line">   |3681        uint64_t total_bytes = 0;                                                                                              |</div><div class="line">   |3682        for (vector&lt;pair&lt;uint64_t,uint64_t&gt; &gt;::const_iterator p = image_extents.begin();                                       |</div><div class="line">   |3683             p != image_extents.end();                                                                                         |</div><div class="line">   |3684             ++p) &#123;                                                                                                            |</div><div class="line">   |3685          total_bytes += p-&gt;second;                                                                                            |</div><div class="line">   |3686        &#125;                                                                                                                      |</div><div class="line">   |3687        // 这里读取到image_extents的总的长度，这里为2048                                                                            |</div><div class="line">   |3688        ictx-&gt;md_lock.get_write();                                                                                             |</div><div class="line">   |3689        bool abort = ictx-&gt;readahead_disable_after_bytes != 0 &amp;&amp;                                                               |</div><div class="line">   |3690          ictx-&gt;total_bytes_read &gt; ictx-&gt;readahead_disable_after_bytes;                                                        |</div><div class="line">   |3691        if (abort) &#123;                                                                                                           |</div><div class="line">   |3692          ictx-&gt;md_lock.put_write();                                                                                           |</div><div class="line">   |3693          return;                                                                                                              |</div><div class="line">   |3694        &#125;                                                                                                                      |</div><div class="line">   |3695        ictx-&gt;total_bytes_read += total_bytes;                                                                                 |</div><div class="line">   |3696        ictx-&gt;snap_lock.get_read();                                                                                            |</div><div class="line">   |3697        uint64_t image_size = ictx-&gt;get_image_size(ictx-&gt;snap_id);                                                             |</div><div class="line">   |3698        ictx-&gt;snap_lock.put_read();                                                                                            |</div><div class="line">   |3699        ictx-&gt;md_lock.put_write();</div><div class="line">   |3700                                                                                                                               |</div><div class="line">   |3701        pair&lt;uint64_t, uint64_t&gt; readahead_extent = ictx-&gt;readahead.update(image_extents, image_size);                         |</div><div class="line">   |3702        uint64_t readahead_offset = readahead_extent.first;                                                                    |</div><div class="line">   |3703        uint64_t readahead_length = readahead_extent.second;                                                                   |</div><div class="line">   |3704                                                                                                                               |</div><div class="line">   |3705        if (readahead_length &gt; 0) &#123;                                                                                            |</div><div class="line">   |3706          ldout(ictx-&gt;cct, 20) &lt;&lt; "(readahead logical) " &lt;&lt; readahead_offset &lt;&lt; "~" &lt;&lt; readahead_length &lt;&lt; dendl;              |</div><div class="line">   |3707          map&lt;object_t,vector&lt;ObjectExtent&gt; &gt; readahead_object_extents;                                                        |</div><div class="line">   |3708          Striper::file_to_extents(ictx-&gt;cct, ictx-&gt;format_string, &amp;ictx-&gt;layout,                                              |</div><div class="line">   |3709                                   readahead_offset, readahead_length, 0, readahead_object_extents);                           |</div><div class="line">   |3710          for (map&lt;object_t,vector&lt;ObjectExtent&gt; &gt;::iterator p = readahead_object_extents.begin(); p != readahead_object_extent|</div><div class="line">   |3711            for (vector&lt;ObjectExtent&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123;                            |</div><div class="line">   |3712              ldout(ictx-&gt;cct, 20) &lt;&lt; "(readahead) oid " &lt;&lt; q-&gt;oid &lt;&lt; " " &lt;&lt; q-&gt;offset &lt;&lt; "~" &lt;&lt; q-&gt;length &lt;&lt; dendl;           |</div><div class="line">   |3713                                                                                                                               |</div><div class="line">   |3714              Context *req_comp = new C_RBD_Readahead(ictx, q-&gt;oid, q-&gt;offset, q-&gt;length);                                     |</div><div class="line">   |3715              ictx-&gt;readahead.inc_pending();                                                                                   |</div><div class="line">   |3716              ictx-&gt;aio_read_from_cache(q-&gt;oid, q-&gt;objectno, NULL,                                                             |</div><div class="line">   |3717                                        q-&gt;length, q-&gt;offset,                                                                  |</div><div class="line">   |3718                                        req_comp, 0);                                                                          |</div><div class="line">   |3719            &#125;                                                                                                                  |</div><div class="line">   |3720          &#125;                                                                                                                    |</div><div class="line">   |3721          ictx-&gt;perfcounter-&gt;inc(l_librbd_readahead);                                                                          |</div><div class="line">   |3722          ictx-&gt;perfcounter-&gt;inc(l_librbd_readahead_bytes, readahead_length);                                                  |</div><div class="line">   |3723        &#125;                                                                                                                      |</div><div class="line">   |3724      &#125;                                                                                                                        |</div></pre></td></tr></table></figure>
<p>这里分成几个部分来介绍这段代码逻辑。</p>
<p><strong>需要读取的bytes</strong></p>
<p>这里是从<code>image_extents</code>里面计算需要读取的<code>bytes</code>的总数，然后放到<code>total_bytes</code>里面。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">3681</span>        <span class="keyword">uint64_t</span> total_bytes = <span class="number">0</span>;                                                                                              |</div><div class="line">|<span class="number">3682</span>        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">uint64_t</span>,<span class="keyword">uint64_t</span>&gt; &gt;::const_iterator p = image_extents.begin();                                       |</div><div class="line">|<span class="number">3683</span>             p != image_extents.end();                                                                                         |</div><div class="line">|<span class="number">3684</span>             ++p) &#123;                                                                                                            |</div><div class="line">|<span class="number">3685</span>          total_bytes += p-&gt;second;                                                                                            |</div><div class="line">|<span class="number">3686</span>        &#125;                                                                                                                      |</div></pre></td></tr></table></figure></p>
<p>在这里运行的时候，最后的值为<code>total_bytes = 2048</code>。</p>
<p><strong>是否需要abort()</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> |<span class="number">3688</span>        ictx-&gt;md_lock.get_write();                                                                                             |</div><div class="line">&gt;|<span class="number">3689</span>        <span class="keyword">bool</span> <span class="built_in">abort</span> = ictx-&gt;readahead_disable_after_bytes != <span class="number">0</span> &amp;&amp;                                                               |</div><div class="line"> |<span class="number">3690</span>          ictx-&gt;total_bytes_read &gt; ictx-&gt;readahead_disable_after_bytes;                                                        |</div><div class="line"> |<span class="number">3691</span>        <span class="keyword">if</span> (<span class="built_in">abort</span>) &#123;                                                                                                           |</div><div class="line"> |<span class="number">3692</span>          ictx-&gt;md_lock.put_write();                                                                                           |</div><div class="line"> |<span class="number">3693</span>          <span class="keyword">return</span>;                                                                                                              |</div><div class="line"> |<span class="number">3694</span>        &#125;</div></pre></td></tr></table></figure>
<p>这里根据需要读取的<code>ictx-&gt;total_bytes_read = 0</code>数，与<code>readahead_disable_after_bytes = 512KB</code>的值进行比较。在这里，数目设置合理。所以不会退。这里应该是在检查<code>Ceph</code>客户端的设置是否合理的情况。</p>
<p><strong>image_size与bytes</strong></p>
<p>接下来去获取<code>image_size</code>以及<code>ictx-&gt;total_bytes_read</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">3695</span>        ictx-&gt;total_bytes_read += total_bytes;                                                                                 |</div><div class="line">|<span class="number">3696</span>        ictx-&gt;snap_lock.get_read();                                                                                            |</div><div class="line">|<span class="number">3697</span>        <span class="keyword">uint64_t</span> image_size = ictx-&gt;get_image_size(ictx-&gt;snap_id);      <span class="comment">// 整个磁盘的大小为100M                                   |</span></div><div class="line">|<span class="number">3698</span>        ictx-&gt;snap_lock.put_read();                                                                                            |</div><div class="line">|<span class="number">3699</span>        ictx-&gt;md_lock.put_write();                                                                                             |</div><div class="line">|<span class="number">3700</span></div></pre></td></tr></table></figure>
<p>实际上，这段代码，也就是设置了如下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ictx-&gt;total_bytes_read = <span class="number">2048</span></div><div class="line">image_size = <span class="number">100</span>MB</div></pre></td></tr></table></figure>
<p><strong>是否需要更新readahead的范围</strong></p>
<p>接下来就是根据获得的<code>image_size</code>来确定是否需要更新<code>readahead</code>读取的范围:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">3701</span>        pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt; readahead_extent = ictx-&gt;readahead.update(image_extents, image_size);                         |</div></pre></td></tr></table></figure>
<p>这里需要进入<code>readahead.update</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file: common/Readahead.cc</span></div><div class="line">  &gt;|<span class="number">27</span>      Readahead::<span class="keyword">extent_t</span> Readahead::update(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">extent_t</span>&gt;&amp; extents, <span class="keyword">uint64_t</span> limit) &#123;                                   |</div><div class="line">   |<span class="number">28</span>        m_lock.Lock();                                                                                                           |</div><div class="line">   |<span class="number">29</span>        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">extent_t</span>&gt;::const_iterator p = extents.begin(); p != extents.end(); ++p) &#123;                                    |</div><div class="line">   |<span class="number">30</span>          <span class="number">_</span>observe_read(p-&gt;first, p-&gt;second);                                                                                    |</div><div class="line">   |<span class="number">31</span>        &#125;                                                                                                                        |</div><div class="line">  &gt;|<span class="number">32</span>        <span class="keyword">if</span> (m_readahead_pos &gt;= limit|| m_last_pos &gt;= limit) &#123;                                                                    |</div><div class="line">   |<span class="number">33</span>          m_lock.Unlock();                                                                                                       |</div><div class="line">   |<span class="number">34</span>          <span class="keyword">return</span> <span class="keyword">extent_t</span>(<span class="number">0</span>, <span class="number">0</span>);                                                                                                 |</div><div class="line">   |<span class="number">35</span>        &#125;                                                                                                                        |</div><div class="line">   |<span class="number">36</span>        pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt; extent = <span class="number">_</span>compute_readahead(limit);                                                             |</div><div class="line">   |<span class="number">37</span>        m_lock.Unlock();                                                                                                         |</div><div class="line">   |<span class="number">38</span>        <span class="keyword">return</span> extent;                                                                                                           |</div><div class="line">   |<span class="number">39</span>      &#125;</div></pre></td></tr></table></figure>
<p>首先会进入到<code>_observe_read</code>函数。这里传入的两个参数是需要读取的范围<code>offset = 0, length = 2048</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> |<span class="number">53</span>      <span class="keyword">void</span> Readahead::<span class="number">_</span>observe_read(<span class="keyword">uint64_t</span> offset, <span class="keyword">uint64_t</span> length) &#123;                                                          |</div><div class="line">&gt;|<span class="number">54</span>        <span class="keyword">if</span> (offset == m_last_pos) &#123;                                                                                              |</div><div class="line"> |<span class="number">55</span>          m_nr_consec_read++;                                                                                                    |</div><div class="line"> |<span class="number">56</span>          m_consec_read_bytes += length;                                                                                         |</div><div class="line"> |<span class="number">57</span>        &#125; <span class="keyword">else</span> &#123;                                                                                                                 |</div><div class="line"> |<span class="number">58</span>          m_nr_consec_read = <span class="number">0</span>;                                                                                                  |</div><div class="line"> |<span class="number">59</span>          m_consec_read_bytes = <span class="number">0</span>;                                                                                               |</div><div class="line"> |<span class="number">60</span>          m_readahead_trigger_pos = <span class="number">0</span>;                                                                                           |</div><div class="line"> |<span class="number">61</span>          m_readahead_size = <span class="number">0</span>;                                                                                                  |</div><div class="line"> |<span class="number">62</span>          m_readahead_pos = <span class="number">0</span>;                                                                                                   |</div><div class="line"> |<span class="number">63</span>        &#125;                                                                                                                        |</div><div class="line"> |<span class="number">64</span>        m_last_pos = offset + length;                                                                                            |</div><div class="line"> |<span class="number">65</span>      &#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于是第一次进来，<code>m_last_pos = 0</code>，所以肯定会进入到第一个逻辑里面。</li>
<li>函数执行成功之后：<code>m_nr_consec_read  = 1, m_consec_read_bytes  = m_last_pos  = 2048</code>。</li>
</ul>
<p>执行完成之后，进入到代码<code>update()</code>的32行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">&gt;|<span class="number">32</span>        <span class="keyword">if</span> (m_readahead_pos &gt;= limit|| m_last_pos &gt;= limit) &#123;                                                                    |</div><div class="line"> |<span class="number">33</span>          m_lock.Unlock();                                                                                                       |</div><div class="line"> |<span class="number">34</span>          <span class="keyword">return</span> <span class="keyword">extent_t</span>(<span class="number">0</span>, <span class="number">0</span>);                                                                                                 |</div><div class="line"> |<span class="number">35</span>        &#125;                                                                                                                        |</div></pre></td></tr></table></figure>
<p>这部分代码没有别的作用，就是判断一下读取的范围是不是超出了整个<code>image_size</code>。如果合法，那进入到<code>compute_readahead</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">//file : common/Readahead.cc</span></div><div class="line">  &gt;|<span class="number">67</span>      Readahead::<span class="keyword">extent_t</span> Readahead::<span class="number">_</span>compute_readahead(<span class="keyword">uint64_t</span> limit) &#123;                                                        |</div><div class="line">   |<span class="number">68</span>        <span class="keyword">uint64_t</span> readahead_offset = <span class="number">0</span>;                                                                                           |</div><div class="line">   |<span class="number">69</span>        <span class="keyword">uint64_t</span> readahead_length = <span class="number">0</span>;                                                                                           |</div><div class="line">   |<span class="number">70</span>        <span class="keyword">if</span> (m_nr_consec_read &gt;= m_trigger_requests) &#123;                                                                            |</div><div class="line">   ...............                                                                                                                     |</div><div class="line">   |<span class="number">120</span>       &#125;                                                                                                                        |</div><div class="line">   |<span class="number">121</span>       <span class="keyword">return</span> <span class="keyword">extent_t</span>(readahead_offset, readahead_length);                                                                     |</div><div class="line">   |<span class="number">122</span>     &#125;                                                                                                                          |</div></pre></td></tr></table></figure>
<p>由于<code>m_nr_consec_read &gt;= m_trigger_requests</code>不成立，所以这里直接跳到最后<code>return</code>语句。实际上返回的值也就是<code>0, 0</code>。</p>
<p><strong>设置readahead的offset与length</strong></p>
<p>当返回值为<code>0</code>的时候，<code>readahead</code>函数里面一大段代码都会被跳过了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">3701</span>        pair&lt;<span class="keyword">uint64_t</span>, <span class="keyword">uint64_t</span>&gt; readahead_extent = ictx-&gt;readahead.update(image_extents, image_size);                         |</div><div class="line">|<span class="number">3702</span>        <span class="keyword">uint64_t</span> readahead_offset = readahead_extent.first;   <span class="comment">// = 0                                                           |</span></div><div class="line">|<span class="number">3703</span>        <span class="keyword">uint64_t</span> readahead_length = readahead_extent.second;  <span class="comment">// = 0                                                           |</span></div><div class="line">|<span class="number">3704</span>                                                                                                                               |</div><div class="line">|<span class="number">3705</span>        <span class="keyword">if</span> (readahead_length &gt; <span class="number">0</span>) &#123;                                                                                            |</div><div class="line">|<span class="number">3706</span>          ldout(ictx-&gt;cct, <span class="number">20</span>) &lt;&lt; <span class="string">"(readahead logical) "</span> &lt;&lt; readahead_offset &lt;&lt; <span class="string">"~"</span> &lt;&lt; readahead_length &lt;&lt; dendl;              |</div><div class="line">|<span class="number">3707</span>          <span class="built_in">map</span>&lt;<span class="keyword">object_t</span>,<span class="built_in">vector</span>&lt;ObjectExtent&gt; &gt; readahead_object_extents;                                                        |</div><div class="line">|<span class="number">3708</span>          Striper::file_to_extents(ictx-&gt;cct, ictx-&gt;format_string, &amp;ictx-&gt;layout,                                              |</div><div class="line">|<span class="number">3709</span>                                   readahead_offset, readahead_length, <span class="number">0</span>, readahead_object_extents);                           |</div><div class="line">|<span class="number">3710</span>          <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">object_t</span>,<span class="built_in">vector</span>&lt;ObjectExtent&gt; &gt;::iterator p = readahead_object_extents.begin(); p != readahead_object_extent|</div><div class="line">|<span class="number">3711</span>            <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;ObjectExtent&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123;                            |</div><div class="line">|<span class="number">3712</span>              ldout(ictx-&gt;cct, <span class="number">20</span>) &lt;&lt; <span class="string">"(readahead) oid "</span> &lt;&lt; q-&gt;oid &lt;&lt; <span class="string">" "</span> &lt;&lt; q-&gt;offset &lt;&lt; <span class="string">"~"</span> &lt;&lt; q-&gt;length &lt;&lt; dendl;           |</div><div class="line">|<span class="number">3713</span>                                                                                                                               |</div><div class="line">|<span class="number">3714</span>              Context *req_comp = <span class="keyword">new</span> C_RBD_Readahead(ictx, q-&gt;oid, q-&gt;offset, q-&gt;length);                                     |</div><div class="line">|<span class="number">3715</span>              ictx-&gt;readahead.inc_pending();                                                                                   |</div><div class="line">|<span class="number">3716</span>              ictx-&gt;aio_read_from_cache(q-&gt;oid, q-&gt;objectno, <span class="literal">NULL</span>,                                                             |</div><div class="line">|<span class="number">3717</span>                                        q-&gt;length, q-&gt;offset,                                                                  |</div><div class="line">|<span class="number">3718</span>                                        req_comp, <span class="number">0</span>);                                                                          |</div><div class="line">|<span class="number">3719</span>            &#125;                                                                                                                  |</div><div class="line">|<span class="number">3720</span>          &#125;                                                                                                                    |</div><div class="line">|<span class="number">3721</span>          ictx-&gt;perfcounter-&gt;inc(l_librbd_readahead);                                                                          |</div><div class="line">|<span class="number">3722</span>          ictx-&gt;perfcounter-&gt;inc(l_librbd_readahead_bytes, readahead_length);                                                  |</div><div class="line">|<span class="number">3723</span>        &#125;                                                                                                                      |</div><div class="line">|<span class="number">3724</span>      &#125;                                                                                                                        |</div></pre></td></tr></table></figure>
<p>这里就先不去研究这大段代码做的事情。后面再次读到这里的时候再看。</p>
<p><strong>总结</strong></p>
<p>实际上，这个时候也可以总结一下就是，当第一次开始读的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">|<span class="number">151</span>       <span class="keyword">if</span> (m_image_ctx.object_cacher &amp;&amp; m_image_ctx.readahead_max_bytes &gt; <span class="number">0</span> &amp;&amp;                                                  |</div><div class="line">|<span class="number">152</span>           !(m_op_flags &amp; LIBRADOS_OP_FLAG_FADVISE_RANDOM)) &#123;                                                                   |</div><div class="line">|<span class="number">153</span>         readahead(&amp;m_image_ctx, m_image_extents);                                                                              |</div><div class="line">|<span class="number">154</span>       &#125;                                                                                                                        |</div></pre></td></tr></table></figure>
<p>这里的工作，在这里并没有起到作用。也就是说，这里可以先不要看<code>readahead</code>的作用。</p>
<h4 id="image-size"><a href="#image-size" class="headerlink" title="image size"></a>image size</h4><p>在接下来，则是负责对<code>image size</code>进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"> |<span class="number">160</span>         <span class="comment">// prevent image size from changing between computing clip and recording             |</span></div><div class="line"> |<span class="number">161</span>         <span class="comment">// pending async operation                                                           |</span></div><div class="line">&gt;|<span class="number">162</span>         RWLock::<span class="function">RLocker <span class="title">snap_locker</span><span class="params">(m_image_ctx.snap_lock)</span></span>;                                  |</div><div class="line"> |<span class="number">163</span>         snap_id = m_image_ctx.snap_id;</div></pre></td></tr></table></figure>
<p>这里可以查看一下这里得到的<code>snapshot id</code>，其值为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">(gdb) print m_image_ctx.snap_id</div><div class="line">$<span class="number">6</span> = <span class="number">18446744073709551614</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>这里做这样的<code>change</code>主要是为了防止在读写数据的时候，<code>image</code>的size结果发生了变化，所以这里需要先对<code>Image</code>做一个snapshot?然后利用这个<code>snapshot</code>出业的属性去读取一个近似于固定的值。</p>
<h4 id="读取长度的裁减"><a href="#读取长度的裁减" class="headerlink" title="读取长度的裁减"></a>读取长度的裁减</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// map</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">uint64_t</span>,<span class="keyword">uint64_t</span>&gt; &gt;::const_iterator p =</div><div class="line">       m_image_extents.begin();</div><div class="line">     p != m_image_extents.end(); ++p) &#123;</div><div class="line">  <span class="keyword">uint64_t</span> len = p-&gt;second;</div><div class="line">  <span class="keyword">int</span> r = clip_io(&amp;m_image_ctx, p-&gt;first, &amp;len);</div><div class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</div><div class="line">    m_aio_comp-&gt;fail(r);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Striper::file_to_extents(cct, m_image_ctx.format_string, <span class="comment">// 在这里包含了整个image的format string。</span></div><div class="line">                           &amp;m_image_ctx.layout, p-&gt;first, len, <span class="number">0</span>,</div><div class="line">                           object_extents, buffer_ofs);</div><div class="line">  buffer_ofs += len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一开始处理之后，需要查看一下imagectx里面的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">$<span class="number">31</span> = &#123;name = <span class="string">"rbd_data.102374b0dc51."</span>, <span class="string">'0'</span> &lt;repeats <span class="number">16</span> times&gt;&#125;</div><div class="line">(gdb) print object_format</div><div class="line">$<span class="number">32</span> = <span class="number">0x7fffa0001ef0</span> <span class="string">"rbd_data.102374b0dc51.%016llx"</span></div><div class="line">(gdb) print layout</div><div class="line">$<span class="number">33</span> = (<span class="keyword">const</span> <span class="keyword">file_layout_t</span> *) <span class="number">0x5555565220e0</span></div><div class="line">(gdb) print *layout</div><div class="line">$<span class="number">34</span> = &#123;stripe_unit = <span class="number">4194304</span>, stripe_count = <span class="number">1</span>, object_size = <span class="number">4194304</span>, pool_id = <span class="number">0</span>, pool_ns = <span class="string">""</span>&#125;</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>接下来的一段代码则是对想要读取的内容进行裁剪。<code>Striper</code>应该是负现处理条带化的内容？这里可能的原因在于：</p>
<ul>
<li>上层应用只关于需要读取的内容位于文件的什么位置，比如<code>offset</code>和<code>length</code>。</li>
<li>而底层只关心需要读取的内容，对于对象存储而言，可能就是只关心某个对象，所以这里应该是需要转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// file: osdc/Striper.cc:43</span></div><div class="line"><span class="keyword">void</span> Striper::file_to_extents(</div><div class="line">  CephContext *cct, <span class="keyword">const</span> <span class="keyword">char</span> *object_format,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">file_layout_t</span> *layout,</div><div class="line">  <span class="keyword">uint64_t</span> offset, <span class="keyword">uint64_t</span> len,</div><div class="line">  <span class="keyword">uint64_t</span> trunc_size,</div><div class="line">  <span class="built_in">map</span>&lt;<span class="keyword">object_t</span>,<span class="built_in">vector</span>&lt;ObjectExtent&gt; &gt;&amp; object_extents,</div><div class="line">  <span class="keyword">uint64_t</span> buffer_offset)</div><div class="line">&#123;</div><div class="line">  ldout(cct, <span class="number">10</span>) &lt;&lt; <span class="string">"file_to_extents "</span> &lt;&lt; offset &lt;&lt; <span class="string">"~"</span> &lt;&lt; len</div><div class="line">		 &lt;&lt; <span class="string">" format "</span> &lt;&lt; object_format</div><div class="line">		 &lt;&lt; dendl;</div><div class="line">  assert(len &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">   * we want only one extent per object!  this means that each extent</div><div class="line">   * we read may map into different bits of the final read</div><div class="line">   * buffer.. hence ObjectExtent.buffer_extents</div><div class="line">   */</div><div class="line">  <span class="comment">/*</span></div><div class="line">   * 我们只想一个extent一个对象！也就是说一个范围只需要去一个对象去读。这就意味着每个</div><div class="line">   * 要读取的范围可能被分到几个读buffer里面。比如放到ObjectExtent.buffer_extents</div><div class="line">   */</div><div class="line"></div><div class="line">  <span class="number">__u</span>32 object_size = layout-&gt;object_size;   <span class="comment">// 4MB</span></div><div class="line">  <span class="number">__u</span>32 su = layout-&gt;stripe_unit;            <span class="comment">// 4MB</span></div><div class="line">  <span class="number">__u</span>32 stripe_count = layout-&gt;stripe_count; <span class="comment">// 1</span></div><div class="line">  assert(object_size &gt;= su);</div><div class="line">  <span class="keyword">if</span> (stripe_count == <span class="number">1</span>) &#123;  <span class="comment">// 这里本来就是相等的。在debug的时候，直接这样赋值。</span></div><div class="line">    ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">" sc is one, reset su to os"</span> &lt;&lt; dendl;</div><div class="line">    su = object_size;  <span class="comment">// 如果只有一个条带，那么只需要读一个object size就可以了？</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">uint64_t</span> stripes_per_object = object_size / su; <span class="comment">// 4MB/4MB == 1</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">uint64_t</span> cur = offset; <span class="comment">// = 0</span></div><div class="line">  <span class="keyword">uint64_t</span> left = len;   <span class="comment">// = 2048</span></div><div class="line">  <span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;     <span class="comment">// left = 2048 &gt; 0,</span></div><div class="line">    <span class="comment">// layout into objects</span></div><div class="line">    <span class="keyword">uint64_t</span> blockno = cur / su; <span class="comment">// which block // 需要读哪个block</span></div><div class="line">    <span class="comment">// which horizontal stripe (Y)</span></div><div class="line">    <span class="keyword">uint64_t</span> stripeno = blockno / stripe_count;</div><div class="line">    <span class="comment">// which object in the object set (X)</span></div><div class="line">    <span class="keyword">uint64_t</span> stripepos = blockno % stripe_count;</div><div class="line">    <span class="comment">// which object set</span></div><div class="line">    <span class="keyword">uint64_t</span> objectsetno = stripeno / stripes_per_object;</div><div class="line">    <span class="comment">// object id</span></div><div class="line">    <span class="keyword">uint64_t</span> objectno = objectsetno * stripe_count + stripepos;</div><div class="line"></div><div class="line">    <span class="comment">// find oid, extent</span></div><div class="line">    <span class="keyword">char</span> buf[<span class="built_in">strlen</span>(object_format) + <span class="number">32</span>];</div><div class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), object_format, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span>)objectno);</div><div class="line">    <span class="keyword">object_t</span> oid = buf;</div><div class="line"></div><div class="line">    <span class="comment">// map range into object</span></div><div class="line">    <span class="keyword">uint64_t</span> block_start = (stripeno % stripes_per_object) * su;</div><div class="line">    <span class="keyword">uint64_t</span> block_off = cur % su;</div><div class="line">    <span class="keyword">uint64_t</span> max = su - block_off;</div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> x_offset = block_start + block_off;</div><div class="line">    <span class="keyword">uint64_t</span> x_len;</div><div class="line">    <span class="keyword">if</span> (left &gt; max)</div><div class="line">      x_len = max;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      x_len = left;</div><div class="line"></div><div class="line">    ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">" off "</span> &lt;&lt; cur &lt;&lt; <span class="string">" blockno "</span> &lt;&lt; blockno &lt;&lt; <span class="string">" stripeno "</span></div><div class="line">		   &lt;&lt; stripeno &lt;&lt; <span class="string">" stripepos "</span> &lt;&lt; stripepos &lt;&lt; <span class="string">" objectsetno "</span></div><div class="line">		   &lt;&lt; objectsetno &lt;&lt; <span class="string">" objectno "</span> &lt;&lt; objectno</div><div class="line">		   &lt;&lt; <span class="string">" block_start "</span> &lt;&lt; block_start &lt;&lt; <span class="string">" block_off "</span></div><div class="line">		   &lt;&lt; block_off &lt;&lt; <span class="string">" "</span> &lt;&lt; x_offset &lt;&lt; <span class="string">"~"</span> &lt;&lt; x_len</div><div class="line">		   &lt;&lt; dendl;</div><div class="line"></div><div class="line">    ObjectExtent *ex = <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;ObjectExtent&gt;&amp; exv = object_extents[oid];</div><div class="line">    <span class="keyword">if</span> (exv.empty() || exv.back().offset + exv.back().length != x_offset) &#123;</div><div class="line">      exv.resize(exv.size() + <span class="number">1</span>);</div><div class="line">      ex = &amp;exv.back();</div><div class="line">      ex-&gt;oid = oid;</div><div class="line">      ex-&gt;objectno = objectno;</div><div class="line">      ex-&gt;oloc = OSDMap::file_to_object_locator(*layout);</div><div class="line"></div><div class="line">      ex-&gt;offset = x_offset;</div><div class="line">      ex-&gt;length = x_len;</div><div class="line">      ex-&gt;truncate_size = object_truncate_size(cct, layout, objectno,</div><div class="line">					       trunc_size);</div><div class="line"></div><div class="line">      ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">" added new "</span> &lt;&lt; *ex &lt;&lt; dendl;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// add to extent</span></div><div class="line">      ex = &amp;exv.back();</div><div class="line">      ldout(cct, <span class="number">20</span>) &lt;&lt; <span class="string">" adding in to "</span> &lt;&lt; *ex &lt;&lt; dendl;</div><div class="line">      ex-&gt;length += x_len;</div><div class="line">    &#125;</div><div class="line">    ex-&gt;buffer_extents.push_back(make_pair(cur - offset + buffer_offset,</div><div class="line">					   x_len));</div><div class="line"></div><div class="line">    ldout(cct, <span class="number">15</span>) &lt;&lt; <span class="string">"file_to_extents  "</span> &lt;&lt; *ex &lt;&lt; <span class="string">" in "</span> &lt;&lt; ex-&gt;oloc</div><div class="line">		   &lt;&lt; dendl;</div><div class="line">    <span class="comment">// ldout(cct, 0) &lt;&lt; "map: ino " &lt;&lt; ino &lt;&lt; " oid " &lt;&lt; ex.oid &lt;&lt; " osd "</span></div><div class="line">    <span class="comment">//		  &lt;&lt; ex.osd &lt;&lt; " offset " &lt;&lt; ex.offset &lt;&lt; " len " &lt;&lt; ex.len</span></div><div class="line">    <span class="comment">//		  &lt;&lt; " ... left " &lt;&lt; left &lt;&lt; dendl;</span></div><div class="line"></div><div class="line">    left -= x_len;</div><div class="line">    cur += x_len;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Gdb/">Gdb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Qemu/">Qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/ceph-rbd-read" data-title="Ceph 调试 RBD读写流程-2" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/ceph-cmake-debug" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/10/24/ceph/ceph-cmake-debug/" class="article-date">
  	<time datetime="2016-10-24T13:38:02.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/10/24/ceph/ceph-cmake-debug/">Ceph Bluestore Cmake以及调试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>为了看<code>bluestore</code>的代码，这里尝试拉取了最新的<code>Ceph</code>代码，然后利用<code>Cmake</code>进行了编译和调试。需要注意的是，这里并且没有编译之后，安装一个完整的<code>Ceph</code>系统，而只是为了读<code>BlueStore</code>以及<code>BlueFS</code>部分的代码。</p>
<p>编译的时候，需要注意：</p>
<ul>
<li>打开静态编译</li>
<li>打开gdb选项</li>
</ul>
<h1 id="编译Ceph"><a href="#编译Ceph" class="headerlink" title="编译Ceph"></a>编译Ceph</h1><p>利用<code>git clone</code>下载好源码之后，需要利用<code>cmake</code>来进行编译。在编译之前，最好是清理以前的依赖，否则很容易出错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">git submodule deinit --forcegit clean -xfdgit checkout .git submodule init</div></pre></td></tr></table></figure>
<p>清理成功之后，再编译如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./install-deps.sh</div><div class="line">./do_cmake.sh -DCMAKE_EXPORT_COMPILE_COMMANDS=ON CMAKE_BUILD_TYPE=<span class="string">"Debug"</span> CMAKE_CXX_FLAGS_DEBUG=<span class="string">"-g2 -ggdb"</span> -DBUILD_SHARED_LIBS=OFF</div><div class="line"><span class="built_in">cd</span> build</div><div class="line">make -j24</div></pre></td></tr></table></figure>
<p>在这里<code>24</code>表示，主机有24核，可以开<code>24</code>个线程一起编。编译成功之后，调试方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> ceph/build/bin/</div><div class="line">gdb -tui --dir=/var/lib/docker/ceph --args ./unittest_bluestore_types</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Gdb/">Gdb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/bluestore/">bluestore</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/ceph-cmake-debug" data-title="Ceph Bluestore Cmake以及调试" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/bluestore-intro" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/10/16/ceph/bluestore-intro/" class="article-date">
  	<time datetime="2016-10-16T12:45:45.000Z" itemprop="datePublished">2016-10-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/10/16/ceph/bluestore-intro/">Ceph Bluestore简介</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="http://www.sysnote.org/2016/08/19/ceph-bluestore/" target="_blank" rel="external">ceph存储引擎bluestore解析</a> 来源独家号 System Notes 作者 @dong_wu</li>
<li><a href="http://www.voidcn.com/blog/changtao381/article/p-4987037.html" target="_blank" rel="external">http://www.voidcn.com/blog/changtao381/article/p-4987037.html</a></li>
<li><a href="http://www.slideshare.net/sageweil1/bluestore-a-new-faster-storage-backend-for-ceph" target="_blank" rel="external">http://www.slideshare.net/sageweil1/bluestore-a-new-faster-storage-backend-for-ceph</a></li>
<li><a href="https://drive.google.com/file/d/0B2gTBZrkrnpZOTVQNkV0M2tIWkk/view" target="_blank" rel="external">https://drive.google.com/file/d/0B2gTBZrkrnpZOTVQNkV0M2tIWkk/view</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20NA%20BlueStore.pdf" target="_blank" rel="external">http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20NA%20BlueStore.pdf</a></li>
</ul>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><p>在计算机科学中，预写式日志（Write-ahead logging，縮寫 WAL）是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术。在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中。<br>log文件中通常包括redo和undo信息。这样做的目的可以通过一个例子来说明。假设一个程序在执行某些操作的过程中机器掉电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。<br>WAL允许用in-place方式更新数据库。另一种用来实现原子更新的方法是shadow paging，它并不是in-place方式。用in-place方式做更新的主要优点是减少索引和块列表的修改。ARIES是WAL系列技术常用的算法。在文件系统中，WAL通常称为journaling。PostgreSQL也是用WAL来提供point-in-time恢复和数据库复制特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">extent 范围：范围记录的主要方式是offet &amp; length。</div></pre></td></tr></table></figure>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>ceph后端(<code>objectstore</code>)使用的支持多种存储引擎，以插件式的方式来进行管理使用。<br>目前支持的有：</p>
<ul>
<li>filestore</li>
<li>kvstore</li>
<li>memstore</li>
<li>bluestore</li>
</ul>
<p>目前默认使用的<code>filestore</code>。之所以会开发一个新的<code>bluestore</code>，这是因为<code>filestore</code>有以下问题：</p>
<ul>
<li>只对<code>HDD</code>进行了设计，没有针对<code>SSD</code>做设计。</li>
<li><code>filestore</code>有<code>journal</code>，会带来二次写。导致写放大的问题。</li>
<li><code>filestore</code>是一个依赖底层现有文件系统，无论是<code>xfs</code>，还是<code>btrfs</code>，还是<code>ext4</code>都是比较<code>重</code>的文件系统，但是可能对于<code>filestore</code>而言，不需要用到这么<code>重</code>的文件系统。</li>
</ul>
<p>那么目前为止，<code>bluestore</code>的现状是：</p>
<ul>
<li>bluestore还处于开发优化阶段</li>
<li>在jewel版本还是试用版本</li>
<li>并且最新的master相比jewel已经做了大的重构，预期会在后续的大版本中稳定下来成为默认的存储引擎。</li>
</ul>
<p>本文基于当前的<code>master</code>分支对<code>bluestore</code>存储引擎进行分析。</p>
<h1 id="Bluestore的结构"><a href="#Bluestore的结构" class="headerlink" title="Bluestore的结构"></a>Bluestore的结构</h1><p><img src="/blog/img/bluestore-arch-wei.jpeg" alt="bluestore的结构"></p>
<p>这个图需要从下往上看：</p>
<p><strong>BlockDevice</strong></p>
<p><code>BlockDevice</code>实现在用户态下使用<code>linux aio</code>直接对裸设备进行I/O操作。既然是直接管理裸设备就必然需要进行裸设备的空间管理。因此，就需要一个分配器的概念。</p>
<p><strong>Allocator</strong></p>
<p><code>Allocator</code>负责分配磁盘上的空间。对应的就是<code>Allocator</code>，目前支持<code>StupidAllocator</code>和<code>BitmapAllocator</code>两种分配器。</p>
<p><strong>BlueFS</strong></p>
<p><code>BlueFS</code>是实现的一个小型的文件系统。这个文件系统负现存放写入数据的元数据。</p>
<p><strong>BlueRocksEnv</strong></p>
<p>这个是实现了<code>BlueFS</code>对接<code>RocksDB</code>的一个接口。起因是因为，当建立好<code>BlueFS</code>之后，元数据的管理就是一个问题。为了简单起见，这里采用了<code>RocksDB</code>，但是要明白：<code>RocksDB</code>本身并不支持<code>BlueFS</code>。好在<code>RocksDB</code>采用了驱动的操作方式，只要是实现了<code>RocksEnvWrapper</code>接口，就可把自己写的文件系统交给<code>RocksDB</code>使用。</p>
<p>在系统启动mount这个文件系统的时候将所有的元数据都加载到内存中，BluesFS的数据和日志文件都通过BlockDevice保存到裸设备上，BlueFS和BlueStore可以共享裸设备，也可以分别指定不同的设备。</p>
<p><strong>BlueFS/BlueStore的区别</strong></p>
<p>从概念上讲，<code>Bluestore</code>包含了<code>BlueFS</code>。<code>BlueFS</code>只是<code>Bluestore</code>的一部分。但是有时候，也会遇到这种情况，就是指<code>bluestore</code>负责用户过来的数据的存放。而<code>BlueFS</code>只负现元数据的处理。所以这两者在物理上可以放在一起，也可以放在不同的地方。</p>
<h1 id="Bluestore的元数据"><a href="#Bluestore的元数据" class="headerlink" title="Bluestore的元数据"></a>Bluestore的元数据</h1><p>在<code>bluestore</code>里面存放着很多元数据。在开始之前需要搞明白这些元数据的含义。</p>
<p><img src="/blog/img/bluestore-metadata.png" alt="Bluestore内部的元数据"></p>
<p>元数据的起因。在以前的<code>filestore</code>里面，由于数据是存放在现有的文件系统里面的。底层文件系统直接接了<code>管理元数据</code>的工作。那么现在好了，底层文件系统也要自己写了，<code>bluestore</code>也需要自己管理元数据了。</p>
<p>#Onode</p>
<p><code>Onode</code>是对应的数据块对应的元数据，一般而言，当进程运行的时候<code>Onode</code>是在内存里面的。为了避免丢失，也会保存到<code>rocksdb</code>里面。</p>
<p><strong>注意</strong>在代码里面<code>Onode</code>本身也是有元数据信息：<code>bluestore_onode_t</code>这个就是用来记录<code>Onoe</code>的元数据信息。并且会作为值放到<code>RocksDB</code>里面。<code>bluestore_onode_t onode;  ///&lt; metadata stored as value in kv store</code>。<code>key</code>就有可能使用的是：<code>string key;     ///&lt; key under PREFIX_OBJ where we are stored</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// an in-memory object</span></div><div class="line"><span class="keyword">struct</span> Onode &#123;</div><div class="line">  ExtentMap extent_map;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> boost::intrusive_ptr&lt;Onode&gt; OnodeRef;</div></pre></td></tr></table></figure>
<p>可以看出，<code>Onode</code>这个结构里面包含着<code>extent_map</code>。这个<code>map</code>结构里面记录着两个元数据信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">extent_map_t</span> extent_map;        <span class="comment">///&lt; map of Extents to Blobs</span></div><div class="line"><span class="keyword">blob_map_t</span> spanning_blob_map;   <span class="comment">///&lt; blobs that span shards</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Shard &#123;</div><div class="line">  <span class="built_in">string</span> key;            <span class="comment">///&lt; kv key</span></div><div class="line">  <span class="keyword">uint32_t</span> offset;       <span class="comment">///&lt; starting logical offset</span></div><div class="line">  <span class="keyword">bluestore_onode_t</span>::shard_info *shard_info;</div><div class="line">  <span class="keyword">bool</span> loaded = <span class="literal">false</span>;   <span class="comment">///&lt; true if shard is loaded</span></div><div class="line">  <span class="keyword">bool</span> dirty = <span class="literal">false</span>;    <span class="comment">///&lt; true if shard is dirty and needs reencoding</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;Shard&gt; shards;    <span class="comment">///&lt; shards</span></div></pre></td></tr></table></figure>
<h2 id="extent"><a href="#extent" class="headerlink" title="extent"></a>extent</h2><p><code>extent_map_t extent_map;</code>的类型为一个<code>set</code>，实际上就是保存了一系列的<code>Extent</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> boost::intrusive::<span class="built_in">set</span>&lt;Extent&gt; <span class="keyword">extent_map_t</span>;</div></pre></td></tr></table></figure>
<p>而<code>Extent</code>则是：<code>范围/长度</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// a logical extent, pointing to (some portion of) a blob</span></div><div class="line"><span class="comment">// 一个罗辑的长度。指向一个或者一个blob的某个位置。</span></div></pre></td></tr></table></figure>
<p>因此，代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// an in-memory object</span></div><div class="line"><span class="keyword">struct</span> Onode &#123;</div><div class="line">  ExtentMap extent_map;</div></pre></td></tr></table></figure>
<p>也就可以达到如下的效果：</p>
<p><img src="/blog/img/bluestore-onode-extent.jpeg" alt="Onode与extent的映射"></p>
<p>Extent的代码定义如下：实际上也是指向一个<code>Blob</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">  <span class="comment">/// a logical extent, pointing to (some portion of) a blob</span></div><div class="line">  <span class="keyword">struct</span> Extent : <span class="keyword">public</span> boost::intrusive::set_base_hook&lt;boost::intrusive::optimize_size&lt;<span class="literal">true</span>&gt;&gt; &#123;</div><div class="line">    <span class="keyword">uint32_t</span> logical_offset = <span class="number">0</span>;      <span class="comment">///&lt; logical offset</span></div><div class="line">    <span class="keyword">uint32_t</span> blob_offset = <span class="number">0</span>;         <span class="comment">///&lt; blob offset</span></div><div class="line">    <span class="keyword">uint32_t</span> length = <span class="number">0</span>;              <span class="comment">///&lt; length</span></div><div class="line">    <span class="keyword">uint8_t</span>  blob_depth = <span class="number">0</span>;          <span class="comment">///&lt; blob overlapping count</span></div><div class="line">    BlobRef blob;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是通过<code>BlobRef</code>记录了</p>
<h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><h3 id="引用方"><a href="#引用方" class="headerlink" title="引用方"></a>引用方</h3><p>在<code>ExtentMap</code>中，也记录了一系列<code>Blob</code>。而在每个<code>Extent</code>中，也会有一个<code>BlobRef</code>的指针，指向自己所属的<code>Blob</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">blob_map_t</span> spanning_blob_map;   <span class="comment">///&lt; blobs that span shards</span></div></pre></td></tr></table></figure>
<p>这个是一个<code>map</code>类型：<code>typedef std::map&lt;int,BlobRef&gt; blob_map_t;</code>。</p>
<h3 id="Blob的定义"><a href="#Blob的定义" class="headerlink" title="Blob的定义"></a>Blob的定义</h3><p><code>Blob</code>的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// in-memory blob metadata and associated cached buffers (if any)</span></div><div class="line"><span class="comment">// 需要注意的是，这个也只是一个常驻内存的blob的元数据。并且与缓存中的buffers产生联系。</span></div><div class="line"></div><div class="line">  <span class="keyword">struct</span> Blob &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">atomic_int</span> nref = &#123;<span class="number">0</span>&#125;;     <span class="comment">///&lt; reference count</span></div><div class="line">    <span class="keyword">int16_t</span> id = <span class="number">-1</span>;                <span class="comment">///&lt; id, for spanning blobs only, &gt;= 0</span></div><div class="line">    <span class="keyword">int16_t</span> last_encoded_id = <span class="number">-1</span>;   <span class="comment">///&lt; (ephemeral) used during encoding only</span></div><div class="line">    SharedBlobRef shared_blob;      <span class="comment">///&lt; shared blob state (if any)</span></div><div class="line"></div><div class="line">    <span class="comment">/// refs from this shard.  ephemeral if id&lt;0, persisted if spanning.</span></div><div class="line">    <span class="keyword">bluestore_extent_ref_map_t</span> ref_map;  <span class="comment">// 这里就是一个长度/refs记录。</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bluestore_blob_t</span> blob;  <span class="comment">///&lt; decoded blob metadata</span></div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> dirty = <span class="literal">true</span>;      <span class="comment">///&lt; true if blob is newer than blob_bl</span></div><div class="line">    <span class="keyword">mutable</span> bufferlist blob_bl;     <span class="comment">///&lt; cached encoded blob</span></div></pre></td></tr></table></figure>
<p>需要注意的是，这个也只是一个元数据类。<code>blog</code>真实的定义是放在：<code>bluestore_types.h</code>这个文件里面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// blob: a piece of data on disk</span></div><div class="line"><span class="keyword">struct</span> <span class="keyword">bluestore_blob_t</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">get_flags_string</span><span class="params">(<span class="keyword">unsigned</span> flags)</span></span>;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bluestore_pextent_t</span>&gt; extents;<span class="comment">///&lt; raw data position on device</span></div><div class="line">  <span class="keyword">bluestore_blob_t</span>(<span class="keyword">uint32_t</span> f = <span class="number">0</span>) : flags(f) &#123;&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>bluestore_blob_t</code>会引用一系列：<code>vector&lt;bluestore_pextent_t&gt; extents;///&lt; raw data position on device</code>。</p>
<p>也就是记录了多个<code>pextent</code>。blob里通过pextent对应到实际物理盘上的区域（pextent里就是offset和length来定位物理盘的位置区域）。一个onode里的多个lextent可能在同一个blob里，而一个blob也可能对应到多个pextent。</p>
<h2 id="pexent"><a href="#pexent" class="headerlink" title="pexent"></a>pexent</h2><p>那么再查看一下<code>pextent</code>的定义是怎么样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// pextent: physical extent</span></div><div class="line"><span class="keyword">struct</span> <span class="keyword">bluestore_pextent_t</span> : <span class="keyword">public</span> AllocExtent&#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>继承了<code>AllocExtent</code>这个类。而这个类的定义极其简单，也就是里面写明了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// offset, length.</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> AllocExtent &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">uint64_t</span> offset;</div><div class="line">  <span class="keyword">uint32_t</span> length;</div><div class="line"></div><div class="line">  AllocExtent() &#123;</div><div class="line">    offset = <span class="number">0</span>;</div><div class="line">    length = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  AllocExtent(<span class="keyword">int64_t</span> off, <span class="keyword">int32_t</span> len) : offset(off), length(len) &#123; &#125;</div><div class="line">  <span class="keyword">uint64_t</span> end() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> offset + length;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Gdb/">Gdb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Qemu/">Qemu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/bluestore-intro" data-title="Ceph Bluestore简介" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/MIT-6-828-JOS课程1：HW-Shell" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/10/05/mit.6.828/MIT-6-828-JOS课程1：HW-Shell/" class="article-date">
  	<time datetime="2016-10-05T12:31:35.000Z" itemprop="datePublished">2016-10-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/10/05/mit.6.828/MIT-6-828-JOS课程1：HW-Shell/">MIT 6.828 JOS课程1：HW Shell</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>作业要求：<a href="https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html</a><br>简单地来说，这次作业主要是分为以下几部分：</p>
<ul>
<li>阅读源代码</li>
<li>添加执行命令的功能</li>
<li>添加IO重定向</li>
<li>添加管道功能</li>
</ul>
<h1 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h1><p>源码位于：<a href="https://pdos.csail.mit.edu/6.828/2016/homework/sh.c" target="_blank" rel="external">MIT 6.828 shell</a><br>为了方便，也把源码上传到github上：<a href="https://github.com/JiYou/xv6-docs/blob/master/lession1/sh.c" target="_blank" rel="external">github</a>。</p>
<h2 id="命令的种类"><a href="#命令的种类" class="headerlink" title="命令的种类"></a>命令的种类</h2><h3 id="命令参数个数"><a href="#命令参数个数" class="headerlink" title="命令参数个数"></a>命令参数个数</h3><p>首先在这里需要明白，一个命令的参数总数是限制的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 10</span></div></pre></td></tr></table></figure>
<p>这里就指定了一个命令的参数最多只能有<code>10</code>个。</p>
<h3 id="命令的基类"><a href="#命令的基类" class="headerlink" title="命令的基类"></a>命令的基类</h3><p>所有的命令都必须有一个种类。这里声明一个<code>struct cmd</code>的作用是为了用来指向特定的某个<code>cmd</code>的类型。</p>
<p><strong>注意</strong>后面声明的<code>struct</code>都是在一个结构的开头<code>int</code>指明了一个<code>type</code>。后面可以把这个结构体在<code>struct *cmd</code>之间进行转换。个人感觉取巧了些。</p>
<ul>
<li>这里采用了<code>C++</code>的思想，也就是说，<code>struct cmd</code>是后面各种<code>execcmd, redircmd, pipecmd</code>的基类。后面要处理各种命令的时候，都是使用的是<code>struct *cmd</code>类型的指针。</li>
<li>此外就是。为了处理命令相互包含的情况。比如：<code>a|b|c</code>，这里面实际上应该是如下结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">pipecmd &#123;</div><div class="line">	- left = pipecmd &#123;</div><div class="line">				   - left: a</div><div class="line">				   - right: b</div><div class="line">			  &#125;</div><div class="line">   - right = execcmd &#123;</div><div class="line">   				   - cmd: c </div><div class="line">       	  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，每个子命令，都可以是<code>pipecmd</code>, <code>redircmd</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// All commands have at least a type. Have looked at the type, the code</span></div><div class="line"><span class="comment">// typically casts the *cmd to some specific cmd type.</span></div><div class="line"><span class="keyword">struct</span> cmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">//  ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="execcmd"><a href="#execcmd" class="headerlink" title="execcmd"></a>execcmd</h4><p>可以直接执行的命令。也就是说不存在IO重定向，管道等情况。所以这里的<code>type</code>注释写的是空格<code>&#39; &#39;</code>。重定向命令示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ls -al &gt;/tmp/res</div></pre></td></tr></table></figure>
<p>就是把<code>ls -al</code>的输出重定向到<code>/tmp/res</code>文件里去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> execcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;              <span class="comment">// ' '</span></div><div class="line">  <span class="keyword">char</span> *argv[MAXARGS];   <span class="comment">// arguments to the command to be exec-ed</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="redircmd"><a href="#redircmd" class="headerlink" title="redircmd"></a>redircmd</h4><p>重定向输入输出的命令。这里记录下的参数包含了：</p>
<ul>
<li>命令类型，重定向输入还是重定向输出？</li>
<li>要执行的命令</li>
<li>输入或者输出文件</li>
<li>打开文件的模式</li>
<li>文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> redircmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// &lt; or &gt;</span></div><div class="line">  <span class="keyword">struct</span> cmd *cmd;   <span class="comment">// the command to be run (e.g., an execcmd)</span></div><div class="line">  <span class="keyword">char</span> *file;        <span class="comment">// the input/output file</span></div><div class="line">  <span class="keyword">int</span> mode;          <span class="comment">// the mode to open the file with</span></div><div class="line">  <span class="keyword">int</span> fd;            <span class="comment">// the file descriptor number to use for the file</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>: 这里是否支持<code>cat &lt;&lt;&quot;EOF&quot;&gt;output</code>或者<code>cat &lt;&lt;&quot;EOF&quot;&gt;&gt;output</code>这种命令？请看后面的代码处理了。</p>
<h4 id="pipecmd"><a href="#pipecmd" class="headerlink" title="pipecmd"></a>pipecmd</h4><p><code>pipecmd</code>执行的时候是有重定向输出的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> pipecmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// |</span></div><div class="line">  <span class="keyword">struct</span> cmd *left;  <span class="comment">// left side of pipe</span></div><div class="line">  <span class="keyword">struct</span> cmd *right; <span class="comment">// right side of pipe</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h2><p>命令的执行则主要是在<code>runcmd</code>函数里面进行。<code>runcmd</code>里面逻辑很简单，就是根据命令的类型来决定执行何种操作。</p>
<ul>
<li>如果是未定义的命令类型，直接报错，并退出。</li>
<li>如果是<code>execcmd</code>类型，需要添加执行代码。实际上作业需要完成的代码也是在这里完成。</li>
<li><code>&#39;&gt;&#39;和&#39;&lt;&#39;</code>表示输入输出重定向。</li>
<li><code>&#39;|&#39;</code>管道操作，就是把前面一个程序的输出，重定向为后面一个程序的输入。</li>
</ul>
<p>上面这些功能，都处于未完成的状态。都还需要添加代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Execute cmd.  Never returns.</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> p[<span class="number">2</span>], r;</div><div class="line">  <span class="keyword">struct</span> execcmd *ecmd;</div><div class="line">  <span class="keyword">struct</span> pipecmd *pcmd;</div><div class="line">  <span class="keyword">struct</span> redircmd *rcmd;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</div><div class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</div><div class="line">    <span class="comment">// Your code here ...</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"redir not implemented\n"</span>);</div><div class="line">    <span class="comment">// Your code here ...</span></div><div class="line">    runcmd(rcmd-&gt;cmd);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pipe not implemented\n"</span>);</div><div class="line">    <span class="comment">// Your code here ...</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="命令的获取"><a href="#命令的获取" class="headerlink" title="命令的获取"></a>命令的获取</h2><p>这里主要从终端中读取需要执行的命令。<code>getcmd</code>只做三件事情：</p>
<ul>
<li>判断是不是终端，如果是，那么输出<code>&quot;6.828$</code>提标符。</li>
<li>清空内存，然后读取输入。</li>
<li>判断是不是读入了<code>EOF</code>结束标志。如果是，返回<code>-1</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">getcmd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isatty(fileno(<span class="built_in">stdin</span>)))</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"6.828$ "</span>);</div><div class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</div><div class="line">  fgets(buf, nbuf, <span class="built_in">stdin</span>);</div><div class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>主程序比较简单：主要是分成两部分：</p>
<ul>
<li>查看是不是<code>cd</code>命令，如果是，那么调用<code>chdir</code>系统调用。</li>
<li>否则调用<code>fork</code>，利用子进程<code>rumcmd</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</div><div class="line">  <span class="keyword">int</span> fd, r;</div><div class="line"></div><div class="line">  <span class="comment">// Read and run input commands.</span></div><div class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</div><div class="line">      <span class="comment">// Clumsy but will have to do for now.</span></div><div class="line">      <span class="comment">// Chdir has no effect on the parent if run in the child.</span></div><div class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></div><div class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"cannot cd %s\n"</span>, buf+<span class="number">3</span>);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">      runcmd(parsecmd(buf));</div><div class="line">    wait(&amp;r);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="取词程序"><a href="#取词程序" class="headerlink" title="取词程序"></a>取词程序</h2><p>接下来便是<code>gettoken</code>函数，这个函数的工作流程：</p>
<ul>
<li>跳过前面的空白符。修改q指针，指向非空白字符，作为开始。 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// skip the whitespace.</span></div><div class="line">s = *ps;</div><div class="line"><span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">  s++;</div><div class="line"><span class="comment">// s point to the nun-space charater.</span></div><div class="line"><span class="comment">// q point to the begin of nun-space string.</span></div><div class="line"><span class="keyword">if</span>(q)</div><div class="line">  *q = s;</div></pre></td></tr></table></figure>
<ul>
<li>返回值指向第一个非空白字符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">ret = *s;</div></pre></td></tr></table></figure>
<ul>
<li>如查是字符串的结尾，那么直接返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="number">0</span>:   <span class="comment">// end of string.</span></div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果是<code>|&lt;&gt;</code>，那么s向后移一位。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'|'</span>: <span class="comment">// pipe</span></div><div class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="comment">// I/O redirection.</span></div><div class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">  s++;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果是普通命令/参数，那么直接取出整个命令/参数。注意这里设置的返回值为<code>&#39;a&#39;</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">default</span>:</div><div class="line">  ret = <span class="string">'a'</span>;</div><div class="line">  <span class="comment">// find out the position of character. which is not space or &lt;&gt;|.</span></div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; !<span class="built_in">strchr</span>(whitespace, *s) &amp;&amp; !<span class="built_in">strchr</span>(symbols, *s))</div><div class="line">    s++;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<ul>
<li>结束指针指向要取出的<code>token</code>的结束位置。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(eq)</div><div class="line">  *eq = s;</div></pre></td></tr></table></figure>
<ul>
<li>跳过空白符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// skip the space.</span></div><div class="line"><span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">  s++;</div></pre></td></tr></table></figure>
<ul>
<li>重新设置起始字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// set the new start.</span></div><div class="line">*ps = s;</div><div class="line"><span class="keyword">return</span> ret;</div></pre></td></tr></table></figure>
<p>完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">gettoken</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es, <span class="keyword">char</span> **q, <span class="keyword">char</span> **eq)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  <span class="comment">// skip the whitespace.</span></div><div class="line">  s = *ps;</div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  <span class="comment">// s point to the nun-space charater.</span></div><div class="line"></div><div class="line">  <span class="comment">// q point to the begin of nun-space string.</span></div><div class="line">  <span class="keyword">if</span>(q)</div><div class="line">    *q = s;</div><div class="line"></div><div class="line">  ret = *s;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span>(*s)&#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>:   <span class="comment">// end of string.</span></div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'|'</span>: <span class="comment">// pipe</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>: <span class="comment">// I/O redirection.</span></div><div class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    ret = <span class="string">'a'</span>;</div><div class="line">    <span class="comment">// find out the position of character. which is not space or &lt;&gt;|.</span></div><div class="line">    <span class="keyword">while</span>(s &lt; es &amp;&amp; !<span class="built_in">strchr</span>(whitespace, *s) &amp;&amp; !<span class="built_in">strchr</span>(symbols, *s))</div><div class="line">      s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(eq)</div><div class="line">    *eq = s;</div><div class="line"></div><div class="line">  <span class="comment">// skip the space.</span></div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line"></div><div class="line">  <span class="comment">// set the new start.</span></div><div class="line">  *ps = s;</div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h2><p><code>peek</code>只做如下事情：</p>
<ul>
<li>找到非空白字符</li>
<li>然后移动字符串头指针</li>
<li>查看找到的第一个非空字符是不是在<code>toks</code>字符串里面</li>
</ul>
<p>所以，简单地来说，<code>peek</code>只做：找到第一个非空字符，然后查看一下这个字符是不是在<code>toks</code>里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es, <span class="keyword">char</span> *toks)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line"></div><div class="line">  s = *ps;</div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  *ps = s;</div><div class="line">  <span class="keyword">return</span> *s &amp;&amp; <span class="built_in">strchr</span>(toks, *s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解析程序"><a href="#解析程序" class="headerlink" title="解析程序"></a>解析程序</h2><p>接下来应该就是解析每个命令，根据前面的阅读，可以知道，命令主要是分为三类：</p>
<ul>
<li>直接可执行命令</li>
<li>重定向命令</li>
<li>管道符</li>
</ul>
<p>所以，相对的解析程序也是分为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parseline</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parseexec</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>在开始解析之前，还是有一些准备代码需要操作：</p>
<h4 id="字符串拷贝"><a href="#字符串拷贝" class="headerlink" title="字符串拷贝"></a>字符串拷贝</h4><p>程序很简单，就是直接拷贝一个字符串。注意的是，在拷贝的时候，自动追加了结束符0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// make a copy of the characters in the input buffer, starting from s through es.</span></div><div class="line"><span class="comment">// null-terminate the copy to make it a string.</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkcopy</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *es)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> n = es - s;</div><div class="line">  <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(n+<span class="number">1</span>);</div><div class="line">  assert(c);</div><div class="line">  <span class="built_in">strncpy</span>(c, s, n);</div><div class="line">  c[n] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="parsecmd"><a href="#parsecmd" class="headerlink" title="parsecmd"></a>parsecmd</h4><p><code>parsecmd</code>是整个解析程序的入口，可以认为是词法分析程序的入口地址。然而，有意思的是<code>parsecmd</code>也只做一件事情，就是调用<code>parseline</code>去做真正的解析，其他啥事也不做。只是在<code>parseline</code>完成之后，检查一下字符串指针是否是指向了结尾处。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsecmd</span><span class="params">(<span class="keyword">char</span> *s)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *es;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  es = s + <span class="built_in">strlen</span>(s);</div><div class="line">  cmd = parseline(&amp;s, es);</div><div class="line">  peek(&amp;s, es, <span class="string">""</span>);</div><div class="line">  <span class="keyword">if</span>(s != es)&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"leftovers: %s\n"</span>, s);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="parseline"><a href="#parseline" class="headerlink" title="parseline"></a>parseline</h3><p><code>parseline</code>要做的第一件事情是把工作交给<code>parsepipe</code>。也就是首先去作管道的工作。做完之后，直接返回解析成功的命令。所以直接的解析工作也就落在了<code>parsepipe</code>函数上。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseline</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">  cmd = parsepipe(ps, es);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="parsepipe"><a href="#parsepipe" class="headerlink" title="parsepipe"></a>parsepipe</h3><p><code>parsepipe</code>命令的执行也很简单，也就是调用<code>parseexec</code>函数。然后再查看一下是否存在管道的情况。如果存在，那么生成<code>pipecmd</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parseexec(ps, es);</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="parseredir"><a href="#parseredir" class="headerlink" title="parseredir"></a>parseredir</h3><p><code>parseredir</code>这个函数主要是把重定向命令解析出来。函数工作的流程：</p>
<ul>
<li>首先利用peek查看第一个非空字符是不是<code>&lt;&gt;</code>。如果不是，那么直接返回原始命令。</li>
<li>如果是重定向符号<code>&lt;&gt;</code>。那么开始进入while流程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//这里可能会有疑问，就是比如运行的命令是`ls -al &gt;/tmp/res`。命令的一开始并不是&quot;&lt;&gt;&quot;符号啊。</div><div class="line">//实际上ls -al这条命令会存放在传入进来的参数`cmd`中。</div><div class="line">//当parseredirs开始处理的时候，接手到的字符已经是从`&gt;/tmp/res`开始了。</div><div class="line">//最终解析的结果就是</div><div class="line">redircmd &#123;</div><div class="line">	- execcmd &#123; `ls -al` &#125;</div><div class="line">	- file &#123; `/tmp/res`&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">示例1:</div><div class="line"></div><div class="line">如果放进来的命令是`ls -al &gt; /tmp/res`。那么得到的结果是：</div><div class="line"></div><div class="line">redircmd &#123;</div><div class="line">	- execcmd &#123; `ls -al` &#125;</div><div class="line">	- file &#123; `/tmp/res`&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">示例2:</div><div class="line"></div><div class="line">如果放进来的命令是`sort &lt; input.txt &gt; output.txt`。那么最后得到的结果是：</div><div class="line"></div><div class="line">redircmd &#123;</div><div class="line">	- redircmd &#123;</div><div class="line">		 	- execcmd &#123; `sort` &#125;</div><div class="line">		 	- file &#123; `input.txt` &#125;</div><div class="line">	  &#125;</div><div class="line">	- file &#123; `output.txt` &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>parseredir的全部源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd* <span class="title">parseredirs</span><span class="params">(<span class="keyword">struct</span> cmd *cmd, <span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> tok;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(peek(ps, es, <span class="string">"&lt;&gt;"</span>))&#123;</div><div class="line">    tok = gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class="string">'a'</span>) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"missing file for redirection\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span>(tok)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">      cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&lt;'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">      cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&gt;'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="parseexec"><a href="#parseexec" class="headerlink" title="parseexec"></a>parseexec</h3><p><code>parseexec</code>命令的执行主要是解析整个命令的关键：</p>
<ul>
<li>首先查看一下是否存在重定向的情况。</li>
<li>如果发现是管道操作，那么立即退回<code>parsepipe</code>那里接着处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cmd = parseexec(ps, es);</div><div class="line"><span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">  gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要考虑一下<code>parsepipe</code>的处理。也就是一直使用了递归调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseexec</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line">  <span class="keyword">int</span> tok, argc;</div><div class="line">  <span class="keyword">struct</span> execcmd *cmd;</div><div class="line">  <span class="keyword">struct</span> cmd *ret;</div><div class="line"></div><div class="line">  ret = execcmd();</div><div class="line">  cmd = (<span class="keyword">struct</span> execcmd*)ret;</div><div class="line"></div><div class="line">  argc = <span class="number">0</span>;</div><div class="line">  ret = parseredirs(ret, ps, es);</div><div class="line">  <span class="keyword">while</span>(!peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    <span class="keyword">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class="number">0</span>)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">if</span>(tok != <span class="string">'a'</span>) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class="line">    argc++;</div><div class="line">    <span class="keyword">if</span>(argc &gt;= MAXARGS) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"too many args\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    ret = parseredirs(ret, ps, es);</div><div class="line">  &#125;</div><div class="line">  cmd-&gt;argv[argc] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/blog/img/parse-arch.jpeg" alt="函数调用图"></p>
<p>通过这个调用图可以看出命令处理的层次结构。</p>
<ul>
<li>首先根据<code>|</code>管道来切分块。比如<code>{block_a} | {block_b} | {block_c} | {block_d}</code>。处理逻辑不是通过<code>for</code>循环来处理，而是通过递归调用来解决。每一个<code>block</code>的处理都是通过<code>parseexec</code>来完成。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parseexec(ps, es);</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>parseexec</code>处理的时候，代码里面是同时处理了<code>execcmd</code>, <code>redircmd</code>这两种命令。也就是说，如果从<code>C++</code>的角度来看，类的继承关系就是：<code>cmd-&gt;execcmd-&gt;redircmd</code>。而<code>pipecmd</code>则是类似于：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> pipecmd : <span class="keyword">public</span> cmd</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	execcmd *left;</div><div class="line">	execcmd *right;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>每个<code>block</code>的处理方式如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">argc = <span class="number">0</span>;</div><div class="line">ret = parseredirs(ret, ps, es);</div><div class="line"><span class="keyword">while</span>(!peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">  <span class="keyword">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class="number">0</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">if</span>(tok != <span class="string">'a'</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class="line">  argc++;</div><div class="line">  <span class="keyword">if</span>(argc &gt;= MAXARGS) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"too many args\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  ret = parseredirs(ret, ps, es);</div><div class="line">&#125;</div><div class="line">cmd-&gt;argv[argc] = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<ul>
<li>如果没有IO重定向，那么<code>parseredirs</code>函数相当于空函数。没有任何作用。</li>
<li><code>parseredirs</code>的处理就比较简单，就只负责处理<code>execcmd</code>的<code>&lt;input.txt</code>或者<code>&gt;output.txt</code>部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(peek(ps, es, <span class="string">"&lt;&gt;"</span>))&#123;</div><div class="line">  tok = gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class="string">'a'</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"missing file for redirection\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">switch</span>(tok)&#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">    cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&lt;'</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&gt;'</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="打印命令的函数"><a href="#打印命令的函数" class="headerlink" title="打印命令的函数"></a>打印命令的函数</h2><p>通过递归，可以很容易地实现打印函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">struct</span> execcmd *xcmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line">  <span class="keyword">struct</span> redircmd *rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">  <span class="keyword">struct</span> pipecmd *pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">  <span class="keyword">switch</span> (cmd-&gt;type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line">      <span class="keyword">while</span> (xcmd-&gt;argv[i]) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s "</span>, xcmd-&gt;argv[i]);</div><div class="line">        i++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">      printcmd(rcmd-&gt;cmd);</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%c "</span>, cmd-&gt;type);</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s"</span>, rcmd-&gt;file);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">      printcmd(pcmd-&gt;left);</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"|"</span>);</div><div class="line">      printcmd(pcmd-&gt;right);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>看懂了程序结构，接下来开始实现作业的各种功能。</p>
<h2 id="execute-cmd"><a href="#execute-cmd" class="headerlink" title="execute cmd"></a>execute cmd</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">6.828</span>$ /bin/ls</div><div class="line">This should execute the program /bin/ls, which should print out the file names in your working directory. You can stop the <span class="number">6.828</span> shell by typing ctrl-d, which should put you back in your computer's shell.</div><div class="line"></div><div class="line">You may want to change the <span class="number">6.828</span> shell to always <span class="keyword">try</span> /bin, <span class="keyword">if</span> the program doesn't exist in the current working directory, so that below you don't have to type <span class="string">"/bin"</span> <span class="keyword">for</span> each program. If you are ambitious you can implement support <span class="keyword">for</span> a PATH variable.</div></pre></td></tr></table></figure>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>这里采用<code>execvp</code>函数来实现。实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// rumcmd</span></div><div class="line"></div><div class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</div><div class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    execvp(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);  <span class="comment">// &lt;-- execute command here.</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</div><div class="line">    <span class="built_in">exit</span> (<span class="number">1</span>);</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h3 id="exit的实现"><a href="#exit的实现" class="headerlink" title="exit的实现"></a>exit的实现</h3><p>实际上，并没有一个程序是<code>exit</code>，所以<code>exit</code>程序还是需要在<code>sh.c</code>里面实现。在开始解析命令的时候，应该可以把首尾的空白符去掉。去掉的函数为<code>trim</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 这个函数的作用就是清除头尾两端的空白符。</span></div><div class="line"><span class="comment">// 原地处理字符串。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> newiter = <span class="number">0</span>, previous_ok = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// &lt;&lt;找到开头的非空白符</span></div><div class="line">  <span class="keyword">while</span> (buf[begin]) &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">isspace</span>(buf[begin])) <span class="keyword">break</span>;</div><div class="line">    begin++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 从开头的非空白符处开始复制。</span></div><div class="line">  <span class="comment">// 这里需要通过previous_ok查看前面一个字符是否是非空白符（1)</span></div><div class="line">  <span class="comment">// 那么有两种情况是需要复制字符的。</span></div><div class="line">  <span class="comment">// a. 非空白符</span></div><div class="line">  <span class="comment">// b. 当前要复制的是空白符，并且前面一个是非空白符。</span></div><div class="line">  newiter = begin;</div><div class="line">  <span class="keyword">while</span> (buf[begin]) &#123;</div><div class="line">    <span class="keyword">if</span> (previous_ok || !<span class="built_in">isspace</span>(buf[begin])) &#123;</div><div class="line">      buf[newiter] = buf[begin];</div><div class="line">      newiter++;</div><div class="line">    &#125;</div><div class="line">    previous_ok = !<span class="built_in">isspace</span>(buf[begin]);</div><div class="line">    begin++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  buf[newiter] = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 从末尾向前找，把所有的空白符设置为0。</span></div><div class="line">  <span class="comment">// 也就是为了清除尾部的空白符。</span></div><div class="line">  end = newiter - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(buf[end])) &#123;</div><div class="line">    buf[end] = <span class="number">0</span>;</div><div class="line">    --end;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了实现<code>exit</code>，需要在<code>getcmd</code>之后，检查命令是否是<code>exit</code>，如果是，则调用<code>exit(0);</code>函数。在<code>main</code>函数中添加代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</div><div class="line">  trim(buf);</div><div class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(buf, <span class="string">"exit"</span>)) &#123;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</div></pre></td></tr></table></figure>
<h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><p>作业要求如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Now you should be able to run the following command correctly:</div><div class="line"></div><div class="line">6.828$ a.out &lt; t.sh</div><div class="line">Make sure you use the right absolute pathnames for the programs.</div><div class="line"></div><div class="line">Don&apos;t forget to submit your solution to the submission web site (using the &quot;hwN.c&quot; naming convention as outlined above), with or without challenge solutions.</div></pre></td></tr></table></figure>
<p><code>IO重定向操作是sort &lt;input.txt&gt;output.txt</code>。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><code>runcmd</code>中添加如下代码。代码的实现逻辑比较简单，就是先关掉<code>redircmd</code>中需要关闭的<code>fd</code>。再次打开文件的时候，这个进程会选择最小的文件描述符。所以会选中刚关掉的文件描述符。做好之后，然后再运行<code>redircmd</code>中的子命令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">  rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">  close(rcmd-&gt;fd);</div><div class="line">  open(rcmd-&gt;file, rcmd-&gt;mode, S_IRWXU);</div><div class="line">  runcmd(rcmd-&gt;cmd);</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道的实现需要借助于<code>pipe()</code>函数。需要注意的是，根据<code>parsepipe</code>解析的结果，最后的结果应该是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">&#123;left1, &#123;left2, &#123;left3, right2&#125;&#125;&#125;</div><div class="line">                 |<span class="number">___</span>right2__|</div><div class="line">         |<span class="number">________</span>right1______|</div></pre></td></tr></table></figure>
<p>这里需要注意的是，实际上<code>pcmd-&gt;right</code>的执行是不需要额外再用一个进程。因为<code>runcmd</code>递归调用会再起动一个进程。所以这里不需要再启动一个进程。参考《Unix系统编程》第十一章代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">	count = makeargv(cmds, <span class="string">"|"</span>, &amp;pipelist);</div><div class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;              <span class="comment">/* handle all but last one */</span></div><div class="line">      <span class="keyword">if</span> (pipe(fds) == <span class="number">-1</span>)</div><div class="line">         perror_exit(<span class="string">"Failed to create pipes"</span>);</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((child = fork()) == <span class="number">-1</span>)</div><div class="line">         perror_exit(<span class="string">"Failed to create process to run command"</span>);</div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (child) &#123;                                       <span class="comment">/* parent code */</span></div><div class="line">         <span class="keyword">if</span> (dup2(fds[<span class="number">1</span>], STDOUT_FILENO) == <span class="number">-1</span>)</div><div class="line">            perror_exit(<span class="string">"Failed to connect pipeline"</span>);</div><div class="line">         <span class="keyword">if</span> (close(fds[<span class="number">0</span>]) || close(fds[<span class="number">1</span>]))</div><div class="line">            perror_exit(<span class="string">"Failed to close needed files"</span>);</div><div class="line">         executeredirect(pipelist[i], i==<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (dup2(fds[<span class="number">0</span>], STDIN_FILENO) == <span class="number">-1</span>)                    <span class="comment">/* child code */</span></div><div class="line">         perror_exit(<span class="string">"Failed to connect last component"</span>);</div><div class="line">      <span class="keyword">if</span> (close(fds[<span class="number">0</span>]) || close(fds[<span class="number">1</span>]))</div><div class="line">         perror_exit(<span class="string">"Failed to do final close"</span>);</div><div class="line">   &#125;</div><div class="line">   executeredirect(pipelist[i], i==<span class="number">0</span>, <span class="number">1</span>);             <span class="comment">/* handle the last one */</span></div><div class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，真正实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">  pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">  pipe(pipefd);</div><div class="line">  <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</div><div class="line">    close(pipefd[<span class="number">0</span>]);   <span class="comment">// close input</span></div><div class="line">    dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// copy output</span></div><div class="line">    close(pipefd[<span class="number">1</span>]);   <span class="comment">// close old output</span></div><div class="line">    runcmd(pcmd-&gt;left);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    close(pipefd[<span class="number">1</span>]);   <span class="comment">// close output</span></div><div class="line">    dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// copy input</span></div><div class="line">    close(pipefd[<span class="number">0</span>]);   <span class="comment">// close old input</span></div><div class="line">    runcmd(pcmd-&gt;right);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>后面有空可以再看一下<code>bash</code>源码是如何处理这个的。</p>
<h1 id="进阶作业"><a href="#进阶作业" class="headerlink" title="进阶作业"></a>进阶作业</h1><p>进阶作业主要是完成三个：</p>
<ul>
<li>实现分号。比如运行<code>ls ; ls | sort; who</code>这种把多个命令放在一起的情况。</li>
<li>实现<code>subshell</code>，比如<code>(ls|wc -l)</code>。</li>
<li>实现后台运行，比如<code>ls &amp;</code>。以及实现<code>wait</code>。</li>
</ul>
<h2 id="作业1-分号的实现"><a href="#作业1-分号的实现" class="headerlink" title="作业1: 分号的实现"></a>作业1: 分号的实现</h2><p>分号的实现，首先要在思路上要清楚。</p>
<ul>
<li>当得到一行输入之后，首先应该是处理分号。<code>block_a ; block_a; block_a</code></li>
<li>得到<code>block_a</code>之后，再对每个<code>block_a</code>做管道的切分，也就是说：<code>block_a = block_b | block_b | block_b</code>。</li>
<li>得到每个<code>block_b</code>之后，<code>block_b</code>一般就只有两种情况，<code>带重定向｜不带重定向</code>。</li>
</ul>
<p>所以在处理分号的时候，需要分以下步骤：这里把分号对应的命令设置为<code>listcmd</code>。</p>
<ul>
<li>定义<code>listcmd</code>的结构.</li>
<li>如何生成这种类型</li>
<li>如何解析</li>
<li>如何<code>runcmd(listcmd *cmd)</code></li>
</ul>
<h3 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h3><p>由于分号是众多命令放在一行，那么肯定是需要链表结构来处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> listcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// ;</span></div><div class="line">  <span class="keyword">struct</span> cmd *cmd;   <span class="comment">// the command to be run. (e.g., an pipecmd)</span></div><div class="line">  <span class="keyword">struct</span> cmd *next;  <span class="comment">// next command position.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>type</code>指明命令的类型。</li>
<li><code>cmd</code>指明需要运行的命令。</li>
<li><code>next</code>指明下一个需要执行的命令。</li>
</ul>
<h3 id="Token的处理"><a href="#Token的处理" class="headerlink" title="Token的处理"></a>Token的处理</h3><p><code>token</code>的处理比较简单。只是在<code>gettoken</code>里面多添加一个<code>case</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">  s++;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h3 id="命令的运行"><a href="#命令的运行" class="headerlink" title="命令的运行"></a>命令的运行</h3><p>命令的运行需要添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">    head = cmd;</div><div class="line">    <span class="keyword">while</span> (head) &#123;</div><div class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</div><div class="line">          runcmd(((<span class="keyword">struct</span> listcmd*)head)-&gt;cmd);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          wait(&amp;waitv);</div><div class="line">          temp = head;</div><div class="line">          head = ((<span class="keyword">struct</span> listcmd*)head)-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方法比较简单，就是一个循环。当执行命令的时候，就生成一个新的进程。然后把指针移动到下一个命令，直接指针为空。</p>
<h3 id="命令的解析"><a href="#命令的解析" class="headerlink" title="命令的解析"></a>命令的解析</h3><h4 id="第一级解析"><a href="#第一级解析" class="headerlink" title="第一级解析"></a>第一级解析</h4><p>在解析命令的时候，<code>parseline</code>的第一个要解析的对象，就应该是<code>parselist</code>。因为分号是第一级切分对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseline</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">  cmd = parselist(ps, es);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="listcmd的解析"><a href="#listcmd的解析" class="headerlink" title="listcmd的解析"></a>listcmd的解析</h4><p><code>listcmd</code>的解析则比较简单，就是先<code>parsepipe</code>作为第一个命令。然后再依次按照分号解析<code>parsepipe</code>则可。中间需要添加的操作就是把每个<code>parsepipe</code>生成的命令放到链表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parselist</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> cmd *cmd = <span class="number">0</span>, *ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *tail = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *temp = <span class="number">0</span>;</div><div class="line"></div><div class="line">    cmd = parsepipe(ps, es);</div><div class="line"></div><div class="line">    head = (<span class="keyword">struct</span> listcmd*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listcmd));</div><div class="line">    head-&gt;type = <span class="string">';'</span>;</div><div class="line">    head-&gt;next = <span class="number">0</span>;</div><div class="line">    head-&gt;cmd = cmd;</div><div class="line">    tail = head;</div><div class="line"></div><div class="line">    ret = (<span class="keyword">struct</span> cmd*)head;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(peek(ps, es, <span class="string">";"</span>)) &#123;</div><div class="line">        gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        temp = (<span class="keyword">struct</span> listcmd*)parselist(ps, es);</div><div class="line">        tail-&gt;next = (<span class="keyword">struct</span> cmd*)temp;</div><div class="line">        tail = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的编写是参考了<code>parsepipe</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parseexec(ps, es);</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加的代码部分就是添加链表操作那里。</p>
<h4 id="parseexec-1"><a href="#parseexec-1" class="headerlink" title="parseexec"></a>parseexec</h4><p><code>parseexec</code>处理的时候，要注意把更高级的分隔符给处理掉。</p>
<ul>
<li>一级分隔符<code>;</code></li>
<li>二级分隔符<code>|</code></li>
</ul>
<p>所以要添加的代码如下：只需要修改<code>parseexec</code>的<code>while</code>循环就可以了。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(!peek(ps, es, <span class="string">"|;"</span>))&#123;</div></pre></td></tr></table></figure>
<h4 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h4><p>在最开始的<code>sh.c</code>的代码里面是没有对内存的释放进行任何的处理的。这里需要对<code>runcmd</code>函数执行完成命令的之后，释放掉内存。<br>需要注意的是：由于是多进程，在释放内存的时候，一定要注意，<code>runcmd</code>每次运行，只负责把自己当前运行的命令的内存释放掉。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> pipecmd &#123;</div><div class="line">	<span class="keyword">struct</span> cmd *left;</div><div class="line">	<span class="keyword">struct</span> cmd *right;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在释放的时候，如果是执行<code>pipecmd</code>，那么<code>pipecmd</code>就在当前进程释放掉。而<code>left</code>，<code>right</code>需要在各自的子进程的<code>execcmd</code>那里释放掉。这里放了<code>runcmd</code>里面完整的代码。包含了内存释放的操作。需要注意的是：<code>execcmd</code>的内存释放是处于最底层。实际上每个命令参数都是<code>mkcopy</code>而来，所以在处理时，需要把这些命令参数放到一个<code>char *</code>数组里面去，而这个数组本身不能是动态申请的内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Execute cmd.  Never returns.</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> p[<span class="number">2</span>], r, j;</div><div class="line">    <span class="keyword">struct</span> execcmd *ecmd;</div><div class="line">    <span class="keyword">struct</span> pipecmd *pcmd;</div><div class="line">    <span class="keyword">struct</span> redircmd *rcmd;</div><div class="line">    <span class="keyword">struct</span> cmd *head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *tail = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *leftcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *rightcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *subcmd = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> shellcmd[MAXARGS][<span class="number">100</span>];</div><div class="line">    <span class="keyword">char</span> *ppcmd[MAXARGS];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> waitv;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(cmd == <span class="number">0</span>)</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(cmd-&gt;type) &#123;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line">        ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line"></div><div class="line">        <span class="comment">// if no comand need to run.</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == ecmd-&gt;argv[<span class="number">0</span>]) &#123;</div><div class="line">          <span class="built_in">free</span>(ecmd);</div><div class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// clean the memory.</span></div><div class="line">        <span class="built_in">memset</span>(shellcmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(shellcmd));</div><div class="line"></div><div class="line">        <span class="comment">// copy comamnd and freeup memory.</span></div><div class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; MAXARGS; ++r) &#123;</div><div class="line">          <span class="keyword">if</span> (ecmd-&gt;argv[r]) &#123;</div><div class="line">            <span class="comment">// copy the command.</span></div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; ecmd-&gt;argv[r][j]; j++) &#123;</div><div class="line">              shellcmd[r][j] = ecmd-&gt;argv[r][j];</div><div class="line">            &#125;</div><div class="line">            shellcmd[r][j] = <span class="number">0</span>;</div><div class="line">            ppcmd[r] = shellcmd[r];</div><div class="line">            <span class="built_in">free</span>(ecmd-&gt;argv[r]);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(ecmd);</div><div class="line">        ppcmd[r] = <span class="number">0</span>;</div><div class="line"></div><div class="line">        execvp(ppcmd[<span class="number">0</span>], ppcmd);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</div><div class="line">        <span class="built_in">exit</span> (<span class="number">1</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">        rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">        close(rcmd-&gt;fd);</div><div class="line">        open(rcmd-&gt;file, rcmd-&gt;mode, S_IRWXU);</div><div class="line">        subcmd = rcmd-&gt;cmd;</div><div class="line"></div><div class="line">        <span class="built_in">free</span>(rcmd-&gt;file);</div><div class="line">        <span class="built_in">free</span>(rcmd);</div><div class="line">        runcmd(subcmd);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">        pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">        pipe(pipefd);</div><div class="line"></div><div class="line">        <span class="comment">// record the subcmd.</span></div><div class="line">        <span class="comment">// free now cmd.</span></div><div class="line">        leftcmd = pcmd-&gt;left;</div><div class="line">        rightcmd = pcmd-&gt;right;</div><div class="line">        <span class="built_in">free</span>(pcmd);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;     <span class="comment">// child process run leftcmd.</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close input</span></div><div class="line">            dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// copy output</span></div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close old output</span></div><div class="line">            runcmd(leftcmd);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// parent process run rightcmd.</span></div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close output</span></div><div class="line">            dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// copy input</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close old input</span></div><div class="line">            runcmd(rightcmd);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">        head = cmd;</div><div class="line">        <span class="keyword">while</span> (head) &#123;</div><div class="line">            <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</div><div class="line">              runcmd(((<span class="keyword">struct</span> listcmd*)head)-&gt;cmd);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              wait(&amp;waitv);</div><div class="line">              temp = head;</div><div class="line">              head = ((<span class="keyword">struct</span> listcmd*)head)-&gt;next;</div><div class="line"></div><div class="line">              <span class="comment">// free memory.</span></div><div class="line">              <span class="built_in">free</span>(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="作业2-Subshell"><a href="#作业2-Subshell" class="headerlink" title="作业2: Subshell"></a>作业2: Subshell</h2><p><code>subshell</code>有好几种，这里应该指的就是使用<code>(ls; ls | wc -l)</code>这种情况了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">命令组（Command group）。由一组圆括号括起来的命令是命令组，命令组中的命令实在子shell（subshell）中执行。因为是在子shell内运行，因此在括号外面是没有办法获取括号内变量的值，但反过来，命令组内是可以获取到外面的值，这点有点像局部变量和全局变量的关系，在实作中，如果碰到要cd到子目录操作，并在操作完成后要返回到当前目录的时候，可以考虑使用subshell来处理；</div></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果遇到命令组，最简单的实现，应该就是：比如用户输入<code>(ls | wc -l; ls); echo ok</code>。前面那个<code>subshell</code>作为一组<code>pipecmd</code>。</p>
<ul>
<li>把命令的输入作为<code>echo</code>的参数。那么这个时候，<code>echo ls | wc -l; ls</code>。如果要更友好一点，应该是一个进程通过管道把命令写给subshell进程 ，后面将采用这种方式。</li>
<li>启动当前二进制程序，然后作为<code>pipecmd</code>的<code>rightcmd</code>。</li>
</ul>
<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><p>在进行切分的时候，<code>subshell</code>应该是作为一个整体的。所以这里等级上应该是与<code>execcmd, redircmd</code>处于同一个等级。</p>
<ul>
<li>最高级<code>listcmd</code></li>
<li>次之<code>pipecmd</code></li>
<li><code>execmd, redircmd, subshellcmd</code>这三个。</li>
</ul>
<p><strong>注意</strong>，这里并不去处理比较复杂的情况，比如注释，引号中包含特殊字符的情况。比如<code>echo &quot;ok ; ok&quot;</code>在当前的程序执行就会失败。</p>
<h3 id="添加结构体定义"><a href="#添加结构体定义" class="headerlink" title="添加结构体定义"></a>添加结构体定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> subshellcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// ( or )</span></div><div class="line">  <span class="keyword">char</span> *cmdstr;      <span class="comment">// commands will be executed in subshell.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="如何执行subshell"><a href="#如何执行subshell" class="headerlink" title="如何执行subshell"></a>如何执行subshell</h3><p>如何运行<code>subshell</code>。主要是分为两步：</p>
<ul>
<li>创建一个管道数组</li>
<li>新建一个子进程，启动的就是当前<code>bash</code>程序。简单起见，最好是用绝对路径。否则<code>cd</code>之后，会找不到<code>./testshell</code>。</li>
<li>父进程把得到的<code>subshell</code>字符串写入管道。</li>
<li>写完之后，开始等待子进程结束。</li>
</ul>
<p>在文件的开头写明当前可执行文件的路径：(这里为了简单，直接写的是当前路径)。这里会有一个<code>bug</code>，就是当用户运行了<code>cd</code>之后，<code>./test</code>会失效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> *exepath = <span class="string">"./test"</span>;</div></pre></td></tr></table></figure>
<p>接下来操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">    sbcmd = (<span class="keyword">struct</span> subshellcmd*)cmd;</div><div class="line">    pipe(pipefd);</div><div class="line"></div><div class="line">    <span class="comment">// copy the cmd string.</span></div><div class="line">    <span class="keyword">for</span> (r = <span class="number">0</span>; sbcmd-&gt;cmdstr[r]; ++r) &#123;</div><div class="line">        shellcmd[<span class="number">0</span>][r] = sbcmd-&gt;cmdstr[r];</div><div class="line">    &#125;</div><div class="line">    shellcmd[<span class="number">0</span>][r] = <span class="number">0</span>;</div><div class="line">    <span class="comment">// free the memory.</span></div><div class="line">    <span class="built_in">free</span>(sbcmd-&gt;cmdstr);</div><div class="line">    <span class="built_in">free</span>(sbcmd);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fork1()) &#123;          <span class="comment">// parent process write string into pipe.</span></div><div class="line">        <span class="comment">// pipefd[1] is for output.</span></div><div class="line">        close(pipefd[<span class="number">0</span>]);   <span class="comment">// close input</span></div><div class="line">        <span class="comment">// ssize_t write(int fd, const void *buf, size_t count);</span></div><div class="line">        write(pipefd[<span class="number">1</span>], shellcmd[<span class="number">0</span>], <span class="built_in">strlen</span>(shellcmd[<span class="number">0</span>]));</div><div class="line">        close(pipefd[<span class="number">1</span>]);   <span class="comment">// close old output</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// chile start process&amp; read pipe.</span></div><div class="line">        close(pipefd[<span class="number">1</span>]);   <span class="comment">// close output</span></div><div class="line">        dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// copy input</span></div><div class="line">        close(pipefd[<span class="number">0</span>]);   <span class="comment">// close old input</span></div><div class="line">        <span class="comment">// begin to start the process with now exe file.</span></div><div class="line">        ecmd = (<span class="keyword">struct</span> execcmd*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> execcmd));</div><div class="line">        ecmd-&gt;type = <span class="string">' '</span>;</div><div class="line">        ecmd-&gt;argv[<span class="number">0</span>] = mkcopy(exepath, exepath + <span class="built_in">strlen</span>(exepath));</div><div class="line">        ecmd-&gt;argv[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">        runcmd((<span class="keyword">struct</span> cmd*)ecmd);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h3 id="gettoken"><a href="#gettoken" class="headerlink" title="gettoken"></a>gettoken</h3><p>在取词的时候，就需要把<code>(cmd | cmd &gt; /tmp/res | cmd)</code>这个括号里面的作为一个整体取出来。</p>
<ul>
<li>实际上这样做明显是有<code>bug</code>的。比如<code>#注释，双引号里面有()</code>，但是这些实现都以后再说。</li>
<li>整体取的时候，要注意把<code>)</code>也要取走。</li>
</ul>
<p><code>gettoken</code>函数里面添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">  ret = <span class="string">'('</span>;</div><div class="line">  <span class="keyword">while</span> (s &lt; es &amp;&amp; !(<span class="string">')'</span> == *s))</div><div class="line">    s++;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (*s != <span class="string">')'</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error symbols for subshell!\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  s++;</div><div class="line">  <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h3 id="parseexec-2"><a href="#parseexec-2" class="headerlink" title="parseexec"></a>parseexec</h3><p>解析命令的时候，由于<code>subshell</code>与<code>普通命令</code>，<code>重定向命令是属于同一个级别</code>，更简单一点可以把<code>subshell</code>整体看成一个普通命令，所以处理起来就简单了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(!peek(ps, es, <span class="string">"|;"</span>))&#123;</div><div class="line">  <span class="keyword">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class="number">0</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">switch</span> (tok) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">      cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class="line">      argc++;</div><div class="line">      <span class="keyword">if</span>(argc &gt;= MAXARGS) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"too many args\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">      &#125;</div><div class="line">      ret = parseredirs(ret, ps, es);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">      <span class="built_in">free</span>(ret);</div><div class="line">      ret = (<span class="keyword">struct</span> cmd *)scmd;</div><div class="line">      scmd-&gt;type = <span class="string">'('</span>;</div><div class="line">      scmd-&gt;cmdstr = mkcopy(q + <span class="number">1</span>, eq - <span class="number">1</span>);</div><div class="line">      ret = parseredirs(ret, ps, es);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="作业3-后台及wait"><a href="#作业3-后台及wait" class="headerlink" title="作业3: 后台及wait"></a>作业3: 后台及wait</h2><p>先说一个这个后台<code>Job</code>。也就是运行的时候，在整个命令后面加一个<code>&amp;</code>。可以让<code>命令到后台运行</code>：也就是不会一直占着<code>bash</code>。那<code>wait</code>呢？演示一个就搞懂。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">jiyou-qt@jiyou-qt:/tmp$ sleep 500 &amp;</div><div class="line">[1] 4017</div><div class="line">jiyou-qt@jiyou-qt:/tmp$ <span class="built_in">wait</span> 4017</div></pre></td></tr></table></figure>
<p>当运行<code>wait 4017</code>的时候，又会重新占用<code>bash</code>，也就是会一直等<code>bash运行结束</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">jiyou-qt@jiyou-qt:/tmp$ <span class="keyword">while</span> [[ 1 <span class="_">-eq</span> 1 ]]; <span class="keyword">do</span> <span class="built_in">echo</span> ok; sleep 3; <span class="keyword">done</span> &amp;</div><div class="line">[1] 4020</div><div class="line">jiyou-qt@jiyou-qt:/tmp$ ok</div><div class="line"></div><div class="line">jiyou-qt@jiyou-qt:/tmp$ ok</div><div class="line"></div><div class="line">jiyou-qt@jiyou-qt:/tmp$ <span class="built_in">wait</span> 4020ok</div><div class="line"></div><div class="line">ok</div></pre></td></tr></table></figure>
<p>需要注意的是：如果是<code>wait</code>的命令是有输出的，那么实际上是会一直打印输出的。</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>后台运行实际上是把整行命令放到后面执行。那么或许一种办法就是直接利用<code>自己写的shell</code>程序新起动一个进程<code>child</code>。而当前正在run的<code>bash</code>不去等这个<code>child</code>进程。继续后面的执行。</p>
<p>因此，命令的解析非常简单：</p>
<ul>
<li><code>parseline</code>先看一下末尾<code>&amp;</code>是否存在。如果有，那么进行一下切分。直接去掉<code>&amp;</code>得到命令字符串<code>cmd_str</code>。</li>
<li>生成一个新的<code>subshell</code>命令</li>
<li>执行的时候，<code>fork</code>一个新进程来执行<code>runcmd</code>。</li>
<li>不要去<code>wait</code>。</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>首先定义如下数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> bgcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// &amp;</span></div><div class="line">  <span class="keyword">struct</span> subshellcmd *scmd; <span class="comment">// subcommand which is subshell.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是说，后台执行的命令，实际内部只是一个<code>subshellcmd</code>。</p>
<h4 id="命令的执行-1"><a href="#命令的执行-1" class="headerlink" title="命令的执行"></a>命令的执行</h4><p>执行命令的时候，直接启动一个新的进程，利用这个新的进程<code>runcmd(parsecmd)</code>就可以了。父进程需要注意记录下这个进程的<code>pid</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">'&amp;'</span>:</div><div class="line">  backgroundcmd = (<span class="keyword">struct</span> bgcmd*)cmd;</div><div class="line">  child_pid = getpid();</div><div class="line">  <span class="keyword">if</span> ((child_pid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">strcpy</span>(shellcmd[<span class="number">0</span>], backgroundcmd-&gt;scmd-&gt;cmdstr);</div><div class="line">    <span class="built_in">free</span>(backgroundcmd-&gt;scmd-&gt;cmdstr);</div><div class="line">    <span class="built_in">free</span>(backgroundcmd-&gt;scmd);</div><div class="line">    runcmd(parsecmd(shellcmd[<span class="number">0</span>]));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (pid_list[i]) cnt_pid ++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (pid_list[i] == <span class="number">0</span>) &#123;</div><div class="line">        pid_list[i] = child_pid;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%d] %d\n"</span>, cnt_pid, child_pid);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<h4 id="命令的解析-1"><a href="#命令的解析-1" class="headerlink" title="命令的解析"></a>命令的解析</h4><p>命令的解析就比较简单了，就只需要解析当前这一行就<code>Over</code>。然后生成相应的<code>bgcmd</code>结构体。这里为了简懒，直接用的是静态变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseline</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">struct</span> bgcmd backcmd;</div><div class="line">  <span class="keyword">struct</span> subshellcmd *scmd;</div><div class="line">  <span class="keyword">char</span> *rf = es;</div><div class="line">  <span class="keyword">for</span> (rf = es; rf &gt;= *ps; --rf) &#123;</div><div class="line">    <span class="keyword">if</span> (*rf == <span class="string">'&amp;'</span>) &#123;</div><div class="line">      *rf = <span class="string">' '</span>;</div><div class="line">      <span class="comment">// gen subshellcmd;</span></div><div class="line">      scmd = (<span class="keyword">struct</span> subshellcmd*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subshellcmd));</div><div class="line">      scmd-&gt;type = <span class="string">'('</span>;</div><div class="line">      scmd-&gt;cmdstr = mkcopy(*ps, es);</div><div class="line">      *ps = rf;</div><div class="line">      <span class="comment">// gen bgcmd;</span></div><div class="line">      backcmd.type = <span class="string">'&amp;'</span>;</div><div class="line">      backcmd.scmd = scmd;</div><div class="line">      <span class="keyword">return</span> (<span class="keyword">struct</span> cmd*)&amp;backcmd;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  cmd = parselist(ps, es);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="wait的实现"><a href="#wait的实现" class="headerlink" title="wait的实现"></a>wait的实现</h4><p>实际上，到这里，实现<code>wait</code>就比较简单了，只需要调用<code>waitpid</code>函数即可。这里给出一个<code>waitpid</code>的用法示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span>  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">pid_t</span> child,child2;  </div><div class="line">    <span class="keyword">int</span> status;  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"This will demostrate how to get child status\n"</span>);  </div><div class="line">    <span class="keyword">if</span> ((child = fork()) == <span class="number">-1</span>) &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Fork Error ：%s\n"</span>, strerror(errno));  </div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;  </div><div class="line">        child2 = fork();  </div><div class="line">        <span class="keyword">if</span>(child2 == <span class="number">0</span>)  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"I am the child2:%ld\n"</span>,getpid());  </div><div class="line">        <span class="keyword">int</span> i;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"I am the child：%ld\n"</span>, getpid());  </div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) <span class="built_in">sin</span>(i);  </div><div class="line">        i = <span class="number">5</span>;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"I exit with %d\n"</span>, i);  </div><div class="line">        <span class="built_in">exit</span>(i);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">while</span> (((child = waitpid(getpid(),&amp;status,<span class="number">0</span>)) == <span class="number">-1</span>)&amp;(errno == EINTR));  </div><div class="line">    <span class="keyword">if</span> (child == <span class="number">-1</span>)  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Wait Error：%s\n"</span>, strerror(errno));  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!status)  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Child %ld terminated normally return status is zero\n"</span>,  </div><div class="line">            child);  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFEXITED(status))  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Child %ld terminated normally return status is %d\n"</span>,  </div><div class="line">            child, WEXITSTATUS(status));  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status));  </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Child %ld terminated due to signal %d znot caught\n"</span>,  </div><div class="line">            child, WTERMSIG(status));  </div><div class="line">    getchar();  </div><div class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，在启动的<code>后台进程</code>的时候，注意整个流程的处理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">main  &lt;-- sleep <span class="number">60</span> &amp;</div><div class="line">  |</div><div class="line">  |</div><div class="line">  rucmd() --&gt;child_pid = fork()</div><div class="line">  |                         |</div><div class="line">  |                         |<span class="number">_</span> runcmd(parsecmd(<span class="string">"sleep 60"</span>));</div><div class="line">  |insert(child_pid)</div><div class="line">  |</div><div class="line">  wait command ?</div><div class="line">          |<span class="number">___</span>yes</div><div class="line">               |<span class="number">__</span> find(child_pid)--waitpid(child_pid)</div></pre></td></tr></table></figure>
<h4 id="main函数的处理"><a href="#main函数的处理" class="headerlink" title="main函数的处理"></a>main函数的处理</h4><p>当执行<code>main</code>函数的时候，需要注意：启动的进程直接在当前这个bash下面。如果还是采用原来的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</div><div class="line">	runcmd(parsecmd(buf));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式，会在里面再次启动一个进程。形成的结构就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">main &lt;-sleep <span class="number">60</span> &amp;</div><div class="line">  |</div><div class="line">  |</div><div class="line">  |<span class="number">___</span>subproc1</div><div class="line">         |</div><div class="line">         |<span class="number">_</span> subproc2 -- runcmd(parsecmd(sleep <span class="number">60</span>));</div></pre></td></tr></table></figure>
<p>所以应该采用如下结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'&amp;'</span>) &#123;</div><div class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Background cmd found!\n"</span>);</div><div class="line">  runcmd(parsecmd(buf));</div><div class="line">  <span class="keyword">continue</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">   runcmd(parsecmd(buf));</div></pre></td></tr></table></figure>
<p>也就是说，如果发现是后台进程，那么直接执行<code>runcmd()</code>而不是在新的进程中<code>runcmd</code>。</p>
<h4 id="wait的处理"><a href="#wait的处理" class="headerlink" title="wait的处理"></a>wait的处理</h4><p>首先在<code>main</code>函数里面检查，看一下是不是<code>wait</code>命令。如果有，那么开始执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">"wait"</span>) == buf) &#123;</div><div class="line">  wpid = atoi(buf + <span class="number">4</span>);</div><div class="line">  wait_process(wpid);</div><div class="line">  <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等待进程的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_process</span><span class="params">(<span class="keyword">int</span> wpid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pid = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> has_find = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> child = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"pid_list[%d] = %d\n"</span>, i, pid_list[i]);</div><div class="line">      <span class="keyword">if</span> (pid_list[i] == wpid) &#123;</div><div class="line">          has_find = <span class="number">1</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == has_find) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can not find wait pid = %d\n"</span>, wpid);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((child = waitpid(wpid, &amp;status, <span class="number">0</span>)) == <span class="number">-1</span>)&amp;(errno == EINTR));</div><div class="line">    <span class="keyword">if</span> (child == <span class="number">-1</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Wait Error：%s\n"</span>, strerror(errno));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!status)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated normally return status is zero\n"</span>, child);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFEXITED(status))</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated normally return status is %d\n"</span>,</div><div class="line">            child, WEXITSTATUS(status));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status));</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated due to signal %d znot caught\n"</span>,</div><div class="line">            child, WTERMSIG(status));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h1><p>这份代码实际上只是实现了<code>bash</code>的基本功能。也学习了面向进程编程的处理技巧。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// Simplifed xv6 shell.</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS 10</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> child_pid = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *pid_list = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">char</span> *exepath = <span class="string">"./test"</span>;</div><div class="line"><span class="comment">// All commands have at least a type. Have looked at the type, the code</span></div><div class="line"><span class="comment">// typically casts the *cmd to some specific cmd type.</span></div><div class="line"><span class="keyword">struct</span> cmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">//  ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> execcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;              <span class="comment">// ' '</span></div><div class="line">  <span class="keyword">char</span> *argv[MAXARGS];   <span class="comment">// arguments to the command to be exec-ed</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> redircmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// &lt; or &gt;</span></div><div class="line">  <span class="keyword">struct</span> cmd *cmd;   <span class="comment">// the command to be run (e.g., an execcmd)</span></div><div class="line">  <span class="keyword">char</span> *file;        <span class="comment">// the input/output file</span></div><div class="line">  <span class="keyword">int</span> mode;          <span class="comment">// the mode to open the file with</span></div><div class="line">  <span class="keyword">int</span> fd;            <span class="comment">// the file descriptor number to use for the file</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> subshellcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// ( or )</span></div><div class="line">  <span class="keyword">char</span> *cmdstr;      <span class="comment">// commands will be executed in subshell.</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> bgcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// &amp;</span></div><div class="line">  <span class="keyword">struct</span> subshellcmd *scmd; <span class="comment">// subcommand which is subshell.</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> pipecmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// |</span></div><div class="line">  <span class="keyword">struct</span> cmd *left;  <span class="comment">// left side of pipe</span></div><div class="line">  <span class="keyword">struct</span> cmd *right; <span class="comment">// right side of pipe</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> listcmd &#123;</div><div class="line">  <span class="keyword">int</span> type;          <span class="comment">// ;</span></div><div class="line">  <span class="keyword">struct</span> cmd *cmd;   <span class="comment">// the command to be run. (e.g., an pipecmd)</span></div><div class="line">  <span class="keyword">struct</span> cmd *next;  <span class="comment">// next command position.</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork1</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// Fork but exits on failure.</span></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parsecmd</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span></span></div><div class="line">*<span class="title">mkcopy</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *es)</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_process</span><span class="params">(<span class="keyword">int</span> wpid)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> pid = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> has_find = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> child = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">      <span class="keyword">if</span> (pid_list[i] == wpid) &#123;</div><div class="line">          has_find = <span class="number">1</span>;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == has_find) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can not find wait pid = %d\n"</span>, wpid);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (((child = waitpid(wpid, &amp;status, <span class="number">0</span>)) == <span class="number">-1</span>)&amp;(errno == EINTR));</div><div class="line">    <span class="keyword">if</span> (child == <span class="number">-1</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Wait Error：%s\n"</span>, strerror(errno));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!status)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated normally return status is zero\n"</span>, child);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFEXITED(status))</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated normally return status is %d\n"</span>,</div><div class="line">            child, WEXITSTATUS(status));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status));</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Child %ld terminated due to signal %d znot caught\n"</span>,</div><div class="line">            child, WTERMSIG(status));</div><div class="line">&#125;</div><div class="line"><span class="comment">// Execute cmd.  Never returns.</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> p[<span class="number">2</span>], r, j;</div><div class="line">    <span class="keyword">struct</span> execcmd *ecmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> pipecmd *pcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> redircmd *rcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> subshellcmd *sbcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> bgcmd *backgroundcmd = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> cmd *head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *tail = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *leftcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *rightcmd = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> cmd *subcmd = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> shellcmd[MAXARGS][<span class="number">100</span>];</div><div class="line">    <span class="keyword">char</span> *ppcmd[MAXARGS];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> waitv;</div><div class="line">    <span class="keyword">int</span> execvp_ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> wait_pid = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cnt_pid = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(cmd == <span class="number">0</span>)</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(cmd-&gt;type) &#123;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line">        ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</div><div class="line"></div><div class="line">        <span class="comment">// if no comand need to run.</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == ecmd-&gt;argv[<span class="number">0</span>]) &#123;</div><div class="line">          <span class="built_in">free</span>(ecmd);</div><div class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// clean the memory.</span></div><div class="line">        <span class="built_in">memset</span>(shellcmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(shellcmd));</div><div class="line"></div><div class="line">        <span class="comment">// copy comamnd and freeup memory.</span></div><div class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; MAXARGS; ++r) &#123;</div><div class="line">          <span class="keyword">if</span> (ecmd-&gt;argv[r]) &#123;</div><div class="line">            <span class="comment">// copy the command.</span></div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; ecmd-&gt;argv[r][j]; j++) &#123;</div><div class="line">              shellcmd[r][j] = ecmd-&gt;argv[r][j];</div><div class="line">            &#125;</div><div class="line">            shellcmd[r][j] = <span class="number">0</span>;</div><div class="line">            ppcmd[r] = shellcmd[r];</div><div class="line">            <span class="built_in">free</span>(ecmd-&gt;argv[r]);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(ecmd);</div><div class="line">        ppcmd[r] = <span class="number">0</span>;</div><div class="line"></div><div class="line">        execvp_ret = execvp(ppcmd[<span class="number">0</span>], ppcmd);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"cmd = %s retv = %d\n"</span>, ppcmd[<span class="number">0</span>], execvp_ret);</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exec not implemented\n"</span>);</div><div class="line">        <span class="built_in">exit</span> (<span class="number">1</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">        rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</div><div class="line">        close(rcmd-&gt;fd);</div><div class="line">        open(rcmd-&gt;file, rcmd-&gt;mode, S_IRWXU);</div><div class="line">        subcmd = rcmd-&gt;cmd;</div><div class="line"></div><div class="line">        <span class="built_in">free</span>(rcmd-&gt;file);</div><div class="line">        <span class="built_in">free</span>(rcmd);</div><div class="line">        runcmd(subcmd);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">        pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</div><div class="line">        pipe(pipefd);</div><div class="line"></div><div class="line">        <span class="comment">// record the subcmd.</span></div><div class="line">        <span class="comment">// free now cmd.</span></div><div class="line">        leftcmd = pcmd-&gt;left;</div><div class="line">        rightcmd = pcmd-&gt;right;</div><div class="line">        <span class="built_in">free</span>(pcmd);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;     <span class="comment">// child process run leftcmd.</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close input</span></div><div class="line">            dup2(pipefd[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">// copy output</span></div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close old output</span></div><div class="line">            runcmd(leftcmd);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// parent process run rightcmd.</span></div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close output</span></div><div class="line">            dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// copy input</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close old input</span></div><div class="line">            runcmd(rightcmd);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">        head = cmd;</div><div class="line">        <span class="keyword">while</span> (head) &#123;</div><div class="line">            <span class="keyword">if</span> (fork1() == <span class="number">0</span>) &#123;</div><div class="line">              runcmd(((<span class="keyword">struct</span> listcmd*)head)-&gt;cmd);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              wait(&amp;waitv);</div><div class="line">              temp = head;</div><div class="line">              head = ((<span class="keyword">struct</span> listcmd*)head)-&gt;next;</div><div class="line"></div><div class="line">              <span class="comment">// free memory.</span></div><div class="line">              <span class="built_in">free</span>(temp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">        sbcmd = (<span class="keyword">struct</span> subshellcmd*)cmd;</div><div class="line">        pipe(pipefd);</div><div class="line"></div><div class="line">        <span class="comment">// copy the cmd string.</span></div><div class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; sbcmd-&gt;cmdstr[r]; ++r) &#123;</div><div class="line">            shellcmd[<span class="number">0</span>][r] = sbcmd-&gt;cmdstr[r];</div><div class="line">        &#125;</div><div class="line">        shellcmd[<span class="number">0</span>][r] = <span class="number">0</span>;</div><div class="line">        <span class="comment">// free the memory.</span></div><div class="line">        <span class="built_in">free</span>(sbcmd-&gt;cmdstr);</div><div class="line">        <span class="built_in">free</span>(sbcmd);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fork1()) &#123;          <span class="comment">// parent process write string into pipe.</span></div><div class="line">            <span class="comment">// pipefd[1] is for output.</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close input</span></div><div class="line">            <span class="comment">// ssize_t write(int fd, const void *buf, size_t count);</span></div><div class="line">            write(pipefd[<span class="number">1</span>], shellcmd[<span class="number">0</span>], <span class="built_in">strlen</span>(shellcmd[<span class="number">0</span>]));</div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close old output</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// chile start process&amp; read pipe.</span></div><div class="line">            close(pipefd[<span class="number">1</span>]);   <span class="comment">// close output</span></div><div class="line">            dup2(pipefd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">// copy input</span></div><div class="line">            close(pipefd[<span class="number">0</span>]);   <span class="comment">// close old input</span></div><div class="line">            <span class="comment">// begin to start the process with now exe file.</span></div><div class="line">            ecmd = (<span class="keyword">struct</span> execcmd*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> execcmd));</div><div class="line">            ecmd-&gt;type = <span class="string">' '</span>;</div><div class="line">            ecmd-&gt;argv[<span class="number">0</span>] = mkcopy(exepath, exepath + <span class="built_in">strlen</span>(exepath));</div><div class="line">            ecmd-&gt;argv[<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">            runcmd((<span class="keyword">struct</span> cmd*)ecmd);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> <span class="string">'&amp;'</span>:</div><div class="line">        backgroundcmd = (<span class="keyword">struct</span> bgcmd*)cmd;</div><div class="line">        child_pid = getpid();</div><div class="line">        <span class="keyword">if</span> ((child_pid = fork()) == <span class="number">0</span>) &#123;</div><div class="line">          <span class="built_in">strcpy</span>(shellcmd[<span class="number">0</span>], backgroundcmd-&gt;scmd-&gt;cmdstr);</div><div class="line">          <span class="built_in">free</span>(backgroundcmd-&gt;scmd-&gt;cmdstr);</div><div class="line">          <span class="built_in">free</span>(backgroundcmd-&gt;scmd);</div><div class="line">          runcmd(parsecmd(shellcmd[<span class="number">0</span>]));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (pid_list[i]) cnt_pid ++;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS * MAXARGS; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (pid_list[i] == <span class="number">0</span>) &#123;</div><div class="line">              pid_list[i] = child_pid;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"[%d] %d\n"</span>, cnt_pid, child_pid);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">getcmd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> nbuf)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (isatty(fileno(<span class="built_in">stdin</span>)))</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"6.828$ "</span>);</div><div class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</div><div class="line">  fgets(buf, nbuf, <span class="built_in">stdin</span>);</div><div class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) <span class="comment">// EOF</span></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这个函数的作用就是清除头尾两端的空白符。</span></div><div class="line"><span class="comment">// 原地处理字符串。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">(<span class="keyword">char</span> *buf)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> newiter = <span class="number">0</span>, previous_ok = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// &lt;&lt;找到开头的非空白符</span></div><div class="line">  <span class="keyword">while</span> (buf[begin]) &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">isspace</span>(buf[begin])) <span class="keyword">break</span>;</div><div class="line">    begin++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 从开头的非空白符处开始复制。</span></div><div class="line">  <span class="comment">// 这里需要通过previous_ok查看前面一个字符是否是非空白符（1)</span></div><div class="line">  <span class="comment">// 那么有两种情况是需要复制字符的。</span></div><div class="line">  <span class="comment">// a. 非空白符</span></div><div class="line">  <span class="comment">// b. 当前要复制的是空白符，并且前面一个是非空白符。</span></div><div class="line">  newiter = begin;</div><div class="line">  <span class="keyword">while</span> (buf[begin]) &#123;</div><div class="line">    <span class="keyword">if</span> (previous_ok || !<span class="built_in">isspace</span>(buf[begin])) &#123;</div><div class="line">      buf[newiter] = buf[begin];</div><div class="line">      newiter++;</div><div class="line">    &#125;</div><div class="line">    previous_ok = !<span class="built_in">isspace</span>(buf[begin]);</div><div class="line">    begin++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  buf[newiter] = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 从末尾向前找，把所有的空白符设置为0。</span></div><div class="line">  <span class="comment">// 也就是为了清除尾部的空白符。</span></div><div class="line">  end = newiter - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">isspace</span>(buf[end])) &#123;</div><div class="line">    buf[end] = <span class="number">0</span>;</div><div class="line">    --end;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100</span>];</div><div class="line">  <span class="keyword">int</span> fd, r, i, wpid;</div><div class="line">  <span class="keyword">struct</span> cmd *scmd = <span class="number">0</span>;</div><div class="line"></div><div class="line">  pid_list = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAXARGS * MAXARGS);</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXARGS; ++i)</div><div class="line">    pid_list[i] = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Read and run input commands.</span></div><div class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</div><div class="line">    trim(buf);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(buf, <span class="string">"exit"</span>) || <span class="number">0</span> == <span class="built_in">strcmp</span>(buf, <span class="string">"quit"</span>)) &#123;</div><div class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">"wait"</span>) == buf) &#123;</div><div class="line">      wpid = atoi(buf + <span class="number">4</span>);</div><div class="line">      wait_process(wpid);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">'c'</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">'d'</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">' '</span>)&#123;</div><div class="line">      <span class="comment">// Clumsy but will have to do for now.</span></div><div class="line">      <span class="comment">// Chdir has no effect on the parent if run in the child.</span></div><div class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// chop \n</span></div><div class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"cannot cd %s\n"</span>, buf+<span class="number">3</span>);</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'&amp;'</span>) &#123;</div><div class="line">      runcmd(parsecmd(buf));</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</div><div class="line">      runcmd(parsecmd(buf));</div><div class="line"></div><div class="line">    wait(&amp;r);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">free</span>(pid_list);</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">fork1</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> pid;</div><div class="line"></div><div class="line">  pid = fork();</div><div class="line">  <span class="keyword">if</span>(pid == <span class="number">-1</span>)</div><div class="line">    perror(<span class="string">"fork"</span>);</div><div class="line">  <span class="keyword">return</span> pid;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">execcmd</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> execcmd *cmd;</div><div class="line"></div><div class="line">  cmd = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cmd));</div><div class="line">  <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*cmd));</div><div class="line">  cmd-&gt;type = <span class="string">' '</span>;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> cmd*)cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">redircmd</span><span class="params">(<span class="keyword">struct</span> cmd *subcmd, <span class="keyword">char</span> *file, <span class="keyword">int</span> type)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> redircmd *cmd;</div><div class="line"></div><div class="line">  cmd = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cmd));</div><div class="line">  <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*cmd));</div><div class="line">  cmd-&gt;type = type;</div><div class="line">  cmd-&gt;cmd = subcmd;</div><div class="line">  cmd-&gt;file = file;</div><div class="line">  cmd-&gt;mode = (type == <span class="string">'&lt;'</span>) ?  O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC;</div><div class="line">  cmd-&gt;fd = (type == <span class="string">'&lt;'</span>) ? <span class="number">0</span> : <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> cmd*)cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">pipecmd</span><span class="params">(<span class="keyword">struct</span> cmd *left, <span class="keyword">struct</span> cmd *right)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> pipecmd *cmd;</div><div class="line"></div><div class="line">  cmd = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cmd));</div><div class="line">  <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="keyword">sizeof</span>(*cmd));</div><div class="line">  cmd-&gt;type = <span class="string">'|'</span>;</div><div class="line">  cmd-&gt;left = left;</div><div class="line">  cmd-&gt;right = right;</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> cmd*)cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Parsing</span></div><div class="line"></div><div class="line"><span class="keyword">char</span> whitespace[] = <span class="string">" \t\r\n\v"</span>;</div><div class="line"><span class="keyword">char</span> symbols[] = <span class="string">"&lt;|&gt;"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">gettoken</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es, <span class="keyword">char</span> **q, <span class="keyword">char</span> **eq)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  s = *ps;</div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  <span class="keyword">if</span>(q)</div><div class="line">    *q = s;</div><div class="line">  ret = *s;</div><div class="line">  <span class="keyword">switch</span>(*s)&#123;</div><div class="line">  <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</div><div class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">';'</span>:</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">    ret = <span class="string">'('</span>;</div><div class="line">    <span class="keyword">while</span> (s &lt; es &amp;&amp; !(<span class="string">')'</span> == *s))</div><div class="line">      s++;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*s != <span class="string">')'</span>) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error symbols for subshell!\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  <span class="keyword">default</span>:</div><div class="line">    ret = <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">while</span>(s &lt; es &amp;&amp; !<span class="built_in">strchr</span>(whitespace, *s) &amp;&amp; !<span class="built_in">strchr</span>(symbols, *s))</div><div class="line">      s++;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(eq)</div><div class="line">    *eq = s;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  *ps = s;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">peek</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es, <span class="keyword">char</span> *toks)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line"></div><div class="line">  s = *ps;</div><div class="line">  <span class="keyword">while</span>(s &lt; es &amp;&amp; <span class="built_in">strchr</span>(whitespace, *s))</div><div class="line">    s++;</div><div class="line">  *ps = s;</div><div class="line">  <span class="keyword">return</span> *s &amp;&amp; <span class="built_in">strchr</span>(toks, *s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parseline</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parselist</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">struct</span> cmd *<span class="title">parseexec</span><span class="params">(<span class="keyword">char</span>**, <span class="keyword">char</span>*)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// make a copy of the characters in the input buffer, starting from s through es.</span></div><div class="line"><span class="comment">// null-terminate the copy to make it a string.</span></div><div class="line"><span class="function"><span class="keyword">char</span></span></div><div class="line">*<span class="title">mkcopy</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> n = es - s;</div><div class="line">  <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(n+<span class="number">1</span>);</div><div class="line">  assert(c);</div><div class="line">  <span class="built_in">strncpy</span>(c, s, n);</div><div class="line">  c[n] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsecmd</span><span class="params">(<span class="keyword">char</span> *s)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *es;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  es = s + <span class="built_in">strlen</span>(s);</div><div class="line">  cmd = parseline(&amp;s, es);</div><div class="line">  peek(&amp;s, es, <span class="string">""</span>);</div><div class="line">  <span class="keyword">if</span>(s != es)&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"leftovers: %s\n"</span>, s);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseline</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">struct</span> bgcmd backcmd;</div><div class="line">  <span class="keyword">struct</span> subshellcmd *scmd;</div><div class="line">  <span class="keyword">char</span> *rf = es;</div><div class="line">  <span class="keyword">for</span> (rf = es; rf &gt;= *ps; --rf) &#123;</div><div class="line">    <span class="keyword">if</span> (*rf == <span class="string">'&amp;'</span>) &#123;</div><div class="line">      *rf = <span class="string">' '</span>;</div><div class="line">      <span class="comment">// gen subshellcmd;</span></div><div class="line">      scmd = (<span class="keyword">struct</span> subshellcmd*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subshellcmd));</div><div class="line">      scmd-&gt;type = <span class="string">'('</span>;</div><div class="line">      scmd-&gt;cmdstr = mkcopy(*ps, es);</div><div class="line">      *ps = rf;</div><div class="line">      <span class="comment">// gen bgcmd;</span></div><div class="line">      backcmd.type = <span class="string">'&amp;'</span>;</div><div class="line">      backcmd.scmd = scmd;</div><div class="line">      <span class="keyword">return</span> (<span class="keyword">struct</span> cmd*)&amp;backcmd;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  cmd = parselist(ps, es);</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parselist</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> cmd *cmd = <span class="number">0</span>, *ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *head = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *tail = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> listcmd *temp = <span class="number">0</span>;</div><div class="line"></div><div class="line">    cmd = parsepipe(ps, es);</div><div class="line"></div><div class="line">    head = (<span class="keyword">struct</span> listcmd*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> listcmd));</div><div class="line">    head-&gt;type = <span class="string">';'</span>;</div><div class="line">    head-&gt;next = <span class="number">0</span>;</div><div class="line">    head-&gt;cmd = cmd;</div><div class="line">    tail = head;</div><div class="line"></div><div class="line">    ret = (<span class="keyword">struct</span> cmd*)head;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(peek(ps, es, <span class="string">";"</span>)) &#123;</div><div class="line">        gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        temp = (<span class="keyword">struct</span> listcmd*)parselist(ps, es);</div><div class="line">        tail-&gt;next = (<span class="keyword">struct</span> cmd*)temp;</div><div class="line">        tail = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parsepipe</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> cmd *cmd;</div><div class="line"></div><div class="line">  cmd = parseexec(ps, es);</div><div class="line">  <span class="keyword">if</span>(peek(ps, es, <span class="string">"|"</span>))&#123;</div><div class="line">    gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseredirs</span><span class="params">(<span class="keyword">struct</span> cmd *cmd, <span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> tok;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(peek(ps, es, <span class="string">"&lt;&gt;"</span>))&#123;</div><div class="line">    tok = gettoken(ps, es, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class="string">'a'</span>) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"missing file for redirection\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span>(tok)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&lt;'</span>:</div><div class="line">      cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&lt;'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'&gt;'</span>:</div><div class="line">      cmd = redircmd(cmd, mkcopy(q, eq), <span class="string">'&gt;'</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cmd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">struct</span> cmd*</span></div><div class="line"><span class="title">parseexec</span><span class="params">(<span class="keyword">char</span> **ps, <span class="keyword">char</span> *es)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *q, *eq;</div><div class="line">  <span class="keyword">int</span> tok, argc;</div><div class="line">  <span class="keyword">struct</span> execcmd *cmd;</div><div class="line">  <span class="keyword">struct</span> cmd *ret;</div><div class="line">  <span class="keyword">struct</span> subshellcmd *scmd;</div><div class="line"></div><div class="line">  ret = (<span class="keyword">struct</span> cmd *)execcmd();</div><div class="line">  cmd = (<span class="keyword">struct</span> execcmd*)ret;</div><div class="line">  scmd = (<span class="keyword">struct</span> subshellcmd*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> subshellcmd));</div><div class="line"></div><div class="line">  argc = <span class="number">0</span>;</div><div class="line">  ret = parseredirs(ret, ps, es);</div><div class="line">  <span class="keyword">while</span>(!peek(ps, es, <span class="string">"|;"</span>))&#123;</div><div class="line">    <span class="keyword">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class="number">0</span>)</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (tok) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">        cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class="line">        argc++;</div><div class="line">        <span class="keyword">if</span>(argc &gt;= MAXARGS) &#123;</div><div class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"too many args\n"</span>);</div><div class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        ret = parseredirs(ret, ps, es);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'('</span>:</div><div class="line">        <span class="built_in">free</span>(ret);</div><div class="line">        ret = (<span class="keyword">struct</span> cmd *)scmd;</div><div class="line">        scmd-&gt;type = <span class="string">'('</span>;</div><div class="line">        scmd-&gt;cmdstr = mkcopy(q + <span class="number">1</span>, eq - <span class="number">1</span>);</div><div class="line">        ret = parseredirs(ret, ps, es);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"syntax error\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  cmd-&gt;argv[argc] = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JOS/">JOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/MIT-6-828/">MIT 6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/xv6/">xv6</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/MIT-6-828-JOS课程1：HW-Shell" data-title="MIT 6.828 JOS课程1：HW Shell" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/blog/page/2/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>