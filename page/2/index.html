<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>缘生故如幻</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录一些有意思的事。">
<meta property="og:type" content="website">
<meta property="og:title" content="缘生故如幻">
<meta property="og:url" content="https://jiyou.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="缘生故如幻">
<meta property="og:description" content="记录一些有意思的事。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="缘生故如幻">
<meta name="twitter:description" content="记录一些有意思的事。">
  
    <link rel="alternative" href="/atom.xml" title="缘生故如幻" type="application/atom+xml">
  
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog//img/head.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">You Ji</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
				        
							<li><a href="/blog/tags/leetcode">leetcode</a></li>
				        
							<li><a href="/blog/tags/blog">blog</a></li>
				        
							<li><a href="/blog/tags/ceph">ceph</a></li>
				        
							<li><a href="/blog/tags/stl">stl</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/ceph/" style="font-size: 10px;">ceph</a> <a href="/blog/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/blog/tags/mit-6-828/" style="font-size: 10px;">mit.6.828</a> <a href="/blog/tags/stl/" style="font-size: 20px;">stl</a> <a href="/blog/tags/算法/" style="font-size: 15px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/JiYou">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">code</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">You Ji</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/blog//img/head.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">You Ji</h1>
			</hgroup>
			
			<p class="header-subtitle">心言直故，如是乃至始终地位，中间永无诸委曲相。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="/blog/tags/MIT-6-828">mit.6.828</a></li>
		        
					<li><a href="/blog/tags/leetcode">leetcode</a></li>
		        
					<li><a href="/blog/tags/blog">blog</a></li>
		        
					<li><a href="/blog/tags/ceph">ceph</a></li>
		        
					<li><a href="/blog/tags/stl">stl</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/JiYou" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/codeit" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-stl/3.模板模板参数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/07/18/stl/3.模板模板参数/" class="article-date">
  	<time datetime="2018-07-17T21:28:32.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/18/stl/3.模板模板参数/">1.3 模板模板参数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="模板的模板参数"><a href="#模板的模板参数" class="headerlink" title="模板的模板参数"></a>模板的模板参数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">int</span> i&gt; <span class="keyword">class</span> A &#123;</div><div class="line">   <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> A&lt;T, <span class="number">5</span>&gt; &#123;</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> U&gt; <span class="keyword">class</span> B1 &#123; &#125;;</div><div class="line"></div><div class="line">B1&lt;A&gt; c;</div></pre></td></tr></table></figure>
<p>注意，这个代码是无法通过编译的。因为编译器在匹配模板参数的时候，是看全部参数的，不会去考虑<code>A</code>的偏特化版本。</p>
<p>The compiler considers the partial specializations based on a template template argument once you have instantiated a specialization based on the corresponding template template parameter. The following example demonstrates this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 声明一个A的Base模板</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">int</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 声明A的偏特化版本</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="keyword">class</span> A&lt;<span class="keyword">int</span>, U&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   V&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; i;</div><div class="line">   V&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 那么，在生成代码的时候，实际上生成的是</span></div><div class="line"><span class="comment">// class B &#123; A&lt;int, char&gt; i; A &lt;char,char&gt; j; &#125;</span></div><div class="line">B&lt;A&gt; c;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c.i.x).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(c.j.x).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果仔细地看一下<code>B</code>这个类，就会发现，<code>T/U</code>好像没有什么用。因为在<code>B</code>的内部声明的里面从来没有用到这两个类型，如果要用这两个类型应该怎么办？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A&lt;T,U&gt; a_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样是会报错的，因为<code>template&lt;class T, class U&gt; class V</code>只会用来修饰类<code>V</code>而不会用来修饰<code>B</code>。所以在编译的时候，会在<code>B</code>里面说，<code>T/U</code>没有定义。</p>
<p>那么，如果想让<code>B</code>类里面有如下声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T t_;</div><div class="line">    U u_;</div><div class="line">    A&lt;T,U&gt; a_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>应该怎么办？</p>
<p>应该把<code>B</code>类的声明改成如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U&gt; <span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    T t_;</div><div class="line">    U u_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="keyword">class</span> A&lt;<span class="keyword">int</span>, U&gt; &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   <span class="keyword">short</span> x;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> X, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> V&gt; <span class="keyword">class</span> B &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    V&lt;T, U&gt; v_;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">B&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">float</span>, A&gt; c;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    c.print();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要特别注意看声明。在声明<code>V</code>的时候，所有的这个<code>V</code>会引用到的变量都是在<code>template&lt;typename T, typename U, typename X, ..&gt; B</code>也就是<code>T, U, X</code>这三个里面取。至于具体取哪个，并不能从<code>template</code>的声明里面看出来。</p>
<p>真正要实例化<code>V</code>类的时候，也就是<code>B</code>的内部声明的时候，才会知道<code>V</code>到底是怎么实例化的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">V&lt;T, U&gt; v_;</div><div class="line">V&lt;U, X&gt; ux_;</div></pre></td></tr></table></figure>
<p>所以可以总结一下，关于模析模板参数。</p>
<ul>
<li>如果模板模板参数想起作用，那么只能在<code>&lt;typename X, typename Y, typename Z, template&lt;class, class&gt; class V&gt;</code>里面取，并且声明模板板参数的时候，不能写明<code>template&lt;class T, class U&gt; class V</code>，而是需要写成<code>template&lt;class, class&gt; class V</code>这种形式，表示参数都从前面的列表里面选择。</li>
<li>如果是写成<code>template&lt;class T, class U&gt; class V</code>这种格式，并且<code>T/U</code>不在外部列表里面。比如<code>template&lt;typename T, typename U, typename X, template&lt;typename T, typename U&gt; class V&gt;</code>这里会因为<code>T/U</code>重复声明，导到编译不过。那么需要改写成<code>template&lt;typename T, typename U, typename X, template&lt;typename A, typename B&gt; class V&gt; class B {};</code>。但是按照这种写法，模板参数<code>A/B</code>就只能在<code>B</code>类定义的时候内部各种实例化，而不能在外部指定。</li>
</ul>
<p>所以，也可以总结成。</p>
<ul>
<li>如果想定义<code>B</code>类的时候，直接也把内部类<code>A</code>的定义决定了。那么，声明的时候，必须采用1.</li>
<li>如果想<code>B</code>类内部自由定义<code>A</code>类的实例化，那么必须采用格式2.</li>
</ul>
<h2 id="模板模板参数的取值范围"><a href="#模板模板参数的取值范围" class="headerlink" title="模板模板参数的取值范围"></a>模板模板参数的取值范围</h2><p>模板模板参数的取值范围可以是：</p>
<ul>
<li>类型声明在前面，比如<code>&lt;typename X, typename Y, typename Z, template&lt;class, class&gt; class V&gt;</code>。这个时候，类<code>V</code>的模板参数可取范围是<code>X, Y, Z</code>。</li>
<li>类型声明在后面，比如<code>&lt;template&lt;class, class&gt; class V, typename X, typename Y, typename Z&gt;</code>也是同样可以取到<code>X/Y/Z</code>的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> H, <span class="keyword">class</span> S&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> H&lt;S&gt; &amp;value)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>, <span class="keyword">class</span>&gt; <span class="keyword">class</span> V, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(V&lt;T, A&gt; &amp;v)</span> </span>&#123;</div><div class="line">    <span class="comment">// This can be "typename V&lt;T, A&gt;::value_type",</span></div><div class="line">    <span class="comment">// but we are pretending we don't have it</span></div><div class="line"></div><div class="line">    T temp = v.back();</div><div class="line">    v.pop_back();</div><div class="line">    <span class="comment">// Do some work on temp</span></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="缺省值"><a href="#缺省值" class="headerlink" title="缺省值"></a>缺省值</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont = Deque&gt;</div><div class="line"><span class="keyword">class</span> Stack &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//...</span></div><div class="line">Stack&lt;<span class="keyword">int</span>&gt; aStack1; <span class="comment">// use default: Cont is Deque</span></div><div class="line">Stack&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,List&gt; aStack2; <span class="comment">// Cont is List</span></div></pre></td></tr></table></figure>
<p>只是需要注意的是，这里的<code>Deque</code>的声明也需要是<code>template &lt;typename&gt; class Deque { };</code>这样。也就是只有一个模板参数。</p>
<p><strong>注意</strong>这里的<code>Deque</code>不是<code>STL</code>里面<code>Deque</code>。</p>
<h1 id="无用的模板参数"><a href="#无用的模板参数" class="headerlink" title="无用的模板参数"></a>无用的模板参数</h1><p>有时候，如果采用如下声明，会导致相同的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Vec &#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> V&gt;</div><div class="line"><span class="keyword">class</span> Wrap &#123; &#125; ;</div></pre></td></tr></table></figure>
<p>在这里，<code>Wrap</code>的声明得到的效果就与</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> V&gt;</div><div class="line"><span class="keyword">class</span> Wrap &#123; &#125;;</div></pre></td></tr></table></figure>
<p>得到同样的效果。因为<code>template&lt;template&lt;typename T&gt; typename V&gt;</code>会导致<code>V</code>没有参数范围可以选择。只能在内部指定类型。</p>
<p>同理，可以扩展到多个参数的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element,</div><div class="line">    <span class="keyword">class</span> Allocator&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3;</div></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3;</div></pre></td></tr></table></figure>
<p>这两个也应该是等价的。在使用的时候，都需要在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>,<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Cont&gt;</div><div class="line"><span class="keyword">class</span> Wrapper3 &#123;</div><div class="line">    Cont&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt; cont_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样的声明方式。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/stl/">stl</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/stl/">stl</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-stl/3.模板模板参数" data-title="1.3 模板模板参数" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/22" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/22/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/22/">LeetCode.22 合法括号对的总排列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定括号的对数。要求写出程序。把所有可能的，符合运算括号排列的都输出出来。</p>
<h1 id="总的结果数目"><a href="#总的结果数目" class="headerlink" title="总的结果数目"></a>总的结果数目</h1><p>比如当给定括号 的对数为n的时候。总的字符数是n*2。那么总的结果可能是:</p>
<p>相当于有<code>2*n</code>个箱子。每个箱子可以选择’(‘或者’)’。那么总的数目有<code>2^(n&lt;&lt;1)</code>个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> total_size = (<span class="number">1</span>&lt;&lt;(n&lt;&lt;<span class="number">1</span>)) + <span class="number">1</span>;</div><div class="line"><span class="keyword">char</span> **ret = (<span class="keyword">char</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * total_size);</div><div class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * total_size);</div></pre></td></tr></table></figure>
<h1 id="第pos个字符应该放什么"><a href="#第pos个字符应该放什么" class="headerlink" title="第pos个字符应该放什么?"></a>第pos个字符应该放什么?</h1><p>由于所有的结果都已经放到了<code>ret</code>中。并且有一个<code>ret_tail</code>记录ret中接下来的空箱子的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> i = <span class="number">0</span> : ret &#123;</div><div class="line">    字符串 = ret[i]</div><div class="line">    根据  字符串 里面的(/)符号数</div><div class="line">        决定在后面追加的内容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环体可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line">ret[<span class="number">0</span>] = <span class="string">"("</span>;</div><div class="line"><span class="keyword">for</span> (pos = <span class="number">1</span>; pos &lt; (n&lt;&lt;<span class="number">1</span>); pos++) &#123;</div><div class="line">    <span class="comment">// 当前字符串的数目</span></div><div class="line">    cnt = ret_tail;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</div><div class="line">        <span class="built_in">string</span> = ret[i];</div><div class="line">        如果不生成新的字符串，直接在ret[i]上追加字符</div><div class="line">        如果需要生成新的字符串，ret_tail申请空间，复制ret[i],然后追加字符到ret[ret_tail];</div><div class="line">            ret_tail++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加速判断"><a href="#加速判断" class="headerlink" title="加速判断"></a>加速判断</h2><p>为了加速判断，每个字符串申请的空间是:</p>
<ol>
<li>先与4 bytes对齐</li>
<li>再多申请4个int的空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">|........string......|...|used|left|</div></pre></td></tr></table></figure>
<p>也就是前面都是正常的C字符串。只不过在这个字符串后面，多申请了一段空间用来存放<code>used/left</code>。</p>
<ul>
<li>used表示<code>(</code>用了多少？</li>
<li>left表示<code>)</code>抵消的<code>(</code>还留下多少？比如<code>(()</code>这里的<code>used=2, left = 1</code>。</li>
</ul>
<p>把这两个<code>int</code>与字符串一起放的原因是容易申请内存。也跟随字符串一起，容易定位与操作。<br>所以这里生成了两个宏，专门用来取<code>used/left</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT_COUNT(p, l) ((int*)(p + l - sizeof(int)))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> USED_COUNT(p, l) ((int*)(p + l - 2*sizeof(int)))</span></div></pre></td></tr></table></figure>
<p>有了<code>used/left</code>之后。生成新的字符串的时候，<code>used/left</code>的值，就直接在原有的字符串上累加就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_char</span><span class="params">(<span class="keyword">char</span> **ret, <span class="keyword">const</span> <span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="keyword">size_t</span> pos, <span class="keyword">const</span> <span class="keyword">size_t</span> str_len, <span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">    assert(!ret[i][pos]);</div><div class="line">    ret[i][pos] = c;</div><div class="line">    <span class="keyword">int</span> *left = LEFT_COUNT(ret[i], str_len);</div><div class="line">    <span class="keyword">int</span> *used = USED_COUNT(ret[i], str_len);</div><div class="line">    <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</div><div class="line">        *left += <span class="number">1</span>;</div><div class="line">        *used += <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;        </div><div class="line">        *left -= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Return an array of size *returnSize.</div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line">#define ROUND_UP(x) ((((x) + 3) &gt;&gt; 2) &lt;&lt; 2)</div><div class="line">#define LEFT_COUNT(p, l) ((int*)(p + l - sizeof(int)))</div><div class="line">#define USED_COUNT(p, l) ((int*)(p + l - 2*sizeof(int)))</div><div class="line"></div><div class="line">void set_char(char **ret, const size_t i, const size_t pos, const size_t str_len, char c) &#123;</div><div class="line">    assert(!ret[i][pos]);</div><div class="line">    ret[i][pos] = c;</div><div class="line">    int *left = LEFT_COUNT(ret[i], str_len);</div><div class="line">    int *used = USED_COUNT(ret[i], str_len);</div><div class="line">    if (c == '(') &#123;</div><div class="line">        *left += 1;</div><div class="line">        *used += 1;</div><div class="line">    &#125; else &#123;        </div><div class="line">        *left -= 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dup_string(char **ret, const size_t from, const size_t to, const size_t str_len, int* returnSize) &#123;</div><div class="line">    assert(!ret[to]);</div><div class="line">    ret[to] = (char*) malloc(sizeof(char) * str_len);</div><div class="line">    memcpy(ret[to], ret[from], sizeof(char) * str_len);</div><div class="line">    *returnSize += 1; // ERROR: *returnSize + 1 -&gt; *returnSize += 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">char** generateParenthesis(int n, int* returnSize) &#123;</div><div class="line">    if (0 == n) &#123;</div><div class="line">        *returnSize = 0;</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t total_size = (1&lt;&lt;(n&lt;&lt;1)) + 1;</div><div class="line">    char **ret = (char**) malloc(sizeof(char*) * total_size);</div><div class="line">    memset(ret, 0, sizeof(char*) * total_size);</div><div class="line">    </div><div class="line">    size_t str_len = ROUND_UP(n&lt;&lt;1) + (sizeof(int)&lt;&lt;2);</div><div class="line">    ret[0] = (char*) malloc(sizeof(char) * str_len);</div><div class="line">    *returnSize = 1; // ERROR: 这里也需要初始化为1</div><div class="line">    memset(ret[0], 0, sizeof(char) * str_len);</div><div class="line"></div><div class="line">    /*需要填充的字符串的位置，其中第一个位置能只填(*/</div><div class="line">    set_char(ret, 0, 0, str_len, '(');</div><div class="line"></div><div class="line">    /*指向需要填充的尾巴, ret_tail中还没有字符串生成*/</div><div class="line">    size_t ret_tail = 1;</div><div class="line"></div><div class="line">    /*其他位置*/</div><div class="line">    for (size_t pos = 1; pos &lt; (n&lt;&lt;1); pos++) &#123;</div><div class="line">        /*遍历里面的每个字符串*/</div><div class="line">        const size_t cnt = ret_tail;</div><div class="line">        for (size_t i = 0; i &lt; cnt; i++) &#123;</div><div class="line">            assert(ret[i]);</div><div class="line">            //assert(ret_tail &lt;= (1&lt;&lt;n));</div><div class="line"></div><div class="line">            char *p = ret[i];</div><div class="line">            int *left = LEFT_COUNT(p, str_len);</div><div class="line">            int *used = USED_COUNT(p, str_len);</div><div class="line"></div><div class="line">            /*如果(已经用光, 且left为0*/</div><div class="line">            if (*used == n &amp;&amp; 0 == *left) continue;</div><div class="line">            </div><div class="line">            /*如果(用光，但是left还有，只能补)*/</div><div class="line">            if (*used == n &amp;&amp; *left &gt; 0) &#123;</div><div class="line">                set_char(ret, i, pos, str_len, ')');</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            assert(*used &lt; n);</div><div class="line">            /*还有(没有用光，那么有两种情况:注意先复制!!可以省掉处理旧字符的情况*/</div><div class="line">            if (*left &gt; 0) &#123;</div><div class="line">                // b. 放(</div><div class="line">                dup_string(ret, i, ret_tail, str_len, returnSize);</div><div class="line">                set_char(ret, ret_tail, pos, str_len, '(');</div><div class="line">                ret_tail++;</div><div class="line"></div><div class="line">                // a. 放)</div><div class="line">                set_char(ret, i, pos, str_len, ')');</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /*left == 0, 只能放(*/</div><div class="line">            assert(*left == 0);</div><div class="line">            set_char(ret, i, pos, str_len, '(');</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/22" data-title="LeetCode.22 合法括号对的总排列" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/222" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/222/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/222/">LeetCode.22 反转二叉树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Invert a binary tree.</div><div class="line"></div><div class="line">Example:</div><div class="line"></div><div class="line">Input:</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div><div class="line">Output:</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="简洁写法"><a href="#简洁写法" class="headerlink" title="简洁写法"></a>简洁写法</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">invertTree_recursive</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</div><div class="line">        TreeNode* node = invertTree_recursive(root-&gt;left);</div><div class="line">        root-&gt;left = invertTree_recursive(root-&gt;right);</div><div class="line">        root-&gt;right = node;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="带栈"><a href="#带栈" class="headerlink" title="带栈"></a>带栈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 带栈的写法</div><div class="line">TreeNode* invertTree(TreeNode* root) &#123;</div><div class="line">    if (!root) return nullptr;</div><div class="line">    stack&lt;TreeNode*&gt; s;</div><div class="line">    s.push(root);</div><div class="line">    while (!s.empty()) &#123;</div><div class="line">        auto p = s.top(); s.pop();</div><div class="line">        std::swap(p-&gt;left, p-&gt;right);</div><div class="line">        if (p-&gt;left) s.push(p-&gt;left);</div><div class="line">        if (p-&gt;right) s.push(p-&gt;right);</div><div class="line">    &#125;</div><div class="line">    return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/222" data-title="LeetCode.22 反转二叉树" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/17" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/17/" class="article-date">
  	<time datetime="2018-05-02T14:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/17/">LeetCode.17 九键字母组合</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目含义"><a href="#题目含义" class="headerlink" title="题目含义"></a>题目含义</h1><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p>
<p>对于这样的一个按键。如果按下一串数字，会出现什么样的字母组合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Input: &quot;23&quot;</div><div class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</div></pre></td></tr></table></figure>
<p>输出的时候，不需要考虑顺序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>总的思想还是比较简单的。首先根据每个数字上面的字母数，得到结果总数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> len_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="number">4</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="number">4</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">    <span class="comment">/*计算总的结果数*/</span></div><div class="line">    *returnSize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = digits;</div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        (*returnSize) *= len_rec[*p] &gt; <span class="number">0</span> ? len_rec[*p] : <span class="number">1</span>;</div><div class="line">        p++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>得到总的结果数之后，可以一次性地把所有需要动态申请的内存都申请完。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*申请结果空间*/</span></div><div class="line"><span class="keyword">size_t</span> retSize = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * (*returnSize + <span class="number">1</span>);</div><div class="line"><span class="keyword">char</span> **ret = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(retSize);</div><div class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, retSize);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">    <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>);</div><div class="line">    ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">    <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始处理，比如给定的数字串是”999”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 第一个数字为<span class="number">9</span></div><div class="line">   生成相应的字符串</div><div class="line">   ar1 = </div><div class="line">   [</div><div class="line">    <span class="string">"w"</span>,</div><div class="line">    <span class="string">"x"</span>,</div><div class="line">    <span class="string">"y"</span>,</div><div class="line">    <span class="string">"z"</span>,</div><div class="line">   ]</div><div class="line"></div><div class="line"><span class="number">2.</span> 第二个数字为<span class="number">9</span></div><div class="line">   ar2 = []</div><div class="line">   <span class="keyword">for</span> c in <span class="string">"wxyz"</span>:</div><div class="line">       新数组 = ar1 + c;</div><div class="line">       ar2 = [ar2; 新数组]</div><div class="line">   如果把循环展开，就是</div><div class="line">   c = <span class="string">"w"</span></div><div class="line">   新数组 = [<span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>]</div><div class="line">   ar2 = [<span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>]</div><div class="line">   </div><div class="line">   第二次循环</div><div class="line">   c = <span class="string">"x"</span></div><div class="line">   新数组 = [<span class="string">"wx"</span>, <span class="string">"xx"</span>, <span class="string">"yx"</span>, <span class="string">"zx"</span>]</div><div class="line">   ar2 = [</div><div class="line">   <span class="string">"ww"</span>, <span class="string">"xw"</span>, <span class="string">"yw"</span>, <span class="string">"zw"</span>,</div><div class="line">   <span class="string">"wx"</span>, <span class="string">"xx"</span>, <span class="string">"yx"</span>, <span class="string">"zx"</span>,</div><div class="line">   ]</div><div class="line">   ...</div><div class="line">   </div><div class="line">   假设ar1长度为N。</div><div class="line">   那么后面每次循环的时候，只需要把</div><div class="line">   这N个字符串拷贝到新的位置。</div><div class="line">        a. 第一次添加的是<span class="number">0</span>~N<span class="number">-1</span></div><div class="line">        b. 第二次处理的字符串是N~<span class="number">2</span>N<span class="number">-1</span></div><div class="line">        c. 第三次处理的是<span class="number">2</span>N~<span class="number">3</span>N<span class="number">-1</span></div><div class="line"><span class="number">3.</span> 递归处理第三个数字</div></pre></td></tr></table></figure>
<p>这段代码的关键就是在:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</div><div class="line"><span class="comment">// pos指向当前需要处理的是哪个数字</span></div><div class="line"><span class="comment">// 同时也是结果字符串需要填充的字符</span></div><div class="line"><span class="comment">// 串的位置。</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 这段代码利用9-&gt;"wxyz"中的"w"来生成</div><div class="line"> * ar1，并且得到长度len(ar1);</div><div class="line"> */</div><div class="line"><span class="keyword">size_t</span> pos = str - a;</div><div class="line"><span class="keyword">while</span> (ret[i][<span class="number">0</span>]) &#123;  <span class="comment">// ERROR: ret[i] -&gt; ret[i][0]</span></div><div class="line">    ret[i][pos] = *dic;</div><div class="line">    assert(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; retLen);</div><div class="line">    assert(<span class="number">0</span> &lt;= pos &amp;&amp; pos &lt; dstrLen);</div><div class="line">    i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * curlen就是指len(ar1);</div><div class="line"> */</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> curlen = i;</div><div class="line"><span class="comment">// *p指向9-&gt;wxyz中的第二个字母x</span></div><div class="line"><span class="keyword">char</span> *p = dic + <span class="number">1</span>;</div><div class="line"><span class="comment">// 从第二个字母开始依次处理每个字母</span></div><div class="line"><span class="keyword">while</span> (*p) &#123;</div><div class="line">    <span class="keyword">size_t</span> npos = (p-dic)*curlen;</div><div class="line">    <span class="comment">// 在处理的时候，把</span></div><div class="line">    <span class="comment">// [0, len(ar1))拷贝到</span></div><div class="line">    <span class="comment">// [i*len(ar1), (i+1)*len(ar1) )</span></div><div class="line">    <span class="comment">// 然后再修改pos位置的字母</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; curlen; i++) &#123;</div><div class="line">        <span class="comment">// 注意处理的字符串</span></div><div class="line">        <span class="built_in">strcpy</span>(ret[npos + i], ret[i]);</div><div class="line">        assert(<span class="number">0</span> &lt;= (npos+i) &amp;&amp; (npos+i) &lt; retLen);</div><div class="line">        assert(<span class="number">0</span> &lt;= pos &amp;&amp; pos &lt; dstrLen);</div><div class="line">        ret[npos+i][pos] = *p;</div><div class="line">    &#125;</div><div class="line">    p++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里并没有使用任何第三方库。直接使用一下递归就可以了。</p>
<h1 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*单字符串快速查找*/</span></div><div class="line"><span class="keyword">char</span>* str_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="string">"abc"</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="string">"def"</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="string">"ghi"</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="string">"jkl"</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="string">"mno"</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="string">"pqrs"</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="string">"tuv"</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="string">"wxyz"</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> len_rec[] = &#123;</div><div class="line">  [<span class="string">'2'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'3'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'4'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'5'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'6'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'7'</span>] = <span class="number">4</span>,</div><div class="line">  [<span class="string">'8'</span>] = <span class="number">3</span>,</div><div class="line">  [<span class="string">'9'</span>] = <span class="number">4</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 这里递归进行处理</div><div class="line"> * str指向当前要处理的字符指针</div><div class="line"> * ret已经申请好所有的空间。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">append_char</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a, <span class="keyword">char</span> *str, <span class="keyword">char</span> **ret)</span> </span>&#123;</div><div class="line">    <span class="comment">/*已经结束*/</span></div><div class="line">    <span class="keyword">if</span> (!str || !(*str)) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*当前字符映射过去的字符串*/</span></div><div class="line">    <span class="keyword">char</span> *dic = str_rec[*str];</div><div class="line">    <span class="keyword">if</span> (!dic || !(*dic)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/*处理dic里面的第一个字符*/</span></div><div class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> pos = str - a;</div><div class="line">    <span class="keyword">while</span> (ret[i][<span class="number">0</span>]) &#123;  <span class="comment">// ERROR: ret[i] -&gt; ret[i][0]</span></div><div class="line">        ret[i][pos] = *dic;</div><div class="line">        i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*当前ret的长度*/</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> curlen = i;</div><div class="line">    <span class="keyword">char</span> *p = dic + <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        <span class="keyword">size_t</span> npos = (p-dic)*curlen;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; curlen; i++) &#123;</div><div class="line">            <span class="built_in">strcpy</span>(ret[npos + i], ret[i]);</div><div class="line">            ret[npos+i][pos] = *p;</div><div class="line">        &#125;</div><div class="line">        p++;</div><div class="line">    &#125;</div><div class="line">    append_char(a, str + <span class="number">1</span>, ret);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Return an array of size *returnSize.</div><div class="line"> * Note: The returned array must be malloced, assume caller calls free().</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">char</span>** <span class="title">letterCombinations</span><span class="params">(<span class="keyword">char</span>* digits, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</div><div class="line">    <span class="comment">/*如果为空串*/</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == digits || *digits == <span class="number">0</span>) &#123;</div><div class="line">        *returnSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*计算总的结果数*/</span></div><div class="line">    *returnSize = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> *p = digits;</div><div class="line">    <span class="keyword">while</span> (*p) &#123;</div><div class="line">        (*returnSize) *= len_rec[*p] &gt; <span class="number">0</span> ? len_rec[*p] : <span class="number">1</span>;</div><div class="line">        p++;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* d_len表示当前数字串的长度，</span></div><div class="line">     * 结果字符串的长度是d_len + 1</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> d_len = p - digits;</div><div class="line"></div><div class="line">    <span class="comment">/*申请结果空间*/</span></div><div class="line">    <span class="keyword">size_t</span> retSize = <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * (*returnSize + <span class="number">1</span>);</div><div class="line">    <span class="keyword">char</span> **ret = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(retSize);</div><div class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, retSize);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">        <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>); <span class="comment">// 这里要多申请一个char</span></div><div class="line">        ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">        <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);    <span class="comment">// ERROR: 这里一定要把n长度的字符串清0，而不只是d_len</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*处理第一个字符*/</span></div><div class="line">    <span class="keyword">char</span> *str = str_rec[*digits];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;  str[i]; i++) &#123;</div><div class="line">        ret[i][<span class="number">0</span>] = str[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    append_char(digits, digits + <span class="number">1</span>, ret);</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在提交的时候，总是遇到</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">sysmalloc: Assertion `(old_top == (((mbinptr) (((char *) &amp;((av)-&gt;bins[((1) - 1) * 2])) - __builtin_offsetof (struct malloc_chunk, fd)))) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= (unsigned long)((((__builtin_offsetof (struct malloc_chunk, fd_nextsize))+((2 *(sizeof(size_t))) - 1)) &amp; ~((2 *(sizeof(size_t))) - 1))) &amp;&amp; ((old_top)-&gt;size &amp; 0x1) &amp;&amp; ((unsigned long) old_end &amp; pagemask) == 0)' failed.</div></pre></td></tr></table></figure>
<p>说的是内存访问越界。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 这里在申请内存的时候，要多一个char</span></div><div class="line"><span class="comment">// 并且要把申请的内存空间请0.</span></div><div class="line"><span class="comment">// memset(ret[i], 0, d_len);会导致上面那个错. </span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; *returnSize; i++) &#123;</div><div class="line">    <span class="keyword">size_t</span> n = <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (d_len + <span class="number">1</span>); <span class="comment">// ERROR: 这里要多申请一个char!!!</span></div><div class="line">    ret[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n); <span class="comment">// ERROR: char *buf -&gt; ret[i]</span></div><div class="line">    <span class="built_in">memset</span>(ret[i], <span class="number">0</span>, n);    <span class="comment">// ERROR: 这里一定要把n长度的字符串清0，而不只是d_len</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/17" data-title="LeetCode.17 九键字母组合" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/02/leetcode/10/" class="article-date">
  	<time datetime="2018-05-02T02:28:32.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/02/leetcode/10/">LeetCode.10 正则表达式匹配</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，以及一个正则表达式。<br>判断给定的正则表达式是否可以表示字符串。</p>
<p>这里并没有让所有的正则表达式的符号都参与进来。<br>只是让’*’, ‘.’这两个符号加进来了。且字符串中只有<code>a~z</code>小写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">* 吃掉前面的字符，或者无视自己，或者把前面的字符重复x次。</div><div class="line">. 可以匹配任意字符</div></pre></td></tr></table></figure>
<p>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">a*有好几种解释</div><div class="line"><span class="number">1.</span> 空串后面的*把a吃掉</div><div class="line"><span class="number">2.</span> a, *自身没有起任何作用</div><div class="line"><span class="number">3.</span> aa重复<span class="number">1</span>次</div><div class="line"><span class="number">4.</span> aaa重复<span class="number">2</span>次</div></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.* 万能字符串，可以表示任何字符在重复的时候，也可以写成....这样。</div><div class="line">** 后面的*可以选择吃掉前面的字符。前面的字符*可能的一种选项就是忽略自己。</div><div class="line">   1. 空串</div><div class="line">   2. *</div><div class="line">   3. **</div><div class="line">   4. ***</div></pre></td></tr></table></figure>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>这个题的做法是典型的深度优先搜索。不过在处理的时候，可以考虑预处理一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> x*x*如果出现在正则表达式里面。实际上是可以简化成x*的。</div><div class="line"><span class="number">2.</span> x*x*x*可以优化成x*</div></pre></td></tr></table></figure>
<p>预处理的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len_p = <span class="built_in">strlen</span>(p);</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = len_p - <span class="number">1</span>; i &gt; <span class="number">1</span>; --i) &#123;</div><div class="line">        <span class="comment">// 匹配x*x*这种情况, i指向后面的那个x</span></div><div class="line">        <span class="keyword">if</span> (p[i - <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; p[i + <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; p[i] == p[i - <span class="number">2</span>]) &#123;</div><div class="line">            memmove(p + i, p + i + <span class="number">2</span>, len_p - i - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 经过上面的处理，x*x*x*可以被缩减为x*</span></div><div class="line">    <span class="comment">// 这里开始进行match匹配</span></div><div class="line">    <span class="keyword">return</span> match_sub(s, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进行匹配的时候，首先可以考虑没有<code>&#39;*&#39;</code>号的情况。比如。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">abc 与 a.c</div><div class="line">abc 与 bdc</div><div class="line"><span class="string">""</span>  与 pg</div><div class="line"><span class="literal">NULL</span> 与 abc</div></pre></td></tr></table></figure>
<p>这种都特别容易判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> same(a,b) ((a)==(b) || (<span class="meta-string">'.'</span>) == (b))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match_sub</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;*p &amp;&amp; *(p + <span class="number">1</span>) != <span class="string">'*'</span>; ++s, ++p)</div><div class="line">        <span class="keyword">if</span> (!s|| !*s || !same(*s, *p))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 此时*p == 0或p[1] == '*'</span></div><div class="line">    <span class="keyword">if</span> (!*p) <span class="keyword">return</span> <span class="literal">NULL</span> == s || *s == <span class="number">0</span>;</div><div class="line">    <span class="comment">// 此时p[1] 必然为'*'</span></div><div class="line">    </div><div class="line">    <span class="comment">// 如果当前字符相等，此时p[1] == '*'</span></div><div class="line">    <span class="comment">// 那么可以选择</span></div><div class="line">    <span class="comment">// 1. 重复 match_sub(s+1, p)</span></div><div class="line">    <span class="comment">// 2. 利用*吃掉当前字符 match_sub(s, p+2);</span></div><div class="line">    <span class="comment">// 3. a*b, *号可以选择无视自己.那么就是match_sub(s+1, p+2);</span></div><div class="line">    <span class="keyword">if</span> (*s &amp;&amp; same(*s, *p))</div><div class="line">        <span class="keyword">return</span>  match_sub(s + <span class="number">1</span>, p) || match_sub(s, p + <span class="number">2</span>) || match_sub(s+<span class="number">1</span>, p+<span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> match_sub(s, p + <span class="number">2</span>);</div><div class="line">    <span class="comment">// 除此之外的其他情况，比如*s == 0 || !same</span></div><div class="line">    <span class="comment">// 那么只能利用*号吃掉当前字符</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/10" data-title="LeetCode.10 正则表达式匹配" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-leetcode/4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/05/01/leetcode/4/" class="article-date">
  	<time datetime="2018-05-01T14:28:32.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/05/01/leetcode/4/">LeetCode.4. Median of Two Sorted Arrays</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0<br>Example 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>整体思路是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">假设有一段数据，需要找到符合要求的那个元素</div><div class="line"><span class="number">1.</span> 把数据分成两半. 有可能不是长度相等的两半</div><div class="line"><span class="number">2.</span> 扔掉肯定不符合要求的那一半</div><div class="line"><span class="number">3.</span> 回到第<span class="number">1</span>步</div></pre></td></tr></table></figure>
<p>这里面算法复杂度的关键就是在第1步里面<code>拆分成两半</code>的处理。<br>如果拆分的过程中是需要遍历每个元素。那么整个数据的处理复杂度为<code>O(n)</code>。<br>这里典型的思路就是<code>寻找第k小的数</code>。</p>
<p>如果拆分的过程中不需要遍历每个元素，可以通过快速的手段即可把整个数组<br>拆分成两部分，那么整个算法的复杂度就是<code>O(lgn)</code>。这里面典型的就是<code>二分查找</code>。</p>
<h2 id="寻找第k小的数"><a href="#寻找第k小的数" class="headerlink" title="寻找第k小的数"></a>寻找第k小的数</h2><p>首先介绍一下寻找第k小数的思路。这个思路与快排非常相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 找一个数:一般取数组的中间元素。</div><div class="line"><span class="number">2.</span> 通过这个数把数组切分成两半。左边数组a1[]比这个元素小，右边数组a2[]比这个元素大。</div><div class="line"><span class="number">3.</span> 如果k &lt;= len(a1[]), 那么k肯定只能在a1[]里面找。用a1[]来进行递归-&gt;回第<span class="number">1</span>步</div><div class="line"><span class="number">4.</span> 如果k &gt; len(a1[])，那么k肯定只能在a2[]里面找。用a2[]来进行递归-&gt;回第<span class="number">1</span>步</div></pre></td></tr></table></figure>
<p>详细代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 找到第k小的数，这里可以在POJ:</span></div><div class="line"><span class="comment">// http://poj.org/problem?id=2388</span></div><div class="line"><span class="comment">// 只不过POJ 2388是用来寻找一个有序数组中间(n/2)的那个元素。</span></div><div class="line"><span class="comment">// 利用kth变种之后，就是寻找第n/2+1小的元素。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((b+<span class="number">1</span>) == e) <span class="keyword">return</span> a[b];</div><div class="line">    <span class="keyword">int</span> i = b - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> j = e;</div><div class="line">    <span class="keyword">int</span> x = a[b+((e-b)&gt;&gt;<span class="number">1</span>)];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (a[++i]&lt;x); <span class="keyword">while</span> (a[--j] &gt; x);</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;<span class="keyword">int</span> t = a[i]; a[i] = a[j]; a[j] = t;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (k &lt;= (i-b)) <span class="keyword">return</span> kth(a, b, i, k);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> kth(a, i, e, k-(i-b));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了这段代码之后，也可以用来寻找第k大的元素。<br><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="external">LeetCode 寻找第k大的元素</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第k小与第n大的关系是</span></div><div class="line"><span class="comment">// 第1小对应于第size大</span></div><div class="line"><span class="comment">// 第size小对应于第1大</span></div><div class="line"><span class="comment">// 所以两者k+n == size+1</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> kth(nums, <span class="number">0</span>, numsSize, numsSize + <span class="number">1</span> - k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即然讲到这里，也可以把快速排序的代码整理出来。快排的题目<br><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="external">LeetCode排序</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b &gt;= e || (b+<span class="number">1</span>) == e) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> i = b <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> j = e;</div><div class="line">    <span class="keyword">int</span> x = a[b+((e-b)&gt;&gt;<span class="number">1</span>)];</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (a[++i]&lt;x); <span class="keyword">while</span> (a[--j] &gt; x);</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;<span class="keyword">int</span> t = a[i]; a[i] = a[j]; a[j] = t;&#125;</div><div class="line">    &#125;</div><div class="line">    quick_sort(a, b, i);</div><div class="line">    quick_sort(a, i, e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    quick_sort(nums, <span class="number">0</span>, numsSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>快排有个点需要注意</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b &gt;= e || (b+<span class="number">1</span>) == e) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> i = b <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> j = e;</div><div class="line">    <span class="keyword">int</span> x = a[b+((e-b)&gt;&gt;<span class="number">1</span>)];</div><div class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</div><div class="line">        <span class="keyword">while</span> (a[++i]&lt;x); <span class="keyword">while</span> (a[--j] &gt; x);</div><div class="line">        <span class="keyword">if</span> (i &lt; j) &#123;<span class="keyword">int</span> t = a[i]; a[i] = a[j]; a[j] = t;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Q: 这里i和j是什么关系？</span></div><div class="line">    <span class="comment">//    为什么后面在分界的时候，是以来进行分界的?</span></div><div class="line">    quick_sort(a, b, i);</div><div class="line">    quick_sort(a, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>while (i &lt; j)</code>结束之后，i与j的关系有两种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> i == j</div><div class="line"><span class="number">2.</span> i &gt; j</div></pre></td></tr></table></figure>
<p>当<code>i == j</code>的时候，直接用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">quick_sort(a, b, i);</div><div class="line">quick_sort(a, i, e);</div></pre></td></tr></table></figure>
<p>来排序后面的两个数组是没有问题的。</p>
<p>但是，当<code>j!=i</code>此时必然有<code>j&lt;i且j+1 == i</code><br>那么如果再用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">quick_sort(a, b, j);</div><div class="line">quick_sort(a, i, e);</div></pre></td></tr></table></figure>
<p>来排序就会出错。因为<code>a[j]</code>这个时候没有被计入到排序里面。<br>如果要把<code>a[j]</code>放到前面的数组里面一起排序。就应当把代码写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">quick_sort(a, b, j+<span class="number">1</span>);</div><div class="line">quick_sort(a, i, e);</div></pre></td></tr></table></figure>
<p>而此时<code>j+1 == i</code>。所以逻辑统一之后就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">quick_sort(a, b, i);</div><div class="line">quick_sort(a, i, e);</div></pre></td></tr></table></figure>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> *<span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *b, <span class="keyword">int</span> *e, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> *m = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</div><div class="line">        m = b + ((e-b)&gt;&gt;<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (*m == v) <span class="keyword">return</span> m;</div><div class="line">        <span class="keyword">if</span> (*m &gt; v) e = m;</div><div class="line">        <span class="keyword">else</span> b = m + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>回到题目本身，由于两个数组都是已经排好序的。找两个数组最中间的那个数。</p>
<p>由于是两个数组，在讨论的时候，可以认为是在从这两个有序数组中找第k小的元素。<br>如果数组长度为奇数，那么就是第(n/2)+1小的元素。如果长度为偶数，那么就是取<br>第(n/2)小和第(n/2)+1小的平均数。那么主函数可以写成如下样子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = nums1Size + nums2Size;</div><div class="line">    <span class="keyword">int</span> midPos = len &gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果是奇数，找最中间的元素</div><div class="line">     * 比如: 1 + 2 == 3, 3 &gt;&gt; 1 == 1 == midPos; [0,1=midPos,2]也就是要找第midPos+1个</div><div class="line">     * 如果是偶数，这里找到是前面一个元素</div><div class="line">     * 比如： 2+2=4, 4&gt;&gt;1 == 2 == midPos; [0,1,2,3] =&gt;第[1,2=midPos,3,4]个, </div><div class="line">     * 用midPos+1则找到了后面一个</div><div class="line">     */</div><div class="line">    <span class="keyword">double</span> a = findKthItem(nums1, nums1 + nums1Size, nums2, nums2 + nums2Size, midPos + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (!(len &amp; <span class="number">0x01</span>)) &#123;</div><div class="line">        <span class="comment">/*长度为偶数*/</span></div><div class="line">        <span class="keyword">double</span> b = findKthItem(nums1, nums1 + nums1Size, nums2, nums2 + nums2Size, midPos);</div><div class="line">        <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是看<code>findKthItem</code>的实现了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 给定两个数组a[], b[], 从数组a[]中找到中位数M。把a[], b[]切分成两部分。</div><div class="line">   a1[] 小于M, a2[]大于等于M</div><div class="line">   b1[] 小于M, b2[]大于等于M</div><div class="line">   两个数组相当于被切分成了两个group.</div><div class="line">   groupA = &#123;a1[], b1[]&#125;</div><div class="line">   groupB = &#123;a2[], b2[]&#125;</div><div class="line"><span class="number">2.</span> 如果k大于len(groupA)，那么要找的元素肯定在groupB. 此时k -= len(groupA)</div><div class="line">   如果k小于等于len(groupA)，那么要找到的元素肯定在groupA.</div><div class="line"><span class="number">3.</span> 回步骤<span class="number">1</span></div></pre></td></tr></table></figure>
<p>在进行第一步的时候，可以直接找最长的那个数组中位数。因为<br>最差的情况下，可以把最长数组的一半扔掉。如果是取最短的数组的中位数。<br>那么最差情况下，只能扔到最短数组的一半。不太划算。所以一开始可以写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 二分搜索</div><div class="line"> * b表示超始位置</div><div class="line"> * e表示结束位置</div><div class="line"> * 搜索范围[b, e)</div><div class="line"> * v表示要找的值</div><div class="line"> * 返回元素指针位置，如果没有找到，返回NULL</div><div class="line"> * pos指向刚好比v大的位置条件是: 如果: notFound(v) &amp;&amp; 且 *b &lt; *v &amp;&amp; *v &lt; *(e-1)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> *<span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *b, <span class="keyword">int</span> *e, <span class="keyword">int</span> *v, <span class="keyword">int</span> **less)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> *m = *less = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span> (b &lt; e) &#123;</div><div class="line">        m = b + ((e-b) &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (*m == *v) <span class="keyword">return</span> m;</div><div class="line">        <span class="keyword">if</span> (*m &gt; *v) e = m;</div><div class="line">        <span class="keyword">else</span> b = m + <span class="number">1</span>; <span class="comment">/*ERROR 1*/</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (*m &lt; *v &amp;&amp; m &lt; e) ++m; <span class="comment">/*ERROR3 这里必须要找到刚好大于v的地方*/</span></div><div class="line">    *less = m;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthItem</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *ae, <span class="keyword">int</span> *b, <span class="keyword">int</span> *be, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果b数组长于a数组，交换之</div><div class="line">     * 取长数组的中值在短数组的中二分查找，速度更快</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> ((be-b) &gt; (ae-a)) &#123;</div><div class="line">        <span class="keyword">return</span> findKthItem(b, be, a, ae, k);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assert(<span class="number">0</span> &lt; k &amp;&amp; k &lt;= ((ae-a) + (be-b)));</div><div class="line">    assert(((ae-a) + (be-b)) &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*如果B数组为空*/</span></div><div class="line">    <span class="keyword">if</span> (b == be) &#123;</div><div class="line">        <span class="keyword">return</span> a[k<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*如果A数组为空*/</span></div><div class="line">    <span class="keyword">if</span> (a == ae) &#123;</div><div class="line">        <span class="keyword">return</span> b[k<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*如果k == 1*/</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == k) &#123;</div><div class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] ? a[<span class="number">0</span>] : b[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*如果k刚好是两个数组的长度之和*/</span></div><div class="line">    <span class="keyword">if</span> (k == ((ae-a) + (be-b))) &#123;</div><div class="line">        <span class="keyword">return</span> *(ae<span class="number">-1</span>) &gt; *(be<span class="number">-1</span>) ? *(ae<span class="number">-1</span>) : *(be<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*取长数组的中值*/</span></div><div class="line">    <span class="keyword">int</span> *amid = a + ((ae - a)&gt;&gt;<span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/*在b数组中二分A数组的中间元素*/</span></div><div class="line">    <span class="keyword">int</span> *less = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> *pos = binarySearch(b, be, amid, &amp;less);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果amid不存在于B数组中，但是范围落在里面，照样可以把</div><div class="line">     * B数组切成两半，这个时候的处理情况与找到的处理是一样的</div><div class="line">     * 都是把两个数组切分成了2份。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (less &amp;&amp; (*b &lt; *amid &amp;&amp; *amid &lt; b[be-b<span class="number">-1</span>])) &#123;</div><div class="line">        pos = less;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 如果找到A数组的中间元素, 或者</div><div class="line">     * pos可以把数组B成功切分成为两半：看pos = less</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (pos) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 这个时候数组被切分为两部分</div><div class="line">         * 数组A [a, amid), [amid, ae)</div><div class="line">         * 数组B [b, pos), [pos, be)</div><div class="line">         * 看一下k所在的范围</div><div class="line">         */</div><div class="line">        <span class="comment">/*前半部分的长度*/</span></div><div class="line">        <span class="keyword">int</span> frontLength = (amid-a) + (pos-b);</div><div class="line">        <span class="comment">/*与k比较有三种结果*/</span></div><div class="line">        <span class="keyword">if</span> (frontLength == k) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 相等:</div><div class="line">             * 元素个数刚好与k相等, 只需要取最后一个元素</div><div class="line">             */</div><div class="line">            <span class="keyword">int</span> aLast = amid - a - <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> bLast = pos - b - <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> a[aLast] &gt; b[bLast] ? a[aLast] : b[bLast];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontLength &gt; k) &#123;</div><div class="line">            <span class="comment">/*前面长于k*/</span></div><div class="line">            <span class="keyword">return</span> findKthItem(a, amid, b, pos, k);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/*前面短于k*/</span></div><div class="line">            <span class="keyword">return</span> findKthItem(amid, ae, pos, be, k - frontLength);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/*can't reach here*/</span></div><div class="line">        assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 找不到，可能有三种情况，</div><div class="line">         * 1. 比数组B所有元素小</div><div class="line">         * 2. 比数组B所有元素大</div><div class="line">         * 3. 介于数组B之间</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (*amid &lt; *b) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 情况1：amid &lt; b数组中所有元素</div><div class="line">             * [a, amid), [amid, ae)</div><div class="line">             *            [b, be)</div><div class="line">             */</div><div class="line">            <span class="keyword">int</span> frontLength = amid - a;</div><div class="line">            <span class="comment">/*也是与k进行比较*/</span></div><div class="line">            <span class="keyword">if</span> (frontLength == k) &#123;</div><div class="line">                <span class="comment">/*返回front last元素*/</span></div><div class="line">                <span class="keyword">int</span> aLast = amid - a - <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> a[aLast];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontLength &gt; k) &#123;</div><div class="line">                <span class="keyword">return</span> a[k<span class="number">-1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> findKthItem(amid, ae, b, be, k - frontLength);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/*can't reach here*/</span></div><div class="line">            assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*amid &gt; b[be-b<span class="number">-1</span>]) &#123;</div><div class="line">            <span class="comment">/*</span></div><div class="line">             * 情况2: amid &gt; b数组中所有元素</div><div class="line">             * [a, amid), [amid, ae)</div><div class="line">             * [b, be)</div><div class="line">             */</div><div class="line">            assert(*amid &gt; b[be-b<span class="number">-1</span>]);</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> frontLength = amid - a + be - b;</div><div class="line">            <span class="keyword">if</span> (frontLength == k) &#123;</div><div class="line">                <span class="keyword">int</span> aLast = amid - a - <span class="number">1</span>;</div><div class="line">                <span class="keyword">int</span> bLast = be - b - <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> a[aLast] &gt; b[bLast] ? a[aLast] : b[bLast];</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frontLength &gt; k) &#123;</div><div class="line">                <span class="keyword">return</span> findKthItem(a, amid, b, be, k);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> amid[k - frontLength - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/*can't reach here*/</span></div><div class="line">            assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* ERROR2:</span></div><div class="line">             * amid 落在B组数区间中，但是不存在</div><div class="line">             * 数组被切分为[a, amid), [amid, ae)</div><div class="line">             *           [b, less), [less, be)</div><div class="line">             * 这种情况与找到的情况是一样的处理方法，前面已经pos = less</div><div class="line">             */</div><div class="line">            <span class="comment">/*can't reach here*/</span></div><div class="line">            assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*can't reach here*/</span></div><div class="line">        assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*can't reach here*/</span></div><div class="line">    assert(<span class="number">1</span> == <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意各种<code>assert</code>的运用，加强边界判断。最终通过之后，可以把相应的<code>assert</code>去掉。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/leetcode/">leetcode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-leetcode/4" data-title="LeetCode.4. Median of Two Sorted Arrays" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/jos-lab3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/28/mit.6.828/jos-lab3/" class="article-date">
  	<time datetime="2018-04-28T02:28:32.000Z" itemprop="datePublished">2018-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/28/mit.6.828/jos-lab3/">MIT 6.828 Lab3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><p>首先需要将lab2的代码与lab3进行合并。前提是lab2的代码已经通过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">athena% <span class="built_in">cd</span> ~/6.828/lab</div><div class="line">athena% add git</div><div class="line">athena% git commit -am <span class="string">'changes to lab2 after handin'</span></div><div class="line">Created commit 734fab7: changes to lab2 after handin</div><div class="line"> 4 files changed, 42 insertions(+), 9 deletions(-)</div><div class="line">athena% git pull</div><div class="line">Already up-to-date.</div><div class="line">athena% git checkout -b lab3 origin/lab3</div><div class="line">Branch lab3 <span class="built_in">set</span> up to track remote branch refs/remotes/origin/lab3.</div><div class="line">Switched to a new branch <span class="string">"lab3"</span></div><div class="line">athena% git merge lab2</div><div class="line">Merge made by recursive.</div><div class="line"> kern/pmap.c |   42 +++++++++++++++++++</div><div class="line"> 1 files changed, 42 insertions(+), 0 deletions(-)</div><div class="line">athena%</div></pre></td></tr></table></figure>
<h1 id="增加的文件"><a href="#增加的文件" class="headerlink" title="增加的文件"></a>增加的文件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"></div><div class="line">inc/    env.h    Public definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        trap.h    Public definitions <span class="keyword">for</span> <span class="built_in">trap</span> handling</div><div class="line">        syscall.h    Public definitions <span class="keyword">for</span> system calls from user environments to the kernel</div><div class="line">        lib.h    Public definitions <span class="keyword">for</span> the user-mode support library</div><div class="line">kern/    env.h    Kernel-private definitions <span class="keyword">for</span> user-mode environments</div><div class="line">        env.c    Kernel code implementing user-mode environments</div><div class="line">        trap.h    Kernel-private <span class="built_in">trap</span> handling definitions</div><div class="line">        trap.c    Trap handling code</div><div class="line">        trapentry.S    Assembly-language <span class="built_in">trap</span> handler entry-points</div><div class="line">        syscall.h    Kernel-private definitions <span class="keyword">for</span> system call handling</div><div class="line">        syscall.c    System call implementation code</div><div class="line">lib/    Makefrag    Makefile fragment to build user-mode library, obj/lib/libjos.a</div><div class="line">        entry.S    Assembly-language entry-point <span class="keyword">for</span> user environments</div><div class="line">        libmain.c    User-mode library setup code called from entry.S</div><div class="line">        syscall.c    User-mode system call stub <span class="built_in">functions</span></div><div class="line">        console.c    User-mode implementations of putchar and getchar, providing console I/O</div><div class="line">        exit.c    User-mode implementation of <span class="built_in">exit</span></div><div class="line">        panic.c    User-mode implementation of panic</div><div class="line">user/    *    Various <span class="built_in">test</span> programs to check kernel lab 3 code</div></pre></td></tr></table></figure>
<p>这里面就是lab3新增加的文件。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>JOS里面是把进程叫做<code>env</code>。定义是在<code>inc/env.h</code>。内核是用这个数据结构来管理用户的进程。</p>
<p>进程的结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env &#123;</div><div class="line">    struct Trapframe env_tf;    // Saved registers</div><div class="line">    struct Env *env_link;        // Next free Env</div><div class="line">    envid_t env_id;            // Unique environment identifier</div><div class="line">    envid_t env_parent_id;        // env_id of this env&apos;s parent</div><div class="line">    enum EnvType env_type;        // Indicates special system environments</div><div class="line">    unsigned env_status;        // Status of the environment</div><div class="line">    uint32_t env_runs;        // Number of times environment has run</div><div class="line"></div><div class="line">    // Address space</div><div class="line">    pde_t *env_pgdir;        // Kernel virtual address of page dir</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后详细介绍了每个字段。</p>
<p><strong>env_tf</strong><br>This structure, defined in inc/trap.h, holds the saved register values for the environment while that environment is not running: i.e., when the kernel or a different environment is running. The kernel saves these when switching from user to kernel mode, so that the environment can later be resumed where it left off.</p>
<p><strong>env_link</strong><br>This is a link to the next Env on the env_free_list. env_free_list points to the first free environment on the list.</p>
<p><strong>env_id</strong><br>The kernel stores here a value that uniquely identifiers the environment currently using this Env structure (i.e., using this particular slot in the envs array). After a user environment terminates, the kernel may re-allocate the same Env structure to a different environment - but the new environment will have a different env_id from the old one even though the new environment is re-using the same slot in the envs array.</p>
<p><strong>env_parent_id</strong><br>The kernel stores here the env_id of the environment that created this environment. In this way the environments can form a “family tree,” which will be useful for making security decisions about which environments are allowed to do what to whom.</p>
<p><strong>env_type</strong><br>This is used to distinguish special environments. For most environments, it will be ENV_TYPE_USER. We’ll introduce a few more types for special system service environments in later labs.</p>
<p><strong>env_status</strong><br>This variable holds one of the following values:</p>
<p><strong>ENV_FREE</strong><br>Indicates that the Env structure is inactive, and therefore on the<br>env_free_list.</p>
<p><strong>ENV_RUNNABLE</strong><br>Indicates that the Env structure represents an environment that is waiting to run on the processor.</p>
<p><strong>ENV_RUNNING</strong><br>Indicates that the Env structure represents the currently running environment.</p>
<p><strong>ENV_NOT_RUNNABLE</strong><br>Indicates that the Env structure represents a currently active environment, but it is not currently ready to run: for example, because it is waiting for an interprocess communication (IPC) from another environment.</p>
<p><strong>ENV_DYING</strong><br>Indicates that the Env structure represents a zombie environment. A zombie environment will be freed the next time it traps to the kernel. We will not use this flag until Lab 4.</p>
<p><strong>env_pgdir</strong><br>This variable holds the kernel virtual address of this environment’s page directory.</p>
<p>这个结构体是由一个链表来管理的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct Env *envs = NULL;        // All environments</div><div class="line">struct Env *curenv = NULL;        // The current env</div><div class="line">static struct Env *env_free_list;    // Free environment list</div></pre></td></tr></table></figure>
<h1 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exercise 1. Modify mem_init() in kern/pmap.c to allocate and map the envs array. This array consists of exactly NENV instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at UENVS (defined in inc/memlayout.h) so user processes can read from this array.</div><div class="line"></div><div class="line">You should run your code and make sure check_kern_pgdir() succeeds.</div></pre></td></tr></table></figure>
<p>这里其实就是两个要求。一个是在内核内存区域分配一段区域来保存这个结构体。<br>另外就是把这个结构体映射到UENVS这个区域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Make &apos;envs&apos; point to an array of size &apos;NENV&apos; of &apos;struct Env&apos;.</div><div class="line">// LAB 3: Your code here.</div><div class="line">n = sizeof(struct Env) * NENV;</div><div class="line">envs = (struct Env*) boot_alloc(n);</div><div class="line">memset(envs, 0, n);</div><div class="line"></div><div class="line">...</div><div class="line">//////////////////////////////////////////////////////////////////////</div><div class="line">// Map the &apos;envs&apos; array read-only by the user at linear address UENVS</div><div class="line">// (ie. perm = PTE_U | PTE_P).</div><div class="line">// Permissions:</div><div class="line">//    - the new image at UENVS  -- kernel R, user R</div><div class="line">//    - envs itself -- kernel RW, user NONE</div><div class="line">// LAB 3: Your code here.</div><div class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure>
<p>只需要认真读一注释就可以写出来。没有什么难度。</p>
<h1 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h1><p>配置运行环境。这里讲了一些有意思的用法。考虑这种情况。比如内核里面需要包含一个独立的程序。但是内核本身就是一个大的程序。那么如何把这个小程序放到内核里面去。</p>
<p>比如<code>obj/user/</code>这里生成一堆小程序。那么如何把这些程序放到内核程序里面？<br>实际上这些处理技巧在<code>kern/Makefrag</code>里面。</p>
<p>首先是定义需要生成的<code>binary</code>的文件列表</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Binary program images to embed within the kernel.</span></div><div class="line"><span class="comment"># Binary files for LAB3</span></div><div class="line">KERN_BINFILES :=    user/hello \</div><div class="line">            user/buggyhello \</div><div class="line">            user/buggyhello2 \</div><div class="line">            user/evilhello \</div><div class="line">            user/testbss \</div><div class="line">            user/divzero \</div><div class="line">            user/breakpoint \</div><div class="line">            user/softint \</div><div class="line">            user/badsegment \</div><div class="line">            user/faultread \</div><div class="line">            user/faultreadkernel \</div><div class="line">            user/faultwrite \</div><div class="line">            user/faultwritekernel</div><div class="line"></div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.c, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_SRCFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst %.S, $(OBJDIR)</span>/%.o, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line">KERN_OBJFILES := <span class="variable">$(patsubst $(OBJDIR)</span>/lib/%, <span class="variable">$(OBJDIR)</span>/kern/%, <span class="variable">$(KERN_OBJFILES)</span>)</div><div class="line"></div><div class="line">KERN_BINFILES := <span class="variable">$(patsubst %, $(OBJDIR)</span>/%, <span class="variable">$(KERN_BINFILES)</span>)</div></pre></td></tr></table></figure>
<p>通过如下这种方式把<code>binary</code>放到kernel中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># How to build the kernel itself</div><div class="line">$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \</div><div class="line">      $(OBJDIR)/.vars.KERN_LDFLAGS</div><div class="line">    @echo + ld $@</div><div class="line">    $(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES)</div><div class="line">    $(V)$(OBJDUMP) -S $@ &gt; $@.asm</div><div class="line">    $(V)$(NM) -n $@ &gt; $@.sym</div></pre></td></tr></table></figure>
<p>注意后面<code>-b</code>这个参数就是把后面的文件直接加载到kernel里面。由于我们现在没有文件系统，内核就把用户程序一股脑链接到自己身上，在以后有了文件系统就不需要了。但是它给了我们一个便利，我们现在可以直接在内存上运行它。</p>
<p>可执行程序现在是加载到kernel的镜像里面了。可是如果想运行的时候，又如何定位到这些程序呢？</p>
<p>这个时候如果去看<code>obj/kern/kernel.sym</code>，就会发现这里面定义了很多变量。<code>gcc</code>生成的<code>.sym</code>文件里面包含的就是编译器生成的变量表，左边是虚拟地址，右边就是对应的变量。</p>
<p>链接命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">echo @ld -o obj/kern/kernel \</div><div class="line">    -m elf_i386 \</div><div class="line">    -T kern/kernel.ld \</div><div class="line">    -nostdlib \</div><div class="line">        obj/kern/entry.o \</div><div class="line">        obj/kern/entrypgdir.o \</div><div class="line">        obj/kern/init.o \</div><div class="line">        obj/kern/console.o \</div><div class="line">        obj/kern/monitor.o \</div><div class="line">        obj/kern/pmap.o \</div><div class="line">        obj/kern/env.o \</div><div class="line">        obj/kern/kclock.o \</div><div class="line">        obj/kern/printf.o \</div><div class="line">        obj/kern/trap.o \</div><div class="line">        obj/kern/trapentry.o \</div><div class="line">        obj/kern/syscall.o \</div><div class="line">        obj/kern/kdebug.o  \</div><div class="line">        obj/kern/printfmt.o  \</div><div class="line">        obj/kern/readline.o  \</div><div class="line">        obj/kern/string.o \</div><div class="line">        /usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a \</div><div class="line">    -b binary  \</div><div class="line">        obj/user/hello  \</div><div class="line">        obj/user/buggyhello \</div><div class="line">        obj/user/buggyhello2  \</div><div class="line">        obj/user/evilhello  \</div><div class="line">        obj/user/testbss  \</div><div class="line">        obj/user/divzero  \</div><div class="line">        obj/user/breakpoint \</div><div class="line">        obj/user/softint \</div><div class="line">        obj/user/badsegment \</div><div class="line">        obj/user/faultread \</div><div class="line">        obj/user/faultreadkernel \</div><div class="line">        obj/user/faultwrite \</div><div class="line">        obj/user/faultwritekernel</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f011b356 D _binary_obj_user_hello_start</div><div class="line">f0122b88 D _binary_obj_user_buggyhello_start</div><div class="line">f0122b88 D _binary_obj_user_hello_end</div><div class="line">f012a3bf D _binary_obj_user_buggyhello2_start</div><div class="line">f012a3bf D _binary_obj_user_buggyhello_end</div><div class="line">f0131c11 D _binary_obj_user_buggyhello2_end</div><div class="line">f0131c11 D _binary_obj_user_evilhello_start</div><div class="line">f0139447 D _binary_obj_user_evilhello_end</div><div class="line">f0139447 D _binary_obj_user_testbss_start</div><div class="line">f0140c94 D _binary_obj_user_divzero_start</div><div class="line">f0140c94 D _binary_obj_user_testbss_end</div><div class="line">f01484dd D _binary_obj_user_breakpoint_start</div><div class="line">f01484dd D _binary_obj_user_divzero_end</div><div class="line">f014fd14 D _binary_obj_user_breakpoint_end</div><div class="line">f014fd14 D _binary_obj_user_softint_start</div><div class="line">f0157548 D _binary_obj_user_badsegment_start</div><div class="line">f0157548 D _binary_obj_user_softint_end</div><div class="line">f015ed7f D _binary_obj_user_badsegment_end</div><div class="line">f015ed7f D _binary_obj_user_faultread_start</div><div class="line">f01665b5 D _binary_obj_user_faultread_end</div><div class="line">f01665b5 D _binary_obj_user_faultreadkernel_start</div><div class="line">f016ddf1 D _binary_obj_user_faultreadkernel_end</div><div class="line">f016ddf1 D _binary_obj_user_faultwrite_start</div><div class="line">f0175628 D _binary_obj_user_faultwrite_end</div><div class="line">f0175628 D _binary_obj_user_faultwritekernel_start</div><div class="line">f017ce65 D _binary_obj_user_faultwritekernel_end</div></pre></td></tr></table></figure>
<p>在内核代码里面就可以通过这些变量的指示来找到相应的程序的内存在哪里。<br>那么，这些变量又是如何生成的呢？</p>
<p><a href="https://balau82.wordpress.com/2012/02/19/linking-a-binary-blob-with-gcc/" target="_blank" rel="external">gcc include binary files</a></p>
<p>这里我们假设想把一个<code>hello.c</code>文件生成的<code>binary</code>放到<code>main.c</code>生成的<code>main</code>程序里面。操作如下：</p>
<p><strong>编译hello.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">cat &lt;&lt;<span class="string">"EOF"</span>&gt; hello.<span class="function">c</span></div><div class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">EOF</div><div class="line"></div><div class="line">gcc hello.c -o hello</div></pre></td></tr></table></figure>
<p><strong>提取binary</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gcc hello.c -o hello</div><div class="line">objcopy -I binary -O elf32-i386 -B i386 hello hello.o</div></pre></td></tr></table></figure>
<p>首先说一下原理。</p>
<ul>
<li>编译生成<code>hello</code>，这是一个<code>elf</code>格式的完全可以独立运行的格式。</li>
<li>第二句话是将<code>hello</code>这个完整的<code>elf</code>当成一个巨大的<code>char binary[]</code>数组。类似于生成如下汇编代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">.global <span class="number">_b</span>inary_hello_start</div><div class="line">.global <span class="number">_b</span>inary_hello_end</div><div class="line">.global <span class="number">_b</span>inary_hello_size</div><div class="line"><span class="number">_b</span>inary_hello_start:</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line">    .db xxxxxx</div><div class="line"><span class="number">_b</span>inary_hello_end:</div><div class="line"><span class="number">_b</span>inary_hello_size:</div><div class="line">    .dword x32xxx</div></pre></td></tr></table></figure>
<p>其中<code>xxxx</code>部分就是表示<code>hello</code>整个<code>ELF</code>文件的内容。</p>
<p><code>hello.o</code>就是把这个<code>.asm</code>汇编代码转成<code>object</code>文件。不信用<code>nm -n</code>命令查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># nm -n hello.o</span></div><div class="line">00000000 D _binary_hello_start</div><div class="line">00001c88 D _binary_hello_end</div><div class="line">00001c88 A _binary_hello_size</div><div class="line">root@debug:/tmp<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>所以这里需要明白。这里的<code>hello.o</code>与</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c hello.c -o hello.o</div></pre></td></tr></table></figure>
<p>是不一样的。这两个有本质的区别。并且比较<code>hello</code>与汇编生成的<code>hello.o</code>两者的大小，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">root@debug:/tmp<span class="comment"># ls -al hello hello.o</span></div><div class="line">-rwxr-xr-x 1 root root 7304  4月 24 08:05 hello</div><div class="line">-rw-r--r-- 1 root root 7730  4月 24 08:05 hello.o  &lt;-- 要大很多</div></pre></td></tr></table></figure>
<p><strong>添加</strong></p>
<p>准备<code>main.c</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_start;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_end;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="number">_b</span>inary_hello_size;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *pblob = &amp;<span class="number">_b</span>inary_hello_start;</div><div class="line">  <span class="keyword">while</span>(pblob &lt; &amp;<span class="number">_b</span>inary_hello_end)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %02X\n"</span>, pblob - &amp;<span class="number">_b</span>inary_hello_start, *pblob);</div><div class="line">    pblob++;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"size: %d\n"</span>, &amp;<span class="number">_b</span>inary_hello_size);</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>整合到一起</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gcc -c main.c -o main.o</div><div class="line">gcc main.o hello.o -o <span class="built_in">test</span></div></pre></td></tr></table></figure>
<h2 id="env-init"><a href="#env-init" class="headerlink" title="env_init()"></a>env_init()</h2><p>这个函数的作用很简单，就是完成如下功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></div><div class="line"><span class="comment">// 把env_ids = 0</span></div><div class="line"><span class="comment">// and insert them into the env_free_list.</span></div><div class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></div><div class="line"><span class="comment">// 注意顺序，链表的是顺序与数组的顺序是完全一致的。</span></div><div class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></div><div class="line"><span class="comment">// env_alloc() returns envs[0]).</span></div><div class="line"><span class="comment">// 比如第一次申请的时候，肯定拿到的是envs[0]</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Set up envs array</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 直接用memset把所有元素清0了。</span></div><div class="line">    <span class="comment">// 这里其实不用清0也没有关系。是因为在mem_init里面已经清0b 。</span></div><div class="line">    </div><div class="line">    <span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(envs));</div><div class="line">    env_free_list = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        envs[i].env_link = env_free_list;</div><div class="line">        env_free_list = envs + i;</div><div class="line">    &#125;</div><div class="line">    assert(env_free_list == envs);</div><div class="line">    <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">    env_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里犯过的一个错误是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样操作，实际上是会造成溢出。这个循环也就会一直出问题。</p>
<h2 id="env-setup-vm"><a href="#env-setup-vm" class="headerlink" title="env_setup_vm()"></a>env_setup_vm()</h2><p>这个函数的功能实际上就是给进程分配页目录表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></div><div class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></div><div class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></div><div class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></div><div class="line"><span class="comment">// of the environment's virtual address space.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></div><div class="line"><span class="comment">//    -E_NO_MEM if page directory or table could not be allocated.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">struct</span> PageInfo *p = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a page for the page directory</span></div><div class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">    <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint:</span></div><div class="line">    <span class="comment">//    - The VA space of all envs is identical above UTOP</span></div><div class="line">    <span class="comment">//    (except at UVPT, which we've set below).</span></div><div class="line">    <span class="comment">//    See inc/memlayout.h for permissions and layout.</span></div><div class="line">    <span class="comment">//    Can you use kern_pgdir as a template?  Hint: Yes.</span></div><div class="line">    <span class="comment">//    (Make sure you got the permissions right in Lab 2.)</span></div><div class="line">    <span class="comment">//    - The initial VA below UTOP is empty.</span></div><div class="line">    <span class="comment">//    - You do not need to make any more calls to page_alloc.</span></div><div class="line">    <span class="comment">//    - Note: In general, pp_ref is not maintained for</span></div><div class="line">    <span class="comment">//    physical pages mapped only above UTOP, but env_pgdir</span></div><div class="line">    <span class="comment">//    is an exception -- you need to increment env_pgdir's</span></div><div class="line">    <span class="comment">//    pp_ref for env_free to work correctly.</span></div><div class="line">    <span class="comment">//    - The functions in kern/pmap.h are handy.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// 要点：高于UTOP的虚拟地址都是一样的。因为给内核用了。但是UVPT除外。</span></div><div class="line">    <span class="comment">//      这里需要利用kern_pgdir作为一个模板</span></div><div class="line">    <span class="comment">// 确保kern_pgdir里面的权限是正确设置的。</span></div><div class="line">    <span class="comment">//      1. 小于UTOP的地址是空的</span></div><div class="line">    <span class="comment">//      2. 不需要调用page_alloc</span></div><div class="line">    <span class="comment">//      3. pp_ref高于UTOP的部分是不维护的。因为只有内核在用。</span></div><div class="line">    <span class="comment">//         但是env_pgdir是个例外，因为可能其他进程的页表会引用到</span></div><div class="line">    <span class="comment">//         所以需要p-&gt;pp_ref++;</span></div><div class="line">    e-&gt;env_pgdir = page2kva(p);</div><div class="line">    p-&gt;pp_ref++;</div><div class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</div><div class="line"></div><div class="line">    <span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">    <span class="comment">// Permissions: kernel R, user R</span></div><div class="line">    e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里也是像内核一样，把<code>UVPT</code>这块空间映射到了页目录表这里。通过这样一个映射。进程在查看自己的<br>内存信息的时候，可以直接通过<code>UVPT</code>这个地址得到。</p>
<p>这样可以发现，内核并没有提供一个叫<code>get_pgdir(void **pgdir)</code>这样的一个系统调用给用户进程。<br>而是通过一种共享内存的方式来实现的。而在<code>linux</code>系统里面，很多信息则是通过<code>/proc, /sysfs</code>这两个文件系统<br>接口来提供的。</p>
<h2 id="region-alloc"><a href="#region-alloc" class="headerlink" title="region_alloc"></a>region_alloc</h2><p><code>region_alloc</code>函数的功能就是填充<code>va</code>起始的虚拟地址。需要找到长度为<code>len</code>的物理内存地址来填满。<br>函数总的来说，还是比较简单。毕竟只是一个<code>lab</code>。并不需要考虑页面不够的情况。</p>
<p>唯一需要处理的就是把地址对齐之后，然后一页一页地开始处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></div><div class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></div><div class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></div><div class="line"><span class="comment">// Pages should be writable by user and kernel.</span></div><div class="line"><span class="comment">// Panic if any allocation attempt fails.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></div><div class="line">    <span class="comment">//   'va' and 'len' values that are not page-aligned.</span></div><div class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></div><div class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></div><div class="line">    <span class="comment">// 分配len字节的物理地址给进程env，并且要映射到虚拟地址va.</span></div><div class="line">    <span class="comment">// 不要初始化这个映射的页面。</span></div><div class="line">    <span class="comment">// 页面要可读，可写</span></div><div class="line">    <span class="comment">// 如果分配失败要panic.</span></div><div class="line">    <span class="comment">// region_alloc</span></div><div class="line">    <span class="keyword">void</span> *v = ROUNDDOWN(va, PGSIZE);</div><div class="line">    <span class="keyword">size_t</span> l = ROUNDUP(len, PGSIZE);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; l; i += PGSIZE) &#123;</div><div class="line">        <span class="keyword">struct</span> PageInfo *p = page_alloc(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (!p) &#123;</div><div class="line">            panic(<span class="string">"region_alloc :%e"</span>, -E_NO_MEM);</div><div class="line">        &#125;</div><div class="line">        assert(!page_insert(e-&gt;env_pgdir, p, v, PTE_U | PTE_W));</div><div class="line">        v += PGSIZE;</div><div class="line">        <span class="comment">// 不要溢出</span></div><div class="line">        assert(v &gt; va &amp;&amp; i &lt; len);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意对于溢出的检查和处理。</p>
<h2 id="load-icode"><a href="#load-icode" class="headerlink" title="load_icode"></a>load_icode</h2><p><code>load_icode</code>函数本身是用来加载整个程序的。因为程序是<code>ELF</code>格式的。<br><code>ELF</code>里面提明了需要加到载的段内存地址<code>ph-&gt;p_va</code>，要加载的段的长度<code>ph-&gt;p_filesz</code>等信息。<br>仔细读一下注释就可以把代码写出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></div><div class="line"><span class="comment">// for a user process.</span></div><div class="line"><span class="comment">// 设置一个初始的程序代码段，栈，CPU标志位给用户程序。</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// 这个函数只会在内核初始化的时候被调用。并且是在第一次跳到用户</span></div><div class="line"><span class="comment">// 模式环境之前。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></div><div class="line"><span class="comment">// into the environment's user memory, starting at the appropriate</span></div><div class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 这个函数加载所有从ELF二进制里面可加载的段到用户环境的内存里面。</span></div><div class="line"><span class="comment">// 加载到合适的想到的虚拟地址那里去。</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></div><div class="line"><span class="comment">// that are marked in the program header as being mapped</span></div><div class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program's bss section.</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 同时这个程序也会把应该清0的段对应的内存进行清0操作。比如程序里面的</span></div><div class="line"><span class="comment">// bss段。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></div><div class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></div><div class="line"><span class="comment">// boot/main.c to get ideas.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 实际上这个跟我们前面在bootloader里面做的事情是很像的。这个时候可以看</span></div><div class="line"><span class="comment">// 看boot/main.c。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Finally, this function maps one page for the program's initial stack.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 最后会加载一页做为程序初始的栈。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// load_icode panics if it encounters problems.</span></div><div class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></div><div class="line"><span class="comment">// 在什么情况下load_icode会挂掉。</span></div><div class="line"><span class="comment">// 给定的输入可能会出啥问题。</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">uint8_t</span> *binary)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Hints:</span></div><div class="line">    <span class="comment">//  Load each program segment into virtual memory</span></div><div class="line">    <span class="comment">//  at the address specified in the ELF segment header.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF header里面记录了所有的段的信息。</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  只加载：ph-&gt;p_type = ELF_PROG_LOAD</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Each segment's virtual address can be found in ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段的虚拟地址: ph-&gt;p_va</span></div><div class="line">    <span class="comment">//  段大小: ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></div><div class="line">    <span class="comment">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span></div><div class="line">    <span class="comment">//  ph-&gt;p_va.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  段起始: binary + ph-&gt;p_offset</span></div><div class="line">    <span class="comment">//  段长： ph-&gt;p_filesz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Any remaining memory bytes should be cleared to zero.</span></div><div class="line">    <span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  清零段：ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  All page protection bits should be user read/write for now.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  页权限: PTE_U | PTE_W</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></div><div class="line">    <span class="comment">//  assume for this function that no two segments will touch</span></div><div class="line">    <span class="comment">//  the same virtual page.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  ELF段不需要页对齐：不会有两个段指向同样的虚拟地址</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You may find a function like region_alloc useful.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  region_alloc有用</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  Loading the segments is much simpler if you can move data</span></div><div class="line">    <span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></div><div class="line">    <span class="comment">//  So which page directory should be in force during</span></div><div class="line">    <span class="comment">//  this function?</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  加载段还是比较简单的，比如可以把数据直接从含有ELF虚拟地址空间</span></div><div class="line">    <span class="comment">//  复制过去。所以这个时候应该加载的是哪个页目录表？</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  You must also do something with the program's entry point,</span></div><div class="line">    <span class="comment">//  to make sure that the environment starts executing there.</span></div><div class="line">    <span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  你必须要利用program entry来做一些事情，以确保后面从这里开始执行。</span></div><div class="line">    <span class="comment">//  env_run &amp; env_pop_tf().</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Elf *ELFHDR = (<span class="keyword">struct</span> Elf*)binary;</div><div class="line">    assert(ELFHDR-&gt;e_magic == ELF_MAGIC);</div><div class="line">    <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></div><div class="line">    ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">    eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">            region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">            <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">            <span class="keyword">uint8_t</span> *dst = (<span class="keyword">uint8_t</span>*)ph-&gt;p_va;</div><div class="line">            <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">            <span class="comment">// uint8_t *dst = page2kva(page_lookup(e-&gt;env_pgdir, (void *)(ph-&gt;p_va), NULL));</span></div><div class="line">            <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">                <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    lcr3(PADDR(kern_pgdir));</div><div class="line">    e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div><div class="line"></div><div class="line">    <span class="comment">// Now map one page for the program's initial stack</span></div><div class="line">    <span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    region_alloc(e, (<span class="keyword">void</span>*)(USTACKTOP - PGSIZE), PGSIZE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里唯一需要注意的是：以下这种方式是不工作的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</div><div class="line">eph = ph + ELFHDR-&gt;e_phnum;</div><div class="line">lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</div><div class="line">    <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">        region_alloc(e, (<span class="keyword">void</span>*)(ph-&gt;p_va), ph-&gt;p_memsz);</div><div class="line">        <span class="keyword">uint8_t</span> *src = binary + ph-&gt;p_offset;</div><div class="line">        <span class="comment">// 由于页面可能不是连续的，所以这里这种拷贝方式不工作</span></div><div class="line">        <span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div><div class="line">        <span class="built_in">memcpy</span>(dst, src, ph-&gt;p_filesz);</div><div class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &lt; ph-&gt;p_memsz) &#123;</div><div class="line">            <span class="built_in">memset</span>(dst + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</div></pre></td></tr></table></figure>
<p>首先说一下这种写法的意图。意图就是通过<code>kern_pgdir</code>这个虚拟地址空间把相应的页拷贝过去。<br>但是这里需要注意的是。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">uint8_t</span> *dst = page2kva(page_lookup(e-&gt;env_pgdir, (<span class="keyword">void</span> *)(ph-&gt;p_va), <span class="literal">NULL</span>));</div></pre></td></tr></table></figure>
<p>这种拷贝方式只对单页面有效的。对于一个段，如果超出两个页，而这个两个页面在物理上并不连续的时候。<br>就出问题。</p>
<p>此外，一定要注意<code>tf_eip</code>的设置。</p>
<h2 id="env-create"><a href="#env-create" class="headerlink" title="env_create"></a>env_create</h2><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></div><div class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></div><div class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></div><div class="line"><span class="comment">// before running the first user-mode environment.</span></div><div class="line"><span class="comment">// The new env's parent ID is set to 0.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">struct</span> Env *init_task = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 必须成功</span></div><div class="line">    assert(!env_alloc(&amp;init_task, <span class="number">0</span>));</div><div class="line">    init_task-&gt;env_parent_id = <span class="number">0</span>;</div><div class="line">    init_task-&gt;env_type = type;</div><div class="line">    load_icode(init_task, binary);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是申请一个进程描述符，然后把相应的代码加载上去。</p>
<h2 id="env-run"><a href="#env-run" class="headerlink" title="env_run"></a>env_run</h2><p>调度到用户进程上执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Context switch from curenv to env e.</span></div><div class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This function does not return.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></div><div class="line">    <span class="comment">//       1. Set the current environment (if any) back to</span></div><div class="line">    <span class="comment">//          ENV_RUNNABLE if it is ENV_RUNNING (think about</span></div><div class="line">    <span class="comment">//          what other states it can be in),</span></div><div class="line">    <span class="comment">//       2. Set 'curenv' to the new environment,</span></div><div class="line">    <span class="comment">//       3. Set its status to ENV_RUNNING,</span></div><div class="line">    <span class="comment">//       4. Update its 'env_runs' counter,</span></div><div class="line">    <span class="comment">//       5. Use lcr3() to switch to its address space.</span></div><div class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment's</span></div><div class="line">    <span class="comment">//       registers and drop into user mode in the</span></div><div class="line">    <span class="comment">//       environment.</span></div><div class="line"></div><div class="line">    <span class="comment">// Hint: This function loads the new environment's state from</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf.  Go back through the code you wrote above</span></div><div class="line">    <span class="comment">//    and make sure you have set the relevant parts of</span></div><div class="line">    <span class="comment">//    e-&gt;env_tf to sensible values.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line">    &#125;</div><div class="line">    curenv = e;</div><div class="line">    curenv-&gt;env_status = ENV_RUNNING;</div><div class="line">    e-&gt;env_runs++;</div><div class="line">    lcr3(PADDR(e-&gt;env_pgdir));</div><div class="line">    env_pop_tf(&amp;(e-&gt;env_tf));</div><div class="line">    <span class="comment">// panic("env_run not yet implemented");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是做了一个非常简单的进程切换。把当前<code>curenv</code>进程切换到要运行的进程<code>e</code>上面。<br>过程还是比较简单，直接把页目录表加载上去之后，就开始跑了。</p>
<p>调用过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">start (kern/entry.S)</div><div class="line">i386_init (kern/init.c)</div><div class="line">    cons_init</div><div class="line">    mem_init</div><div class="line">    env_init</div><div class="line">    trap_init (still incomplete at this point)</div><div class="line">    env_create  # 建页目录表，加载代码</div><div class="line">    env_run     # 切换上下文</div><div class="line">        env_pop_tf</div></pre></td></tr></table></figure>
<p>注意，这里如果打算直接跑一下<code>make qemu-nox</code>的话。整个<code>OS</code>会不断地重启。<br>这是因为中断还没有设置。当<code>hello world</code>打算退出的时候，就会调用<code>sys_exit</code>系统调用。<br>中断还没有设置时，就会遇以保护错误。这个时候系统就会不断重启。</p>
<p><strong>注意</strong>如果是使用的MIT打补丁的<code>qemu</code>是不会重启的。只是这里没有必要专门为了这么一个实验去<br>搞他的那个补丁。</p>
<h1 id="中断号的描述"><a href="#中断号的描述" class="headerlink" title="中断号的描述"></a>中断号的描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:id :type :errorCode :info</div><div class="line">:0 :Fault :No :Divide Error</div><div class="line">:1 :Fault/Trap :No :Debug Exception</div><div class="line">:2 :Interrupt :No :NMI Interrupt</div><div class="line">:3 :Trap :No :Breakpoint</div><div class="line">:4 :Trap :No :Overflow</div><div class="line">:5 :Fault :No :Bound Check</div><div class="line">:6 :Fault :No :Illegal Opcode</div><div class="line">:7 :Fault :No :Device Not available</div><div class="line">:8 :Abort :Yes :Double Fault</div><div class="line">:10 :Fault :Yes :Invalid TSS</div><div class="line">:11 :Fault :Yes :Segment Not Present</div><div class="line">:12 :Fault :Yes :Stack Exception</div><div class="line">:13 :Fault :Yes :General Protection Fault</div><div class="line">:14 :Fault :Yes :Page Fault</div><div class="line">:16 :Fault :No :Floating Point Error</div><div class="line">:17 :Fault :Yes :Alignment Check</div><div class="line">:18 :Abort :No :Machine Check</div><div class="line">:19 :Fault :No :Simd Floating Point Error</div></pre></td></tr></table></figure>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>这里需要看一下这个图。</p>
<p><img src="/blog/img/mit.6.828/lab3.idt.jpeg" alt=""></p>
<p>如果对应到源码里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* Interrupt descriptor table.  (Must be built at run time because</span></div><div class="line"> * shifted function addresses can't be represented in relocation records.)</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> Gatedesc idt[<span class="number">256</span>] = &#123; &#123; <span class="number">0</span> &#125; &#125;;</div><div class="line"><span class="keyword">struct</span> Pseudodesc idt_pd = &#123;</div><div class="line">    <span class="keyword">sizeof</span>(idt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>) idt</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的<code>idt</code>就是存放256个中断描述符的地方。只过这个时候还没有把<code>idt</code>加载到<code>CPU</code>上。而在<code>trap_init</code>的时候<br>把这些中断描述符填上去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">struct</span> Segdesc gdt[];</div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DIVIDE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEBUG_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_NMI_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BRKPT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_OFLOW_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_BOUND_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ILLOP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DEVICE_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_DBLFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_TSS_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SEGNP_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_STACK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_GPFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_PGFLT_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_FPERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_ALIGN_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_MCHK_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SIMDERR_handler</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">T_SYSCALL_handler</span><span class="params">()</span></span>;</div><div class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, T_DIVIDE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, T_DEBUG_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, T_NMI_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, T_BRKPT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_OFLOW], <span class="number">1</span>, GD_KT, T_OFLOW_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, T_BOUND_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, T_ILLOP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, T_DEVICE_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, T_DBLFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, T_TSS_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, T_SEGNP_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, T_STACK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, T_GPFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, T_PGFLT_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, T_FPERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, T_ALIGN_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, T_MCHK_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, T_SIMDERR_handler, <span class="number">0</span>);</div><div class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, T_SYSCALL_handler, <span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Per-CPU setup </span></div><div class="line">    trap_init_percpu();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init_percpu</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></div><div class="line">    <span class="comment">// when we trap to the kernel.</span></div><div class="line">    ts.ts_esp0 = KSTACKTOP;</div><div class="line">    ts.ts_ss0 = GD_KD;</div><div class="line">    ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</div><div class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></div><div class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></div><div class="line">    ltr(GD_TSS0);</div><div class="line"></div><div class="line">    <span class="comment">// Load the IDT</span></div><div class="line">    lidt(&amp;idt_pd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可能的面临的一个问题是，这些中断处理程序是在哪里定义的呢？那么接下来写<code>trapentry.S</code>。</p>
<h3 id="trapentry-S"><a href="#trapentry-S" class="headerlink" title="trapentry.S"></a>trapentry.S</h3><p>整个中断的调用过程如下图所示：</p>
<p><img src="/blog/img/lab3.process.jpeg" alt=""></p>
<p>因此，在写代码的时候，需要先写<code>trapentry.S</code>里面的代码。首先读一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</div><div class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</div><div class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</div><div class="line"> *</div><div class="line"> * You shouldn&apos;t call a TRAPHANDLER function from C, but you may</div><div class="line"> * need to _declare_ one in C (for instance, to get a function pointer</div><div class="line"> * during IDT setup).  You can declare the function with</div><div class="line"> *   void NAME();</div><div class="line"> * where NAME is the argument passed to TRAPHANDLER.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER(name, num)                        \</div><div class="line">    .globl name;        /* define global symbol for &apos;name&apos; */    \</div><div class="line">    .type name, @function;    /* symbol type is function */        \</div><div class="line">    .align 2;        /* align function definition */        \</div><div class="line">    name:            /* function starts here */        \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div><div class="line"></div><div class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&apos;t push an error code.</div><div class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class="line"> * format in either case.</div><div class="line"> */</div><div class="line">#define TRAPHANDLER_NOEC(name, num)                    \</div><div class="line">    .globl name;                            \</div><div class="line">    .type name, @function;                        \</div><div class="line">    .align 2;                            \</div><div class="line">    name:                                \</div><div class="line">    pushl $0;                            \</div><div class="line">    pushl $(num);                            \</div><div class="line">    jmp _alltraps</div></pre></td></tr></table></figure>
<p>这是因为<code>x86</code>的CPU硬件在遇到中断的时候，会进行自动化的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> 如果是在ring <span class="number">0</span>，那么直接使用当前的ss/esp</div><div class="line"><span class="number">2.</span> 如果是在ring <span class="number">3</span>, 那么使用当前tss段里面的ss0/esp0。然后开始压栈</div></pre></td></tr></table></figure>
<p>无错误码时压栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP </div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>对于这种情况。<code>TRAPHANDLER_NOEC</code>会额外地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pushl $0;</div></pre></td></tr></table></figure>
<p>有错误码时压栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20</div><div class="line">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>因此，当压完栈之后。栈中的元素就是对应下面罗列的元素。由此可知，<br><strong>硬件栈是从上往下增长，一个结构体，代码最下面的元素是最先入栈。</strong></p>
<p>如果把结构体里面所有的元素放在从左往右的一行上。压栈顺序与函数入栈的顺序也是一样的。即从<strong>右往左</strong>入栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Trapframe &#123;</div><div class="line">    .....</div><div class="line">    <span class="keyword">uint32_t</span> tf_trapno;</div><div class="line">    <span class="comment">/* below here defined by x86 hardware */</span></div><div class="line">    <span class="keyword">uint32_t</span> tf_err;</div><div class="line">    <span class="keyword">uintptr_t</span> tf_eip;</div><div class="line">    <span class="keyword">uint16_t</span> tf_cs;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding3;</div><div class="line">    <span class="keyword">uint32_t</span> tf_eflags;</div><div class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></div><div class="line">    <span class="keyword">uintptr_t</span> tf_esp;</div><div class="line">    <span class="keyword">uint16_t</span> tf_ss;</div><div class="line">    <span class="keyword">uint16_t</span> tf_padding4;</div><div class="line">&#125; <span class="number">__</span>attribute__((packed));</div></pre></td></tr></table></figure>
<p>这些元素，有些是硬件压入栈的。有些是两个宏压入栈的。<br>但是，这两个宏的本意是用来声明中断处理函数的。这个时候可以根据硬件中断的描述编写代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line">TRAPHANDLER_NOEC(T_DIVIDE_handler, T_DIVIDE)</div><div class="line">TRAPHANDLER_NOEC(T_DEBUG_handler, T_DEBUG)</div><div class="line">TRAPHANDLER_NOEC(T_NMI_handler, T_NMI)</div><div class="line">TRAPHANDLER_NOEC(T_BRKPT_handler, T_BRKPT)</div><div class="line">TRAPHANDLER_NOEC(T_OFLOW_handler, T_OFLOW)</div><div class="line">TRAPHANDLER_NOEC(T_BOUND_handler, T_BOUND)</div><div class="line">TRAPHANDLER_NOEC(T_ILLOP_handler, T_ILLOP)</div><div class="line">TRAPHANDLER_NOEC(T_DEVICE_handler, T_DEVICE)</div><div class="line">TRAPHANDLER(T_DBLFLT_handler, T_DBLFLT)</div><div class="line">TRAPHANDLER(T_TSS_handler, T_TSS)</div><div class="line">TRAPHANDLER(T_SEGNP_handler, T_SEGNP)</div><div class="line">TRAPHANDLER(T_STACK_handler, T_STACK)</div><div class="line">TRAPHANDLER(T_GPFLT_handler, T_GPFLT)</div><div class="line">TRAPHANDLER(T_PGFLT_handler, T_PGFLT)</div><div class="line">TRAPHANDLER_NOEC(T_FPERR_handler, T_FPERR)</div><div class="line">TRAPHANDLER(T_ALIGN_handler, T_ALIGN)</div><div class="line">TRAPHANDLER_NOEC(T_MCHK_handler, T_MCHK)</div><div class="line">TRAPHANDLER_NOEC(T_SIMDERR_handler, T_SIMDERR)</div><div class="line">TRAPHANDLER_NOEC(T_SYSCALL_handler, T_SYSCALL)</div></pre></td></tr></table></figure>
<p>在写这里的时候，一定不要忘了系统调用号<code>T_SYSCALL</code>的设置。</p>
<h3 id="统一的中断处理"><a href="#统一的中断处理" class="headerlink" title="统一的中断处理"></a>统一的中断处理</h3><p>但是<code>struct Trapframe</code>里面还有好多其他元素。后面还是需要接着再入栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line"> * 注意压栈的顺序是从struct Trapframe的底部往上压</div><div class="line"> * 看一下前面的宏，已经压参数，压到了tf_trapno这里了。</div><div class="line"> * 注意：使用pusha指令</div><div class="line"> */</div><div class="line">_alltraps:</div><div class="line">    /*</div><div class="line">     * 注意这里直接用了pushl前面自动补0</div><div class="line">     * 如果要严格的对应</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %ds</div><div class="line">     * - pushw $0</div><div class="line">     * - pushw %es</div><div class="line">     */</div><div class="line">    pushl %ds</div><div class="line">    pushl %es</div><div class="line">    pushal</div><div class="line">    /*</div><div class="line">     * 这里是因为后面要调用trap函数</div><div class="line">     * 1. </div><div class="line">     *   trap函数的定义是trap(struct Trapframe *tf)</div><div class="line">     *   这里还有一个指针</div><div class="line">     *   这个时候压入pushl %esp这个寄存器的内容。</div><div class="line">     *   也就刚好是真正的指向struct Trapframe这个object的起始地址</div><div class="line">     * 2. </div><div class="line">     *   如果trap函数的定义是trap(struct Trapframe tfObject)</div><div class="line">     *   那么这个pushl %esp是没有必要压进去的</div><div class="line">     */</div><div class="line">    pushl %esp</div><div class="line">    /*然后指向内核数据段</div><div class="line">     * 硬件上中断门描述符进来的时候</div><div class="line">     * 已经把CPU设置成了GD_KT也就是内核代码段。</div><div class="line">     * 这个是硬件操作</div><div class="line">     */</div><div class="line">    movw $GD_KD, %ax</div><div class="line">    movw %ax, %ds</div><div class="line">    movw %ax, %es</div><div class="line">    call trap</div><div class="line"></div><div class="line">    /* 操作完成之后，</div><div class="line">     * 没有必要要按照反方向的顺序返回</div><div class="line">     * 因为trap函数最终会走到env_pop_tf()这个函数</div><div class="line">     * movl $tf, %esp</div><div class="line">     * popal</div><div class="line">     * popl %es</div><div class="line">     * popl %ds</div><div class="line">     * addl $0x08, %esp</div><div class="line">     * iret</div><div class="line">     */</div></pre></td></tr></table></figure>
<p>注意上面代码中的注释。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这个时候可以总结一下了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 发生中断或者trap，从ldtr里面找到ldt。</div><div class="line">2. 根据中断号找到这一项，即ldt[中断号]</div><div class="line">3. 根据ldt[中断号] == SETGATE(idt[T_MCHK], 0, GD_KT, T_MCHK_handler, 0);</div><div class="line">   取出当时设置的中断处理函数</div><div class="line">4. 跳转到中断函数</div><div class="line">5. 中断处理函数再跳转到trap函数。</div><div class="line">6. trap函数再根据tf-&gt;trap_no中断号来决定分发给哪个函数。</div></pre></td></tr></table></figure>
<p>也就是如下图：</p>
<p><img src="/blog/img/mit.6.828/lab3.irq.jpeg" alt=""></p>
<h2 id="trap-dispatch"><a href="#trap-dispatch" class="headerlink" title="trap_dispatch"></a>trap_dispatch</h2><p>trap函数接下来就是调用<code>trap_dispatch</code>分发了中断。所以函数的具体实现还得转到<code>trap_dispatch</code>这个函数里面来。<br>这个时候就要开始做练习5了。</p>
<p>Exercise 5. Modify <code>trap_dispatch()</code> to dispatch page fault exceptions to <code>page_fault_handler()</code>.<br>You should now be able to get make grade to succeed on the <code>faultread</code>, <code>faultreadkernel</code>,<br><code>faultwrite</code>, and <code>faultwritekernel</code> tests. If any of them don’t work, figure out why and<br>fix them. Remember that you can boot JOS into a particular user program using <code>make run-x</code><br>or <code>make run-x-nox</code>. For instance, <code>make run-hello-nox</code> runs the <code>hello</code> user program.</p>
<p>这里还是比较简单。<strong>注意</strong>这里只需要转到<code>page_fault_handler()</code>就可以了。并不需要在<code>page_fault_handler()</code>里面做任何真正的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"><span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</div><div class="line"><span class="keyword">case</span> T_PGFLT:</div><div class="line">    page_fault_handler(tf);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，对于断点来说，也是需要再加一个<code>case</code>就可了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_BRKPT:</div><div class="line">    monitor(tf);</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>但是需要注意，在以前写代码的时候，设置<code>SETGATE</code>的时候，需要设置<code>dpl=3</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SETGATE(idt[T_BRKPT], 1, GD_KT, T_BRKPT_handler, 3);</div></pre></td></tr></table></figure>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在开始写之前，需要考虑客户端是如何调用的。<code>inc/syscall.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* system call numbers */</span></div><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    SYS_cputs = <span class="number">0</span>,</div><div class="line">    SYS_cgetc,</div><div class="line">    SYS_getenvid,</div><div class="line">    SYS_env_destroy,</div><div class="line">    NSYSCALLS</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里定义了系统调用的数目。客户端的使用代码位于<code>lib/syscall.c</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">static inline int32_t</div><div class="line">syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)</div><div class="line">&#123;</div><div class="line">    int32_t ret;</div><div class="line"></div><div class="line">    // Generic system call: pass system call number in AX,</div><div class="line">    // up to five parameters in DX, CX, BX, DI, SI.</div><div class="line">    // Interrupt kernel with T_SYSCALL.</div><div class="line">    //</div><div class="line">    // The "volatile" tells the assembler not to optimize</div><div class="line">    // this instruction away just because we don't use the</div><div class="line">    // return value.</div><div class="line">    //</div><div class="line">    // The last clause tells the assembler that this can</div><div class="line">    // potentially change the condition codes and arbitrary</div><div class="line">    // memory locations.</div><div class="line"></div><div class="line">    asm volatile("int %1\n"      // 这里指向num</div><div class="line">             : "=a" (ret)        // 返回值从eax 设置到 ret里面。</div><div class="line">             : "i" (T_SYSCALL),  // 这里随意选择一个寄存器</div><div class="line">               "a" (num),        // 把想要调用的中断号给eax</div><div class="line">               "d" (a1),         // 第一个参数给edx</div><div class="line">               "c" (a2),         // 第二个参数给ecx</div><div class="line">               "b" (a3),         // 第三个参数给ebx</div><div class="line">               "D" (a4),         // 第四个参数给edi</div><div class="line">               "S" (a5)          // 第五个参数给esi</div><div class="line">             : "cc", "memory");</div><div class="line"></div><div class="line">    // 如果我们的指令可以修改条件码寄存器（cc），我们必须将 "cc" 添加进修饰寄存器列表。</div><div class="line">    // 如果我们的指令以不可预测的方式修改了内存，那么需要将 "memory" 添加进修饰寄存器列表。</div><div class="line">    if(check &amp;&amp; ret &gt; 0)</div><div class="line">        panic("syscall %d returned %d (&gt; 0)", num, ret);</div><div class="line"></div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以在写底层<code>OS</code>的实现的时候，也一定要注意到这么一点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">case</span> T_SYSCALL:</div><div class="line">    <span class="keyword">if</span> (tf-&gt;tf_regs.reg_eax &gt;= NSYSCALLS) <span class="keyword">return</span> -E_INVAL;</div><div class="line">    tf-&gt;tf_regs.reg_eax = syscall(</div><div class="line">        tf-&gt;tf_regs.reg_eax,</div><div class="line">        tf-&gt;tf_regs.reg_edx,</div><div class="line">        tf-&gt;tf_regs.reg_ecx,</div><div class="line">        tf-&gt;tf_regs.reg_ebx,</div><div class="line">        tf-&gt;tf_regs.reg_edi,</div><div class="line">        tf-&gt;tf_regs.reg_esi</div><div class="line">    );</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>系统要实现的系统调用也没有太多。也就是<code>enum</code>那里列出来的那几个。所以在实现的时候，只需要通过<br><code>case</code>语句把系统调用引导过去就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></div><div class="line"><span class="keyword">int32_t</span></div><div class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></div><div class="line">    <span class="comment">// Return any appropriate return value.</span></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    <span class="keyword">switch</span> (syscallno) &#123;</div><div class="line">        <span class="keyword">case</span> SYS_cputs:</div><div class="line">            sys_cputs((<span class="keyword">char</span>*)a1, (<span class="keyword">size_t</span>)a2);</div><div class="line">        <span class="keyword">case</span> SYS_cgetc:</div><div class="line">            <span class="keyword">return</span> sys_cgetc();</div><div class="line">        <span class="keyword">case</span> SYS_getenvid:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_getenvid();</div><div class="line">        <span class="keyword">case</span> SYS_env_destroy:</div><div class="line">            assert(curenv);</div><div class="line">            <span class="keyword">return</span> sys_env_destroy(sys_getenvid());</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> -E_INVAL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="内存的检测"><a href="#内存的检测" class="headerlink" title="内存的检测"></a>内存的检测</h2><p>接下来就会看到<code>SYS_cputs</code>函数里面是需要检查一下用户权限是否可以访问内存区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Print a string to the system console.</span></div><div class="line"><span class="comment">// The string is exactly 'len' characters long.</span></div><div class="line"><span class="comment">// Destroys the environment on memory errors.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></div><div class="line">    <span class="comment">// Destroy the environment if not.</span></div><div class="line"></div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_assert(curenv, s, len, PTE_P|PTE_U);</div><div class="line">    <span class="comment">// Print the string supplied by the user.</span></div><div class="line">    cprintf(<span class="string">"%.*s"</span>, len, s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这里<code>user_mem_assert</code>是需要在<code>kern/pmap.c</code>里面去实现的。代码跳转过去，会发现代码里<br>需要实现的是<code>user_mem_check()</code>。</p>
<p>首先给出一种低效的版本，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int</div><div class="line">user_mem_check(struct Env *env, const void *va, size_t len, int perm)</div><div class="line">&#123;</div><div class="line">    // LAB 3: Your code here.</div><div class="line">    // LAB 3: DONE</div><div class="line">    user_mem_check_addr = 0;</div><div class="line">    for (const void *b = va; (b - va) &lt; len; b++) &#123;</div><div class="line">        user_mem_check_addr = (size_t)b &lt; ULIM ? 0 : (size_t)b;</div><div class="line">        if (!user_mem_check_addr) &#123;</div><div class="line">            pte_t *pte = pgdir_walk(env-&gt;env_pgdir, b, 0);</div><div class="line">            if (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (size_t)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (user_mem_check_addr) return -E_FAULT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，为了防止溢出，在条件判断的时候，最好是使用<code>b-va &lt; len</code>这种格式。<br>这个处理实际上是比较简单粗爆的。每个内存地址都需要依次检查一下。<br>假设要检查的地址是<code>10 ~ 4097</code>。在检查完地址<code>10</code>之后。实际上是可以跳到下<br>一个页面大小对齐的地址上去的。也就是4096。这里处理起来非常简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">b = 当前地址</div><div class="line">// 要找到下一个页面对齐的地址</div><div class="line">b = ROUNDDOWN(b, PGSIZE) + PGSIZE</div></pre></td></tr></table></figure>
<p>那么代码就可以很容易地精简如下了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// LAB 3: Your code here.</span></div><div class="line">    <span class="comment">// LAB 3: DONE</span></div><div class="line">    user_mem_check_addr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">void</span> *b = va; (b - va) &lt; len; b += PGSIZE) &#123;</div><div class="line">        <span class="comment">// 注意在这里检查一下内存地址的有效性</span></div><div class="line">        user_mem_check_addr = (<span class="keyword">size_t</span>)b &lt; ULIM ? <span class="number">0</span> : (<span class="keyword">size_t</span>)b;</div><div class="line">        <span class="keyword">if</span> (!user_mem_check_addr) &#123;</div><div class="line">            <span class="keyword">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, b, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span> (!pte || !(*pte &amp; (PTE_P|perm|PTE_U))) &#123;</div><div class="line">                user_mem_check_addr = (<span class="keyword">size_t</span>)b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (user_mem_check_addr) <span class="keyword">return</span> -E_FAULT;</div><div class="line">        b = ROUNDDOWN(b, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab3" data-title="MIT 6.828 Lab3" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-mit.6.828/jos-lab2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/19/mit.6.828/jos-lab2/" class="article-date">
  	<time datetime="2018-04-19T14:28:32.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/19/mit.6.828/jos-lab2/">MIT 6.828 Lab2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h1><p>In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">boot_alloc()</div><div class="line">mem_init() (only up to the call to check_page_free_list(<span class="number">1</span>))</div><div class="line">page_init()</div><div class="line">page_alloc()</div><div class="line">page_free()</div></pre></td></tr></table></figure>
<p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</p>
<p>总的来说，就是需要实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">boot_alloc()</div><div class="line">mem_init() <span class="comment">// 只需要实现到check_page_free_list(1)这里。</span></div><div class="line">page_init()</div><div class="line">page_alloc()</div><div class="line">page_free()</div></pre></td></tr></table></figure>
<h1 id="bootloader读入内核代码之后的分布"><a href="#bootloader读入内核代码之后的分布" class="headerlink" title="bootloader读入内核代码之后的分布"></a>bootloader读入内核代码之后的分布</h1><p><a href="http://lzz5235.github.io/2014/03/04/jos.html" target="_blank" rel="external">内存分布</a></p>
<p>这里主要是引用一下这个图：</p>
<p><img src="http://lzz5235.github.io/assets/pic/235.png" alt=""></p>
<p>可以发现，在刚读取完成内核代码到内存之后。形成的结构如上图所示。</p>
<h1 id="开启分页"><a href="#开启分页" class="headerlink" title="开启分页"></a>开启分页</h1><p>分页的机制在《x86汇编语言－从实模式到保护模式》里面介绍得比较清楚。这里就不多说，只引用<a href="http://neilsh.me/2015/07/02/os_setup_and_virtual_memory_setup/" target="_blank" rel="external">一张图</a>：</p>
<p><img src="http://ww1.sinaimg.cn/large/7f793092gw1etosykok6uj216o1kwdq0.jpg" alt=""></p>
<h2 id="UVPT"><a href="#UVPT" class="headerlink" title="UVPT"></a>UVPT</h2><p>UVPT: 需要看 <a href="https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.828/2014/lec/l-josmem.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">UVPT = 0x3BD &lt;&lt; 22</div></pre></td></tr></table></figure>
<h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><p>如果一个虚拟地址等于<code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0</code>。<br>使用<code>kern_pgdir</code>的时候，这个虚拟地址MCU处理之后就是<code>kern_pgdir</code>。</p>
<p>所以 <code>*(0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0) == kern_pgdir</code>。<br>那么，假设有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    p[i]; <span class="comment">// 这里实际上就是在遍历kern_pgdir[i];    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以<code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0~4096</code>byte地址，就是映射到了<code>char kern_pgdir[4096]</code><br>这个数组。</p>
<h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><p>那么假设虚拟地址是<code>0x3BD  &lt;&lt; 22 | 0~1024 | 0</code>这个时候情况又是如何？比如用户程序访问<code>0x3BD &lt;&lt; 22</code>这个地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. CR3 = kern_pgdir</div><div class="line">2. 高10位值为0x3BD, 页目录项为kern_pgdir[0x3BD]</div><div class="line">   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</div><div class="line">   不用说，又回到了kern_pgdir</div><div class="line">3. 中间10位为0，那么页表为kern_pgdir[0x3BD]指向的物理地址的第0项。</div><div class="line">   由于kern_pgdir[0x3BD]指向的是kern_pgdir，所以这里页表为kern_pgdir[0]。</div><div class="line">   kern_pgdir[0]用户程序是可以访问的。在Case 1里面已经验证过了。</div><div class="line">4. 虚拟地址就是kern_pgdir[0]指向的物理地址的第0项。不过这个物理地址，用户程序不一定可以访问。</div></pre></td></tr></table></figure>
<p>所以总结一下就是<code>0x3BD &lt;&lt; 22 | 0 ~ 1024 | xxxx</code>。这个时候，前面<code>20</code>位的地址一解释。指向的地址就是一个<br>页表地址<code>kern_pgdir[i]</code>。如果再加上<code>offset = xxxx</code>。实际上这个地址，虚拟地址不一定可以访问。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>0x3BD  &lt;&lt; 22 | 0x3BD &lt;&lt; 12 | 0~4096</code>byte地址，就是映射到了<code>char kern_pgdir[4096]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    p[i]; <span class="comment">// 这里实际上就是在遍历uint32_t kern_pgdir[i];    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>UVPT ~ UVPT + 4MB</code>这个虚拟地址应该会有至少一个页目录项。一个页目录项刚好点4MB。结合Case 2。可以发现，<br>用户程序通过kern_pgdir这个数组里面的内容，就知道这4MB空间里面的页表的内容。比如是否有物理地址映射？<br>是否已经分配内存。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="number">0x3BD</span>  &lt;&lt; <span class="number">22</span> | <span class="number">0x3BD</span> &lt;&lt; <span class="number">12</span> | <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (*(p+i) &amp; <span class="number">0x01</span>) &#123;</div><div class="line">        <span class="comment">// 二级页表存在</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 二级页表不存在</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h2><p>这个函数首先来，<code>end</code>变量是定义在<code>kernel.ld</code>文件里面的。指向了内核地址的尾巴。<br>也就是在向内核要虚拟地址的时候，可以从这里开始要。</p>
<p><strong>注意</strong>这里要到的地址是虚拟地址。不是物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></div><div class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span></div><div class="line"><span class="comment">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></div><div class="line"><span class="comment">// anything.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If we're out of memory, boot_alloc should panic.</span></div><div class="line"><span class="comment">// This function may ONLY be used during initialization,</span></div><div class="line"><span class="comment">// before the page_free_list list has been set up.</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></div><div class="line">    <span class="keyword">char</span> *result;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></div><div class="line">    <span class="comment">// 'end' is a magic symbol automatically generated by the linker,</span></div><div class="line">    <span class="comment">// which points to the end of the kernel's bss segment:</span></div><div class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></div><div class="line">    <span class="comment">// to any kernel code or global variables.</span></div><div class="line">    <span class="keyword">if</span> (!nextfree) &#123;</div><div class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</div><div class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></div><div class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></div><div class="line">    <span class="comment">// to a multiple of PGSIZE.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// LAB 2: Your code here.</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == n) &#123;</div><div class="line">        <span class="keyword">return</span> nextfree;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    n = ROUNDUP(n, PGSIZE);</div><div class="line">    result = nextfree;</div><div class="line">    nextfree += n;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init"></a>mem_init</h2><p>这个函数里面分为页管理链表分配空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">n = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages;</div><div class="line">pages = (<span class="keyword">struct</span> PageInfo*)boot_alloc(n);</div><div class="line"><span class="built_in">memset</span>(pagees, <span class="number">0</span>, n);</div></pre></td></tr></table></figure>
<p>注意看注释，要求全部初始化为0的。</p>
<h2 id="page-init"><a href="#page-init" class="headerlink" title="page_init"></a>page_init</h2><p>这里要做的事情很简单，就是把空闲的内存通过双向链表串起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// The example code here marks all physical pages as free.</span></div><div class="line">    <span class="comment">// However this is not truly the case.  What memory is free?</span></div><div class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></div><div class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></div><div class="line">    <span class="comment">//     in case we ever need them.  (Currently we don't, but...)</span></div><div class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></div><div class="line">    <span class="comment">//     is free.</span></div><div class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></div><div class="line">    <span class="comment">//     never be allocated.</span></div><div class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></div><div class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></div><div class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></div><div class="line">    <span class="comment">//     page tables and other data structures?</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// Change the code to reflect this.</span></div><div class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></div><div class="line">    <span class="comment">// free pages!</span></div><div class="line">    <span class="keyword">size_t</span> i;</div><div class="line">    <span class="comment">// 这里采用的思路是：凡是不能被分配的内存页，都不加到链表里面。</span></div><div class="line">    <span class="comment">// 只处理可以被使用的内存页。</span></div><div class="line">    assert(!page_free_list);</div><div class="line">    <span class="comment">// 1. page 0是要被用来做实模式的IDT BIOS数据结构，尽管从来不会用，以后也不会用</span></div><div class="line">    <span class="comment">//    这不是浪费么。不管了。</span></div><div class="line">    <span class="comment">// 2. 接下来的[PGSIZE, npages_basemem * PGSIZE)是可用的。</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</div><div class="line">        pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">        pages[i].pp_link = page_free_list;</div><div class="line">        page_free_list = &amp;pages[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3. IO空洞，绝对不能使用。</span></div><div class="line">    <span class="comment">//    链表直接跳过。不管。</span></div><div class="line"></div><div class="line">    <span class="comment">// 4. 直接找到kernel内存的尾巴</span></div><div class="line">    <span class="comment">//    注意这里取了PADDR之后要除PGSIZE.</span></div><div class="line">    <span class="keyword">for</span> (i = PADDR(boot_alloc(<span class="number">0</span>))/PGSIZE; i &lt; npages; i++) &#123;        </div><div class="line">        pages[i].pp_ref = <span class="number">0</span>;</div><div class="line">        pages[i].pp_link = page_free_list;</div><div class="line">        page_free_list = &amp;pages[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc"></a>page_alloc</h2><p>page_alloc的功能就是从链表中分配一页。这里需要完全照着注释来实现。比如<code>pp_link</code>要设置为空。<code>pp_ref</code>不要去修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> PageInfo *</span></div><div class="line"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">struct</span> PageInfo *ret = page_free_list;</div><div class="line">    <span class="keyword">if</span> (!page_free_list) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    page_free_list = ret-&gt;pp_link;</div><div class="line">    ret-&gt;pp_link = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</div><div class="line">        <span class="built_in">memset</span>(page2kva(ret), <span class="number">0</span>, PGSIZE);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-free"><a href="#page-free" class="headerlink" title="page_free"></a>page_free</h2><p>这里会把一个<code>pp_ref</code>为0的页表放回到链表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></div><div class="line">    assert(!pp-&gt;pp_ref);</div><div class="line">    assert(!pp-&gt;pp_link);</div><div class="line"></div><div class="line">    pp-&gt;pp_link = page_free_list;</div><div class="line">    page_free_list = pp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Excersize-3"><a href="#Excersize-3" class="headerlink" title="Excersize 3"></a>Excersize 3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">　　xp/Nx paddr -- 查看paddr物理地址处开始的，N个字的16进制的表示结果。</div><div class="line">　　info registers -- 展示所有内部寄存器的状态。</div><div class="line">　　info mem -- 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</div><div class="line">　　info pg -- 展示当前页表的结构。</div></pre></td></tr></table></figure>
<h1 id="Excersize-4"><a href="#Excersize-4" class="headerlink" title="Excersize 4"></a>Excersize 4</h1><h2 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h2><p><code>pgdir_walk</code>只是在给定的页表中查一下虚拟地址的<strong>页目录项</strong>。并不需要页目录项与虚拟地址绑定。如果存在页目录项，那么只需要直接返回相应的页目录项。<br>就是在写<code>if/else</code>的时候要考虑各种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">pte_t</span> *</div><div class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    assert(pgdir);</div><div class="line">    <span class="keyword">pde_t</span> *pde = &amp;pgdir[PDX(va)];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(*pde &amp; PTE_P)) &#123;</div><div class="line">        <span class="keyword">if</span> (!create) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> PageInfo *page = page_alloc(ALLOC_ZERO);</div><div class="line">        <span class="keyword">if</span> (!page) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        page-&gt;pp_ref++;</div><div class="line">        assert(page-&gt;pp_ref == <span class="number">1</span>);</div><div class="line">        assert(page-&gt;pp_link == <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        *pde = page2pa(page) | PTE_P | PTE_U | PTE_W;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取页表项</span></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">pte_t</span>*)(KADDR(PTE_ADDR(*pde))) + PTX(va);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region"></a>boot_map_region</h2><p>把一个虚拟内存映射一个物理内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; size; i += PGSIZE) &#123;</div><div class="line">        <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, (<span class="keyword">const</span> <span class="keyword">void</span> *)va, <span class="literal">true</span>);</div><div class="line">        *pte = pa | perm | PTE_P;</div><div class="line">        va += PGSIZE;</div><div class="line">        pa += PGSIZE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的设置。</p>
<h2 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert"></a>page_insert</h2><p>写这个函数的时候，要特别仔细地把注释读一下。<code>boot_map_region</code>在映射的时候。<br>并没有考虑到页表的占用释放回收什么的（直接把这个空间里面的物理内存映射到了<code>kern_pgdir</code>里面），这是因为<code>boot_map_region</code>这个函数操作的都是已经在kernel里面申请好的内存。并且页表的管理是从<code>boot_alloc(0)</code>之后才开始管理的。所以内核里面的页在添加到的<code>kernel_pgdir</code>的时候并不会用<code>PageInfo</code>来进行管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (!pte)</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">    pp-&gt;pp_ref++;</div><div class="line">    <span class="keyword">if</span> (*pte &amp; PTE_P)</div><div class="line">        page_remove(pgdir, va);</div><div class="line">    *pte = page2pa(pp) | perm | PTE_P;</div><div class="line">    tlb_invalidate(pgdir, va);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup"></a>page_lookup</h2><p>这个函数的功能就是给定一个虚拟地址。然后根据这个虚拟地址来找到相应的物理地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> PageInfo *</span></div><div class="line"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class="literal">false</span>);</div><div class="line">    <span class="keyword">if</span> (!pte || !(*pte &amp; PTE_P)) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (pte_store) *pte_store = pte;</div><div class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(*pte));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove"></a>page_remove</h2><p><code>page_remove</code>这个函数的功能主要是取消虚拟地址与物理地址的关联。<br>这里需要注意的是。释放了虚拟内存与物理内存的映射之后。并没有直接把相应的物理内存直接放到链表里面。这主要是因为，可能存在多个虚拟内存映射到同一个物理内页面的情况。虽然这个虚拟内存不在与这个物理内存发生联系了。但是其他的虚拟地址还是有可能继续与这个物理内存关联并且还在使用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Fill this function in</span></div><div class="line">    <span class="keyword">pte_t</span> *pte = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> PageInfo *pp = page_lookup(pgdir, va, &amp;pte);</div><div class="line">    <span class="keyword">if</span> (!pp) <span class="keyword">return</span>;</div><div class="line">    *pte = <span class="number">0</span>;</div><div class="line">    page_decref(pp);</div><div class="line">    tlb_invalidate(pgdir, va);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Excersize-5"><a href="#Excersize-5" class="headerlink" title="Excersize 5"></a>Excersize 5</h2><p>mem_init()</p>
<p>这里主要是要把内核里面一些区域设置到页目录中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// 注意这里用的是PTSIZE</span></div><div class="line"><span class="comment">// 一种保守的作法是把pages align到页大小之后再进行映射。</span></div><div class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Use the physical memory that 'bootstack' refers to as the kernel</span></div><div class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></div><div class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></div><div class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></div><div class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></div><div class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></div><div class="line"><span class="comment">//       overwrite memory.  Known as a "guard page".</span></div><div class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);    </div><div class="line"></div><div class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></div><div class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></div><div class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></div><div class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></div><div class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></div><div class="line"><span class="comment">// we just set up the mapping anyway.</span></div><div class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></div><div class="line"><span class="comment">// Your code goes here:</span></div><div class="line"><span class="comment">// KERNBASE    0x F0000000</span></div><div class="line"><span class="comment">// 2^32 =      0x 1000 0000</span></div><div class="line"><span class="comment">// 256MB</span></div><div class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0x10000000</span>, <span class="number">0</span>, PTE_W);</div></pre></td></tr></table></figure>
<p>接下来还有一系列小问题。比如</p>
<h3 id="kern-pgdir里面的内容是什么？"><a href="#kern-pgdir里面的内容是什么？" class="headerlink" title="kern_pgdir里面的内容是什么？"></a>kern_pgdir里面的内容是什么？</h3><p>这个问题其实只需要看一下<code>mem_init</code>里面的<code>boot_map_region</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</div><div class="line">Entry    Base Virtual Address    Points to (logically):</div><div class="line">1023    ?    Page table for top 4MB of phys memory</div><div class="line">1022    ?    ?</div><div class="line">.    ?    ?</div><div class="line">.    ?    ?</div><div class="line">.    ?    ?</div><div class="line">2    0x00800000    ?</div><div class="line">1    0x00400000    ?</div><div class="line">0    0x00000000    [see next question]</div></pre></td></tr></table></figure>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
<p>这个问题是因为页表里面有各种保护机制。</p>
<h3 id="最大能支持的内存是多少？"><a href="#最大能支持的内存是多少？" class="headerlink" title="最大能支持的内存是多少？"></a>最大能支持的内存是多少？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</div><div class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</div><div class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</div><div class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</div><div class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</div></pre></td></tr></table></figure>
<p>这里UPAGES对应的就是<code>pages</code>这个链表。程序空间在利用虚拟地址访问<code>pages</code>的时候。一旦大于<code>4MB</code>，比如越界到了<code>UVPT</code>这个空间。由于这部分虚拟地址是放到了<code>kern_pgdir</code>里面。所以这个时候超出的部分就不能访问了。也就意味着：物理空间上，<code>pages</code>占用多大空间都没有问题。但是虚拟地址空间在访问<code>UPAGES</code>的时候就是不能访问全。因此，能支持的内存大小就变成了2GB。</p>
<h3 id="How-much-space-overhead-is-there-for-managing-memory-if-we-actually-had-the-maximum-amount-of-physical-memory-How-is-this-overhead-broken-down"><a href="#How-much-space-overhead-is-there-for-managing-memory-if-we-actually-had-the-maximum-amount-of-physical-memory-How-is-this-overhead-broken-down" class="headerlink" title="How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?"></a>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</h3><p>这里是说现在管理内存的开销是多少？其实直接看虚拟地址就可以明白了。一个页目录表占用4MB。而<code>UPAGES</code>占用了4MB。所以合在一起就是8MB。如果要减小开销。</p>
<h3 id="内存访问的问题"><a href="#内存访问的问题" class="headerlink" title="内存访问的问题"></a>内存访问的问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Q1. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE?</div><div class="line"></div><div class="line">Q2. What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</div></pre></td></tr></table></figure>
<p>Q1. 当还在利用<code>kern/entry.S</code>和<code>kern/entrypgdir.c</code>的时候。一打开分页的时候，EIP还在一个低端的物理地址上。是通过什么方式让EIP跑到<code>KERNBASE</code>之上的内核虚拟地址空间运行的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    mov    $relocated, %eax</div><div class="line">    jmp    *%eax</div><div class="line">relocated:</div><div class="line"></div><div class="line">    # Clear the frame pointer register (EBP)</div><div class="line">    # so that once we get into debugging C code,</div><div class="line">    # stack backtraces will be terminated properly.</div><div class="line">    movl    $0x0,%ebp            # nuke frame pointer</div></pre></td></tr></table></figure>
<p>Q2. 问的是说，实际上当打开分页的时候，EIP还是在低地址运行。然后再通过跳转跑到高端地址。打开分页的时候，EIP指向下一条指令。即｀move $relocated, %eax`的内存地址。为什么访问这个内存地址不会失败?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> kern/entrypgdir.c 中将 0 ~ 4MB 和 KERNBASE ~ KERNBASE + 4 MB 的虚拟地址都映射到了 0 ~ 4MB 的物理地址上，因此无论 EIP 在高位和低位都能执行。必需这么做是因为如果只映射高位地址，那么在开启分页机制的下一条语句就会crash。</div><div class="line">`</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/mit-6-828/">mit.6.828</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/mit-6-828/">mit.6.828</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-mit.6.828/jos-lab2" data-title="MIT 6.828 Lab2" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/1.Object" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/15/ceph/1.Object/" class="article-date">
  	<time datetime="2018-04-14T21:28:32.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/15/ceph/1.Object/">1.1 各种Object</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-object-t"><a href="#1-object-t" class="headerlink" title="1. object_t"></a>1. object_t</h1><p>这个object_t实际上就是只有一个name在起作用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="keyword">object_t</span> &#123;</div><div class="line">  <span class="built_in">string</span> name;</div><div class="line"></div><div class="line">  <span class="keyword">object_t</span>() &#123;&#125;</div><div class="line">  <span class="comment">// cppcheck-suppress noExplicitConstructor</span></div><div class="line">  <span class="keyword">object_t</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s) : name(s) &#123;&#125;</div><div class="line">  <span class="comment">// cppcheck-suppress noExplicitConstructor</span></div><div class="line">  <span class="keyword">object_t</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : name(s) &#123;&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">object_t</span>&amp; o)</span> </span>&#123;</div><div class="line">    name.swap(o.name);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    name.clear();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(bufferlist &amp;bl)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> ceph::encode;</div><div class="line">    encode(name, bl);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(bufferlist::const_iterator &amp;bl)</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> ceph::decode;</div><div class="line">    decode(name, bl);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">WRITE_CLASS_ENCODER(<span class="keyword">object_t</span>)</div></pre></td></tr></table></figure>
<p>尾部的这个宏，实际上没有什么特别的。这里可以把这个宏展开。</p>
<h2 id="WRITE-CLASS-ENCODER"><a href="#WRITE-CLASS-ENCODER" class="headerlink" title="WRITE_CLASS_ENCODER"></a>WRITE_CLASS_ENCODER</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_CLASS_ENCODER(cl)                     \</span></div><div class="line">  inline void encode(const cl &amp;c, ::ceph::bufferlist &amp;bl, uint64_t features=0) &#123; \</div><div class="line">    ENCODE_DUMP_PRE(); c.encode(bl); ENCODE_DUMP_POST(cl); &#125;        \</div><div class="line">  inline void decode(cl &amp;c, ::ceph::bufferlist::const_iterator &amp;p) &#123; c.decode(p); &#125;</div></pre></td></tr></table></figure>
<p>展开之后的代码就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> cl &amp;c, ::ceph::bufferlist &amp;bl, <span class="keyword">uint64_t</span> features=<span class="number">0</span>)</span> </span>&#123;</div><div class="line">  ENCODE_DUMP_PRE();   <span class="comment">// -&gt; 这两个是没有什么用的</span></div><div class="line">  c.encode(bl);</div><div class="line">  ENCODE_DUMP_POST(cl);  <span class="comment">// 这个宏的作用就是说想把dump出来的object打印到/tmp目录。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(cl &amp;c, ::ceph::bufferlist::const_iterator &amp;p)</span> </span>&#123;</div><div class="line">   c.decode(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以这两个宏的作用就是直接调用类的encode和decode函数。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>object_t</code>只提供了<code>name</code>并没有提供其他任何存储空间，那么一个<code>object</code>的内容在哪里呢？</p>
<h2 id="重载运算符函数"><a href="#重载运算符函数" class="headerlink" title="重载运算符函数"></a>重载运算符函数</h2><p>针对于<code>object_t</code>，<code>Ceph</code>重载了很多运算符，看起来是比较繁锁的，就是不知道有没有更加简便的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name == r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name != r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name &gt; r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name &lt; r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name &gt;= r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; l, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) &#123;</div><div class="line">  <span class="keyword">return</span> l.name &lt;= r.name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="keyword">const</span> <span class="keyword">object_t</span>&amp; o) &#123;</div><div class="line">  <span class="keyword">return</span> out &lt;&lt; o.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如是只是为了支持<code>hash</code>函数，那么只需要<code>==</code>被重载就可以了。</p>
<h2 id="如何自定义hash支持"><a href="#如何自定义hash支持" class="headerlink" title="如何自定义hash支持"></a>如何自定义hash支持</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">  <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> hash&lt;<span class="keyword">object_t</span>&gt; &#123;</div><div class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">object_t</span>&amp; r) <span class="keyword">const</span> &#123;</div><div class="line">      <span class="comment">//static hash&lt;string&gt; H;</span></div><div class="line">      <span class="comment">//return H(r.name);</span></div><div class="line">      <span class="keyword">return</span> ceph_str_hash_linux(r.name.c_str(), r.name.length());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125; <span class="comment">// namespace std</span></div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/1.Object" data-title="1.1 各种Object" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
    <article id="post-ceph/2.chrono" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2018/04/15/ceph/2.chrono/" class="article-date">
  	<time datetime="2018-04-14T21:28:32.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/04/15/ceph/2.chrono/">1.2 Chrono Duration</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先看一下标准库的使用以及概念。首先是一个概念<code>ratio</code>，<code>ratio</code>表示的是一个概念，就是单位。</p>
<p>Durations表示的是一段时间。比如10秒钟，2个小时。</p>
<h1 id="Ratio"><a href="#Ratio" class="headerlink" title="Ratio"></a>Ratio</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">intmax_t</span> N, <span class="keyword">intmax_t</span> D = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</div></pre></td></tr></table></figure>
<p>先看<code>D</code>，<code>D</code>表示一秒可以被切分成多少份。<code>N</code>就是表示有多少份。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;                      seconds</div></pre></td></tr></table></figure>
<p>这里就是表示1秒。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;               microseconds</div></pre></td></tr></table></figure>
<p>这个就是表示毫秒。</p>
<p>另外一种简单的观点，就是<code>N/D</code>秒就是<code>ratio</code>的值。</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">ratio&lt;<span class="number">3600</span>, <span class="number">1</span>&gt;                hours          <span class="number">3600</span>/<span class="number">1</span> = <span class="number">3600</span>秒</div><div class="line">ratio&lt;<span class="number">60</span>, <span class="number">1</span>&gt;                  minutes          <span class="number">60</span>/<span class="number">1</span> = <span class="number">60</span>秒</div><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;                   seconds</div><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;                microseconds</div><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;             microseconds</div><div class="line">ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt;          nanosecons</div></pre></td></tr></table></figure>
<p><strong>注意</strong>我们自己可以定义Period，比如<code>ratio&lt;1, -2&gt;</code>表示单位时间是<code>-0.5</code>秒。</p>
<h1 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h1><p>这个用来表示一段时间，比如一天，2个小时，10秒钟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period = ratio&lt;<span class="number">1</span>&gt; &gt; <span class="keyword">class</span> duration;</div></pre></td></tr></table></figure>
<p>Rep表示一种数值类型，用来表示Period的数量，比如<code>int float double</code><br>Period是ratio类型，用来表示时间度量单位。比如经过了2纳秒。这里Period就是用<code>ratio&lt;1, 1000000000&gt;          nanosecons</code>来表示。</p>
<h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ToDuration, <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period&gt;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> ToDuration <span class="title">duration_cast</span> <span class="params">(<span class="keyword">const</span> duration&lt;Rep,Period&gt;&amp; dtn)</span></span>;</div></pre></td></tr></table></figure>
<p>这个函数的作用是把一种duration转换成另外一种durantion的表达。</p>
<h1 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h1><p>当然，对于很多常用的时间类型，标准库里面也进行了定义。不过需要注意的是，这些不是一个常量，而是一个类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// nanoseconds</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, nano&gt;         nanoseconds;</div><div class="line"><span class="comment">/// microseconds</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, micro&gt;        microseconds;</div><div class="line"><span class="comment">/// milliseconds</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, milli&gt;        milliseconds;</div><div class="line"><span class="comment">/// seconds</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>&gt; 		        seconds</div><div class="line"><span class="comment">/// minutes</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt; <span class="number">60</span>&gt;&gt;   minutes</div><div class="line"><span class="comment">/// hours</span></div><div class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;  hours;</div></pre></td></tr></table></figure>
<p>所以在使用的时候，可以直接使用这些时间单位。比如休眠一段时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>)); <span class="comment">//休眠三秒</span></div><div class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>)); <span class="comment">//休眠100毫秒</span></div></pre></td></tr></table></figure>
<h1 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h1><p>有时候，也可以计算有多个少<code>X</code>为单位的时间。这个<code>X</code>可以是毫秒，也可能是纳秒等等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里只有3毫秒，所以count结果为3.</span></div><div class="line">    <span class="built_in">std</span>::chrono::milliseconds ms&#123;<span class="number">3</span>&#125;; <span class="comment">// 3 毫秒</span></div><div class="line">    <span class="comment">// 6000 microseconds constructed from 3 milliseconds</span></div><div class="line">    <span class="comment">// 这里单位变成了micro second</span></div><div class="line">    <span class="comment">// 2*ms则是6ms，也就是6000微秒</span></div><div class="line">    <span class="built_in">std</span>::chrono::microseconds us = <span class="number">2</span>*ms; <span class="comment">//6000微秒</span></div><div class="line">    <span class="comment">// 30Hz clock using fractional ticks</span></div><div class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; hz30(<span class="number">3.5</span>);</div><div class="line">    <span class="comment">// 这里的输出是3.5</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hz30 has"</span> &lt;&lt; hz30.count() &lt;&lt; <span class="string">" ticks\n"</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"3 ms duration has "</span> &lt;&lt; ms.count() &lt;&lt; <span class="string">" ticks\n"</span>&lt;&lt;  <span class="string">"6000 us duration has "</span> &lt;&lt; us.count() &lt;&lt; <span class="string">" ticks\n"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">hz30 has3.5 ticks</div><div class="line">3 ms duration has 3 ticks</div><div class="line">6000 us duration has 6000 ticks</div></pre></td></tr></table></figure>
<h1 id="时间的计算"><a href="#时间的计算" class="headerlink" title="时间的计算"></a>时间的计算</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::chrono::<span class="function">minutes <span class="title">t1</span><span class="params">( <span class="number">10</span> )</span></span>;</div><div class="line">    <span class="built_in">std</span>::chrono::<span class="function">seconds <span class="title">t2</span><span class="params">( <span class="number">60</span> )</span></span>;</div><div class="line">    <span class="built_in">std</span>::chrono::seconds t3 = t1 - t2;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t3.count() &lt;&lt; <span class="string">" second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">540 second</div></pre></td></tr></table></figure>
<h1 id="时间的转换"><a href="#时间的转换" class="headerlink" title="时间的转换"></a>时间的转换</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::chrono::<span class="function">minutes <span class="title">t1</span><span class="params">( <span class="number">10</span> )</span></span>;</div><div class="line">    <span class="built_in">std</span>::chrono::<span class="function">seconds <span class="title">t2</span><span class="params">( <span class="number">60</span> )</span></span>;</div><div class="line">    <span class="built_in">std</span>::chrono::seconds t3 = t1 - t2;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t3.count() &lt;&lt; <span class="string">" second"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;</div><div class="line">        <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::minutes&gt;(t3).count()</div><div class="line">        &lt;&lt; <span class="string">"minutes"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ceph/">ceph</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/ceph/">ceph</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-ceph/2.chrono" data-title="1.2 Chrono Duration" data-url="undefined"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'undefined'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/blog/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 You Ji
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /blog/
	}
</script>
<script src="/blog/js/require-2.1.6_jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

</script>



  </div>
</body>
</html>